// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017-2018 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.tests.integration_tests {
	
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.security;
	using net.named_data.jndn.security.pib;
	using net.named_data.jndn.security.tpm;
	using net.named_data.jndn.security.v2;
	using net.named_data.jndn.util;
	
	public class TestValidatorInterestOnly {
		internal HierarchicalValidatorFixture fixture_;
	
		public sealed class Anonymous_C7 : DataValidationSuccessCallback {
			public void successCallback(Data data) {
			}
		}
	
		public sealed class Anonymous_C6 : DataValidationFailureCallback {
			private readonly String message;
	
			public Anonymous_C6(String message_0) {
				this.message = message_0;
			}
	
			public void failureCallback(Data data, ValidationError error) {
				Assert.Fail(message);
			}
		}
	
		public sealed class Anonymous_C5 : DataValidationSuccessCallback {
			private readonly String message;
	
			public Anonymous_C5(String message_0) {
				this.message = message_0;
			}
	
			public void successCallback(Data data) {
				Assert.Fail(message);
			}
		}
	
		public sealed class Anonymous_C4 : DataValidationFailureCallback {
			public void failureCallback(Data data, ValidationError error) {
			}
		}
	
		public sealed class Anonymous_C3 : 			InterestValidationSuccessCallback {
			public void successCallback(Interest interest) {
			}
		}
	
		public sealed class Anonymous_C2 : 			InterestValidationFailureCallback {
			private readonly String message;
	
			public Anonymous_C2(String message_0) {
				this.message = message_0;
			}
	
			public void failureCallback(Interest interest,
					ValidationError error) {
				Assert.Fail(message);
			}
		}
	
		public sealed class Anonymous_C1 : 			InterestValidationSuccessCallback {
			private readonly String message;
	
			public Anonymous_C1(String message_0) {
				this.message = message_0;
			}
	
			public void successCallback(Interest interest) {
				Assert.Fail(message);
			}
		}
	
		public sealed class Anonymous_C0 : 			InterestValidationFailureCallback {
			public void failureCallback(Interest interest,
					ValidationError error) {
			}
		}
	
		internal class ValidationPolicySimpleHierarchyForInterestOnly : 			ValidationPolicySimpleHierarchy {
			public override void checkPolicy(Data data, ValidationState state,
					net.named_data.jndn.security.v2.ValidationPolicy.ValidationContinuation  continueValidation) {
				continueValidation.continueValidation(null, state);
			}
		}
	
		public void setUp() {
			// Turn off INFO log messages.
			ILOG.J2CsMapping.Util.Logging.Logger.getLogger("").setLevel(ILOG.J2CsMapping.Util.Logging.Level.SEVERE);
	
			fixture_ = new HierarchicalValidatorFixture(
					new TestValidatorInterestOnly.ValidationPolicySimpleHierarchyForInterestOnly ());
		}
	
		/// <summary>
		/// Call fixture_.validator_.validate and if it calls the failureCallback then
		/// fail the test with the given message.
		/// </summary>
		///
		/// <param name="data">The Data to validate.</param>
		/// <param name="message_0">The message to show if the test fails.</param>
		internal void validateExpectSuccess(Data data, String message_0) {
			fixture_.validator_.validate(data, new TestValidatorInterestOnly.Anonymous_C7 (), new TestValidatorInterestOnly.Anonymous_C6 (message_0));
		}
	
		/// <summary>
		/// Call fixture_.validator_.validate and if it calls the successCallback then
		/// fail the test with the given message.
		/// </summary>
		///
		/// <param name="data">The Data to validate.</param>
		/// <param name="message_0">The message to show if the test succeeds.</param>
		internal void validateExpectFailure(Data data, String message_0) {
			fixture_.validator_.validate(data, new TestValidatorInterestOnly.Anonymous_C5 (message_0), new TestValidatorInterestOnly.Anonymous_C4 ());
		}
	
		/// <summary>
		/// Call fixture_.validator_.validate and if it calls the failureCallback then
		/// fail the test with the given message.
		/// </summary>
		///
		/// <param name="interest">The Interest to validate.</param>
		/// <param name="message_0">The message to show if the test fails.</param>
		internal void validateExpectSuccess(Interest interest, String message_0) {
			fixture_.validator_.validate(interest,
					new TestValidatorInterestOnly.Anonymous_C3 (), new TestValidatorInterestOnly.Anonymous_C2 (message_0));
		}
	
		/// <summary>
		/// Call fixture_.validator_.validate and if it calls the successCallback then
		/// fail the test with the given message.
		/// </summary>
		///
		/// <param name="interest">The Interest to validate.</param>
		/// <param name="message_0">The message to show if the test succeeds.</param>
		internal void validateExpectFailure(Interest interest, String message_0) {
			fixture_.validator_.validate(interest,
					new TestValidatorInterestOnly.Anonymous_C1 (message_0), new TestValidatorInterestOnly.Anonymous_C0 ());
		}
	
		public void testValidateInterestsButBypassForData() {
			Interest interest = new Interest(new Name(
					"/Security/V2/ValidatorFixture/Sub1/Sub2/Interest"));
			Data data = new Data(new Name(
					"/Security/V2/ValidatorFixture/Sub1/Sub2/Interest"));
	
			validateExpectFailure(interest, "Unsigned");
			validateExpectSuccess(data,
					"The policy requests to bypass validation for all data");
			Assert.AssertEquals(0, fixture_.face_.sentInterests_.Count);
			ILOG.J2CsMapping.Collections.Collections.Clear(fixture_.face_.sentInterests_);
	
			interest = new Interest(new Name(
					"/Security/V2/ValidatorFixture/Sub1/Sub2/Interest"));
			fixture_.keyChain_.sign(interest, new SigningInfo(
					net.named_data.jndn.security.SigningInfo.SignerType.SHA256));
			fixture_.keyChain_.sign(data, new SigningInfo(
					net.named_data.jndn.security.SigningInfo.SignerType.SHA256));
			validateExpectFailure(interest,
					"Required KeyLocator/Name is missing (not passed to the policy)");
			validateExpectSuccess(data,
					"The policy requests to bypass validation for all data");
			Assert.AssertEquals(0, fixture_.face_.sentInterests_.Count);
			ILOG.J2CsMapping.Collections.Collections.Clear(fixture_.face_.sentInterests_);
	
			interest = new Interest(new Name(
					"/Security/V2/ValidatorFixture/Sub1/Sub2/Interest"));
			fixture_.keyChain_.sign(interest, new SigningInfo(fixture_.identity_));
			fixture_.keyChain_.sign(data, new SigningInfo(fixture_.identity_));
			validateExpectSuccess(interest,
					"Should be successful since it is signed by the anchor");
			validateExpectSuccess(data,
					"The policy requests to bypass validation for all data");
			Assert.AssertEquals(0, fixture_.face_.sentInterests_.Count);
			ILOG.J2CsMapping.Collections.Collections.Clear(fixture_.face_.sentInterests_);
	
			interest = new Interest(new Name(
					"/Security/V2/ValidatorFixture/Sub1/Sub2/Interest"));
			fixture_.keyChain_.sign(interest,
					new SigningInfo(fixture_.subIdentity_));
			fixture_.keyChain_.sign(data, new SigningInfo(fixture_.subIdentity_));
			validateExpectFailure(interest,
					"Should fail since the policy is not allowed to create new trust anchors");
			validateExpectSuccess(data,
					"The policy requests to bypass validation for all data");
			Assert.AssertEquals(1, fixture_.face_.sentInterests_.Count);
			ILOG.J2CsMapping.Collections.Collections.Clear(fixture_.face_.sentInterests_);
	
			interest = new Interest(new Name(
					"/Security/V2/ValidatorFixture/Sub1/Sub2/Interest"));
			fixture_.keyChain_.sign(interest, new SigningInfo(
					fixture_.otherIdentity_));
			fixture_.keyChain_.sign(data, new SigningInfo(fixture_.otherIdentity_));
			validateExpectFailure(interest,
					"Should fail since it is signed by a policy-violating certificate");
			validateExpectSuccess(data,
					"The policy requests to bypass validation for all data");
			// No network operations are expected since the certificate is not validated
			// by the policy.
			Assert.AssertEquals(0, fixture_.face_.sentInterests_.Count);
			ILOG.J2CsMapping.Collections.Collections.Clear(fixture_.face_.sentInterests_);
	
			// Make the trusted cache simulate a time 2 hours later, after expiration.
			fixture_.validator_.setCacheNowOffsetMilliseconds_(2 * 3600 * 1000.0d);
	
			interest = new Interest(new Name(
					"/Security/V2/ValidatorFixture/Sub1/Sub2/Interest"));
			fixture_.keyChain_.sign(interest, new SigningInfo(
					fixture_.subSelfSignedIdentity_));
			fixture_.keyChain_.sign(data, new SigningInfo(
					fixture_.subSelfSignedIdentity_));
			validateExpectFailure(interest,
					"Should fail since the policy is not allowed to create new trust anchors");
			validateExpectSuccess(data,
					"The policy requests to bypass validation for all data");
			Assert.AssertEquals(1, fixture_.face_.sentInterests_.Count);
			ILOG.J2CsMapping.Collections.Collections.Clear(fixture_.face_.sentInterests_);
		}
	
		// This is to force an import of net.named_data.jndn.util.
		private static Common dummyCommon_ = new Common();
	}
}
