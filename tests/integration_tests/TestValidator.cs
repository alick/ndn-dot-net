// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.tests.integration_tests {
	
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.security;
	using net.named_data.jndn.security.pib;
	using net.named_data.jndn.security.tpm;
	using net.named_data.jndn.security.v2;
	using net.named_data.jndn.util;
	
	public class TestValidator {
		public sealed class Anonymous_C7 : DataValidationSuccessCallback {
			public void successCallback(Data data) {
			}
		}
	
		public sealed class Anonymous_C6 : DataValidationFailureCallback {
			private readonly String message;
	
			public Anonymous_C6(String message_0) {
				this.message = message_0;
			}
	
			public void failureCallback(Data data, ValidationError error) {
				Assert.Fail(message);
			}
		}
	
		public sealed class Anonymous_C5 : DataValidationSuccessCallback {
			private readonly String message;
	
			public Anonymous_C5(String message_0) {
				this.message = message_0;
			}
	
			public void successCallback(Data data) {
				Assert.Fail(message);
			}
		}
	
		public sealed class Anonymous_C4 : DataValidationFailureCallback {
			public void failureCallback(Data data, ValidationError error) {
			}
		}
	
		public sealed class Anonymous_C3 : 			ValidatorFixture.TestFace.ProcessInterest {
			public void processInterest(Interest interest, OnData onData,
					OnTimeout onTimeout, OnNetworkNack onNetworkNack) {
				NetworkNack networkNack = new NetworkNack();
				networkNack.setReason(net.named_data.jndn.NetworkNack.Reason.NO_ROUTE);
	
				onNetworkNack.onNetworkNack(interest, networkNack);
			}
		}
	
		public sealed class Anonymous_C2 : 			ValidatorFixture.TestFace.ProcessInterest {
			private readonly Data malformedCertificate;
			private readonly net.named_data.jndn.tests.integration_tests.ValidatorFixture.TestFace.ProcessInterest  originalProcessInterest;
	
			public Anonymous_C2(Data malformedCertificate_0,
					net.named_data.jndn.tests.integration_tests.ValidatorFixture.TestFace.ProcessInterest  originalProcessInterest_1) {
				this.malformedCertificate = malformedCertificate_0;
				this.originalProcessInterest = originalProcessInterest_1;
			}
	
			public void processInterest(Interest interest, OnData onData,
					OnTimeout onTimeout, OnNetworkNack onNetworkNack) {
				if (interest.getName().isPrefixOf(
						malformedCertificate.getName()))
					onData.onData(interest, malformedCertificate);
				else
					originalProcessInterest.processInterest(interest, onData,
							onTimeout, onNetworkNack);
			}
		}
	
		public sealed class Anonymous_C1 : 			ValidatorFixture.TestFace.ProcessInterest {
			private readonly net.named_data.jndn.tests.integration_tests.ValidatorFixture.TestFace.ProcessInterest  originalProcessInterest;
			private readonly Data expiredCertificate;
	
			public Anonymous_C1(net.named_data.jndn.tests.integration_tests.ValidatorFixture.TestFace.ProcessInterest  originalProcessInterest_0,
					Data expiredCertificate_1) {
				this.originalProcessInterest = originalProcessInterest_0;
				this.expiredCertificate = expiredCertificate_1;
			}
	
			public void processInterest(Interest interest, OnData onData,
					OnTimeout onTimeout, OnNetworkNack onNetworkNack) {
				if (interest.getName().isPrefixOf(expiredCertificate.getName()))
					onData.onData(interest, expiredCertificate);
				else
					originalProcessInterest.processInterest(interest, onData,
							onTimeout, onNetworkNack);
			}
		}
	
		public sealed class Anonymous_C0 : 				ValidatorFixture.TestFace.ProcessInterest {
				private readonly TestValidator outer_TestValidator;
		
				public Anonymous_C0(TestValidator paramouter_TestValidator) {
					this.outer_TestValidator = paramouter_TestValidator;
				}
		
				public void processInterest(Interest interest, OnData onData,
						OnTimeout onTimeout, OnNetworkNack onNetworkNack) {
					try {
						// Create another key for the same identity and sign it properly.
						PibKey parentKey = outer_TestValidator.fixture_.keyChain_
								.createKey(outer_TestValidator.fixture_.subIdentity_);
						PibKey requestedKey = outer_TestValidator.fixture_.subIdentity_.getKey(interest
								.getName());
		
						// Copy the Name.
						Name certificateName = new Name(requestedKey.getName());
						certificateName.append("looper").appendVersion(1);
						CertificateV2 certificate = new CertificateV2();
						certificate.setName(certificateName);
		
						// Set the MetaInfo.
						certificate.getMetaInfo().setType(net.named_data.jndn.ContentType.KEY);
						// Set the freshness period to one hour.
						certificate.getMetaInfo().setFreshnessPeriod(3600 * 1000.0d);
		
						// Set the content.
						certificate.setContent(requestedKey.getPublicKey());
		
						// Set SigningInfo.
						SigningInfo // Set SigningInfo.
											paras = new SigningInfo(parentKey);
						// Validity period from 10 days before to 10 days after now.
						double now = net.named_data.jndn.util.Common.getNowMilliseconds();
						paras.setValidityPeriod(new ValidityPeriod(now - 10 * 24
								* 3600 * 1000.0d, now + 10 * 24 * 3600 * 1000.0d));
		
						outer_TestValidator.fixture_.keyChain_.sign(certificate, paras);
						onData.onData(interest, certificate);
					} catch (Exception ex) {
						Assert.Fail("Error in InfiniteCertificateChain: " + ex);
					}
				}
			}
	
		internal HierarchicalValidatorFixture fixture_;
	
		public void setUp() {
			// Turn off INFO log messages.
			ILOG.J2CsMapping.Util.Logging.Logger.getLogger("").setLevel(ILOG.J2CsMapping.Util.Logging.Level.SEVERE);
	
			fixture_ = new HierarchicalValidatorFixture(
					new ValidationPolicySimpleHierarchy());
		}
	
		/// <summary>
		/// Call fixture_.validator_.validate and if it calls the failureCallback then
		/// fail the test with the given message.
		/// </summary>
		///
		/// <param name="data">The Data to validate.</param>
		/// <param name="message_0">The message to show if the test fails.</param>
		internal void validateExpectSuccess(Data data, String message_0) {
			fixture_.validator_.validate(data, new TestValidator.Anonymous_C7 (), new TestValidator.Anonymous_C6 (message_0));
		}
	
		/// <summary>
		/// Call fixture_.validator_.validate and if it calls the successCallback then
		/// fail the test with the given message.
		/// </summary>
		///
		/// <param name="data">The Data to validate.</param>
		/// <param name="message_0">The message to show if the test fails.</param>
		internal void validateExpectFailure(Data data, String message_0) {
			fixture_.validator_.validate(data, new TestValidator.Anonymous_C5 (message_0), new TestValidator.Anonymous_C4 ());
		}
	
		internal void makeCertificate(PibKey key, PibKey signer) {
			// Copy the default certificate.
			CertificateV2 request = new CertificateV2(key.getDefaultCertificate());
			request.setName(new Name(key.getName()).append("looper").appendVersion(
					1));
	
			// Set SigningInfo.
			SigningInfo // Set SigningInfo.
					paras = new SigningInfo(signer);
			// Validity period from 100 days before to 100 days after now.
			double now = net.named_data.jndn.util.Common.getNowMilliseconds();
			paras.setValidityPeriod(new ValidityPeriod(now - 100 * 24 * 3600
					* 1000.0d, now + 100 * 24 * 3600 * 1000.0d));
			fixture_.keyChain_.sign(request, paras);
			fixture_.keyChain_.addCertificate(key, request);
	
			fixture_.cache_.insert(request);
		}
	
		public void testConstructorSetValidator() {
			Validator validator = fixture_.validator_;
	
			ValidationPolicy middlePolicy = new ValidationPolicySimpleHierarchy();
			ValidationPolicy innerPolicy = new ValidationPolicySimpleHierarchy();
	
			validator.getPolicy().setInnerPolicy(middlePolicy);
			validator.getPolicy().setInnerPolicy(innerPolicy);
	
			Assert.AssertTrue(validator.getPolicy().getValidator_() != null);
			Assert.AssertTrue(validator.getPolicy().getInnerPolicy().getValidator_() != null);
			Assert.AssertTrue(validator.getPolicy().getInnerPolicy().getInnerPolicy()
					.getValidator_() != null);
		}
	
		public void testTimeouts() {
			// Disable responses from the simulated Face.
			fixture_.face_.processInterest_ = null;
	
			Data data = new Data(new Name(
					"/Security/V2/ValidatorFixture/Sub1/Sub2/Data"));
			fixture_.keyChain_.sign(data, new SigningInfo(fixture_.subIdentity_));
	
			validateExpectFailure(data, "Should fail to retrieve certificate");
			// There should be multiple expressed interests due to retries.
			Assert.AssertTrue(fixture_.face_.sentInterests_.Count > 1);
		}
	
		public void testNackedInterests() {
			fixture_.face_.processInterest_ = new TestValidator.Anonymous_C3 ();
	
			Data data = new Data(new Name(
					"/Security/V2/ValidatorFixture/Sub1/Sub2/Data"));
			fixture_.keyChain_.sign(data, new SigningInfo(fixture_.subIdentity_));
	
			validateExpectFailure(data, "All interests should get NACKed");
			// There should be multiple expressed interests due to retries.
			Assert.AssertTrue(fixture_.face_.sentInterests_.Count > 1);
		}
	
		public void testMalformedCertificate() {
			// Copy the default certificate.
			Data malformedCertificate_0 = new Data(fixture_.subIdentity_
					.getDefaultKey().getDefaultCertificate());
			malformedCertificate_0.getMetaInfo().setType(net.named_data.jndn.ContentType.BLOB);
			fixture_.keyChain_.sign(malformedCertificate_0, new SigningInfo(
					fixture_.identity_));
			// It has the wrong content type and a missing ValidityPeriod.
			try {
				new CertificateV2(malformedCertificate_0).wireEncode();
				Assert.Fail("Did not throw the expected exception");
			} catch (CertificateV2.Error ex) {
			} catch (Exception ex_1) {
				Assert.Fail("Did not throw the expected exception");
			}
	
			ValidatorFixture.TestFace.ProcessInterest originalProcessInterest_2 = fixture_.face_.processInterest_;
			fixture_.face_.processInterest_ = new TestValidator.Anonymous_C2 (malformedCertificate_0, originalProcessInterest_2);
	
			Data data = new Data(new Name(
					"/Security/V2/ValidatorFixture/Sub1/Sub2/Data"));
			fixture_.keyChain_.sign(data, new SigningInfo(fixture_.subIdentity_));
	
			validateExpectFailure(data, "Signed by a malformed certificate");
			Assert.AssertEquals(1, fixture_.face_.sentInterests_.Count);
		}
	
		public void testExpiredCertificate() {
			// Copy the default certificate.
			Data expiredCertificate_0 = new Data(fixture_.subIdentity_
					.getDefaultKey().getDefaultCertificate());
			SigningInfo info = new SigningInfo(fixture_.identity_);
			// Validity period from 2 hours ago do 1 hour ago.
			double now = net.named_data.jndn.util.Common.getNowMilliseconds();
			info.setValidityPeriod(new ValidityPeriod(now - 2 * 3600 * 1000,
					now - 3600 * 1000.0d));
			fixture_.keyChain_.sign(expiredCertificate_0, info);
			try {
				new CertificateV2(expiredCertificate_0).wireEncode();
			} catch (Exception ex) {
				Assert.Fail("Unexpected exception: " + ex.Message);
			}
	
			ValidatorFixture.TestFace.ProcessInterest originalProcessInterest_1 = fixture_.face_.processInterest_;
			fixture_.face_.processInterest_ = new TestValidator.Anonymous_C1 (originalProcessInterest_1, expiredCertificate_0);
	
			Data data = new Data(new Name(
					"/Security/V2/ValidatorFixture/Sub1/Sub2/Data"));
			fixture_.keyChain_.sign(data, new SigningInfo(fixture_.subIdentity_));
	
			validateExpectFailure(data, "Signed by a malformed certificate");
			Assert.AssertEquals(1, fixture_.face_.sentInterests_.Count);
		}
	
		public void testResetAnchors() {
			fixture_.validator_.resetAnchors();
	
			Data data = new Data(new Name(
					"/Security/V2/ValidatorFixture/Sub1/Sub2/Data"));
			fixture_.keyChain_.sign(data, new SigningInfo(fixture_.subIdentity_));
			validateExpectFailure(data, "Should fail, as no anchors are configured");
		}
	
		public void testTrustedCertificateCaching() {
			Data data = new Data(new Name(
					"/Security/V2/ValidatorFixture/Sub1/Sub2/Data"));
			fixture_.keyChain_.sign(data, new SigningInfo(fixture_.subIdentity_));
	
			validateExpectSuccess(data,
					"Should get accepted, as signed by the policy-compliant certificate");
			Assert.AssertEquals(1, fixture_.face_.sentInterests_.Count);
			ILOG.J2CsMapping.Collections.Collections.Clear(fixture_.face_.sentInterests_);
	
			// Disable responses from the simulated Face.
			fixture_.face_.processInterest_ = null;
	
			validateExpectSuccess(data,
					"Should get accepted, based on the cached trusted certificate");
			Assert.AssertEquals(0, fixture_.face_.sentInterests_.Count);
			ILOG.J2CsMapping.Collections.Collections.Clear(fixture_.face_.sentInterests_);
	
			// Make the trusted cache simulate a time 2 hours later, after expiration.
			fixture_.validator_.setCacheNowOffsetMilliseconds_(2 * 3600 * 1000.0d);
	
			validateExpectFailure(data,
					"Should try and fail to retrieve certificates");
			// There should be multiple expressed interests due to retries.
			Assert.AssertTrue(fixture_.face_.sentInterests_.Count > 1);
			ILOG.J2CsMapping.Collections.Collections.Clear(fixture_.face_.sentInterests_);
		}
	
		public void testResetVerifiedCertificates() {
			Data data = new Data(new Name(
					"/Security/V2/ValidatorFixture/Sub1/Sub2/Data"));
			fixture_.keyChain_.sign(data, new SigningInfo(fixture_.subIdentity_));
			validateExpectSuccess(data,
					"Should get accepted, as signed by the policy-compliant certificate");
	
			// Reset the anchors.
			fixture_.validator_.resetAnchors();
			validateExpectSuccess(data,
					"Should get accepted, as signed by the certificate in the trusted cache");
	
			// Reset the trusted cache.
			fixture_.validator_.resetVerifiedCertificates();
			validateExpectFailure(data,
					"Should fail, as there is no trusted cache or anchors");
		}
	
		public void testUntrustedCertificateCaching() {
			Data data = new Data(new Name(
					"/Security/V2/ValidatorFixture/Sub1/Sub2/Data"));
			fixture_.keyChain_.sign(data, new SigningInfo(
					fixture_.subSelfSignedIdentity_));
	
			validateExpectFailure(data,
					"Should fail, as signed by the policy-violating certificate");
			Assert.AssertEquals(1, fixture_.face_.sentInterests_.Count);
			ILOG.J2CsMapping.Collections.Collections.Clear(fixture_.face_.sentInterests_);
	
			validateExpectFailure(data,
					"Should fail again, but no network operations are expected");
			Assert.AssertEquals(0, fixture_.face_.sentInterests_.Count);
			ILOG.J2CsMapping.Collections.Collections.Clear(fixture_.face_.sentInterests_);
	
			// Make the trusted cache simulate a time 20 minutes later, to expire the
			// untrusted cache (which has a lifetime of 5 minutes).
			fixture_.validator_.setCacheNowOffsetMilliseconds_(20 * 60 * 1000.0d);
	
			// Disable responses from the simulated Face.
			fixture_.face_.processInterest_ = null;
	
			validateExpectFailure(data,
					"Should try and fail to retrieve certificates");
			Assert.AssertTrue(fixture_.face_.sentInterests_.Count > 1);
			ILOG.J2CsMapping.Collections.Collections.Clear(fixture_.face_.sentInterests_);
		}
	
		public void testInfiniteCertificateChain() {
			fixture_.face_.processInterest_ = new TestValidator.Anonymous_C0 (this);
	
			Data data = new Data(new Name(
					"/Security/V2/ValidatorFixture/Sub1/Sub2/Data"));
			fixture_.keyChain_.sign(data, new SigningInfo(fixture_.subIdentity_));
	
			fixture_.validator_.setMaxDepth(40);
			Assert.AssertEquals(40, fixture_.validator_.getMaxDepth());
			validateExpectFailure(data,
					"Should fail since the certificate should be looped");
			Assert.AssertEquals(40, fixture_.face_.sentInterests_.Count);
			ILOG.J2CsMapping.Collections.Collections.Clear(fixture_.face_.sentInterests_);
	
			// Make the trusted cache simulate a time 5 hours later, after expiration.
			fixture_.validator_.setCacheNowOffsetMilliseconds_(5 * 3600 * 1000.0d);
	
			fixture_.validator_.setMaxDepth(30);
			Assert.AssertEquals(30, fixture_.validator_.getMaxDepth());
			validateExpectFailure(data,
					"Should fail since the certificate chain is infinite");
			Assert.AssertEquals(30, fixture_.face_.sentInterests_.Count);
		}
	
		public void testLoopedCertificateChain() {
			PibIdentity identity1 = fixture_.addIdentity(new Name("/loop"));
			PibKey key1 = fixture_.keyChain_.createKey(identity1, new RsaKeyParams(
					new Name.Component("key1")));
			PibKey key2 = fixture_.keyChain_.createKey(identity1, new RsaKeyParams(
					new Name.Component("key2")));
			PibKey key3 = fixture_.keyChain_.createKey(identity1, new RsaKeyParams(
					new Name.Component("key3")));
	
			makeCertificate(key1, key2);
			makeCertificate(key2, key3);
			makeCertificate(key3, key1);
	
			Data data = new Data(new Name("/loop/Data"));
			fixture_.keyChain_.sign(data, new SigningInfo(key1));
			validateExpectFailure(data,
					"Should fail since the certificate chain loops");
			Assert.AssertEquals(3, fixture_.face_.sentInterests_.Count);
		}
	
		// This is to force an import of net.named_data.jndn.util.
		private static Common dummyCommon_ = new Common();
	}
}
