// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017-2018 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.tests.integration_tests {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.spec;
	using javax.crypto;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.encrypt.algo;
	using net.named_data.jndn.security;
	using net.named_data.jndn.security.tpm;
	using net.named_data.jndn.security.v2;
	using net.named_data.jndn.util;
	
	public class TestTpmBackEnds {
		public TestTpmBackEnds() {
			this.backEndList = new TpmBackEnd[2];
		}
	
		internal TpmBackEndMemory backEndMemory;
		internal TpmBackEndFile backEndFile;
	
		internal TpmBackEnd[] backEndList;
	
		public void setUp() {
			backEndMemory = new TpmBackEndMemory();
	
			FileInfo locationPath = new FileInfo(System.IO.Path.Combine(net.named_data.jndn.tests.integration_tests.IntegrationTestsCommon.getPolicyConfigDirectory().FullName,"ndnsec-key-file"));
			if (locationPath.Exists) {
				/* foreach */
				// Delete files from a previous test.
				foreach (FileInfo file  in  locationPath.listFiles())
					file.delete();
			}
			backEndFile = new TpmBackEndFile(locationPath.FullName);
	
			backEndList[0] = backEndMemory;
			backEndList[1] = backEndFile;
		}
	
		public void tearDown() {
		}
	
		public void testKeyManagement() {
			/* foreach */
			foreach (TpmBackEnd tpm  in  backEndList) {
				Name identityName = new Name("/Test/KeyName");
				Name.Component keyId = new Name.Component("1");
				Name keyName = net.named_data.jndn.security.pib.PibKey.constructKeyName(identityName, keyId);
	
				// The key should not exist.
				Assert.AssertEquals(false, tpm.hasKey(keyName));
				Assert.AssertTrue(tpm.getKeyHandle(keyName) == null);
	
				// Create a key, which should exist.
				Assert.AssertTrue(tpm.createKey(identityName, new RsaKeyParams(keyId)) != null);
				Assert.AssertTrue(tpm.hasKey(keyName));
				Assert.AssertTrue(tpm.getKeyHandle(keyName) != null);
	
				// Create a key with the same name, which should throw an error.
				try {
					tpm.createKey(identityName, new RsaKeyParams(keyId));
					Assert.Fail("Did not throw the expected exception");
				} catch (Tpm.Error ex) {
				} catch (Exception ex_0) {
					Assert.Fail("Did not throw the expected exception");
				}
	
				// Delete the key, then it should not exist.
				tpm.deleteKey(keyName);
				Assert.AssertEquals(false, tpm.hasKey(keyName));
				Assert.AssertTrue(tpm.getKeyHandle(keyName) == null);
			}
		}
	
		public void testRsaSigning() {
			/* foreach */
			foreach (TpmBackEnd tpm  in  backEndList) {
				// Create an RSA key.
				Name identityName = new Name("/Test/KeyName");
	
				TpmKeyHandle key = tpm.createKey(identityName, new RsaKeyParams());
				Name keyName = key.getKeyName();
	
				Blob content = new Blob(new int[] { 0x01, 0x02, 0x03, 0x04 });
				Blob signature = key.sign(net.named_data.jndn.security.DigestAlgorithm.SHA256, content.buf());
	
				Blob publicKey = key.derivePublicKey();
	
				bool result = net.named_data.jndn.security.VerificationHelpers.verifySignature(content,
						signature, publicKey);
				Assert.AssertEquals(true, result);
	
				tpm.deleteKey(keyName);
				Assert.AssertEquals(false, tpm.hasKey(keyName));
			}
		}
	
		public void testRsaDecryption() {
			/* foreach */
			foreach (TpmBackEnd tpm  in  backEndList) {
				// Create an rsa key.
				Name identityName = new Name("/Test/KeyName");
	
				TpmKeyHandle key = tpm.createKey(identityName, new RsaKeyParams());
				Name keyName = key.getKeyName();
	
				Blob content = new Blob(new int[] { 0x01, 0x02, 0x03, 0x04 });
	
				Blob publicKey = key.derivePublicKey();
	
				// TODO: Move encrypt to PublicKey?
				Blob cipherText = net.named_data.jndn.encrypt.algo.RsaAlgorithm.encrypt(publicKey, content,
						new EncryptParams(net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaOaep));
	
				Blob plainText = key.decrypt(cipherText.buf());
	
				Assert.AssertTrue(plainText.equals(content));
	
				tpm.deleteKey(keyName);
				Assert.AssertEquals(false, tpm.hasKey(keyName));
			}
		}
	
		/* Debug: derivePublicKey for EC is not implemented.
		  @Test
		  public void
		  testEcdsaSigning() throws TpmBackEnd.Error, Tpm.Error, SecurityException
		  {
		    for (TpmBackEnd tpm : backEndList) {
		      // Create an EC key.
		      Name identityName = new Name("/Test/Ec/KeyName");
	
		      TpmKeyHandle key = tpm.createKey(identityName, new EcKeyParams());
		      Name ecKeyName = key.getKeyName();
	
		      Blob content = new Blob(new int[] { 0x01, 0x02, 0x03, 0x04});
		      Blob signature = key.sign(DigestAlgorithm.SHA256, content.buf());
	
		      Blob publicKey = key.derivePublicKey();
	
		      // TODO: Move verify to PublicKey?
		      boolean result = VerificationHelpers.verifySignature
		        (content, signature, publicKey);
		      assertEquals(true, result);
	
		      tpm.deleteKey(ecKeyName);
		      assertEquals(false, tpm.hasKey(ecKeyName));
		    }
		  }
		*/
	
		public void testImportExport() {
			String privateKeyPkcs1Base64 = "MIIEpAIBAAKCAQEAw0WM1/WhAxyLtEqsiAJgWDZWuzkYpeYVdeeZcqRZzzfRgBQT\n"
					+ "sNozS5t4HnwTZhwwXbH7k3QN0kRTV826Xobws3iigohnM9yTK+KKiayPhIAm/+5H\n"
					+ "GT6SgFJhYhqo1/upWdueojil6RP4/AgavHhopxlAVbk6G9VdVnlQcQ5Zv0OcGi73\n"
					+ "c+EnYD/YgURYGSngUi/Ynsh779p2U69/te9gZwIL5PuE9BiO6I39cL9z7EK1SfZh\n"
					+ "OWvDe/qH7YhD/BHwcWit8FjRww1glwRVTJsA9rH58ynaAix0tcR/nBMRLUX+e3rU\n"
					+ "RHg6UbSjJbdb9qmKM1fTGHKUzL/5pMG6uBU0ywIDAQABAoIBADQkckOIl4IZMUTn\n"
					+ "W8LFv6xOdkJwMKC8G6bsPRFbyY+HvC2TLt7epSvfS+f4AcYWaOPcDu2E49vt2sNr\n"
					+ "cASly8hgwiRRAB3dHH9vcsboiTo8bi2RFvMqvjv9w3tK2yMxVDtmZamzrrnaV3YV\n"
					+ "Q+5nyKo2F/PMDjQ4eUAKDOzjhBuKHsZBTFnA1MFNI+UKj5X4Yp64DFmKlxTX/U2b\n"
					+ "wzVywo5hzx2Uhw51jmoLls4YUvMJXD0wW5ZtYRuPogXvXb/of9ef/20/wU11WFKg\n"
					+ "Xb4gfR8zUXaXS1sXcnVm3+24vIs9dApUwykuoyjOqxWqcHRec2QT2FxVGkFEraze\n"
					+ "CPa4rMECgYEA5Y8CywomIcTgerFGFCeMHJr8nQGqY2V/owFb3k9maczPnC9p4a9R\n"
					+ "c5szLxA9FMYFxurQZMBWSEG2JS1HR2mnjigx8UKjYML/A+rvvjZOMe4M6Sy2ggh4\n"
					+ "SkLZKpWTzjTe07ByM/j5v/SjNZhWAG7sw4/LmPGRQkwJv+KZhGojuOkCgYEA2cOF\n"
					+ "T6cJRv6kvzTz9S0COZOVm+euJh/BXp7oAsAmbNfOpckPMzqHXy8/wpdKl6AAcB57\n"
					+ "OuztlNfV1D7qvbz7JuRlYwQ0cEfBgbZPcz1p18HHDXhwn57ZPb8G33Yh9Omg0HNA\n"
					+ "Imb4LsVuSqxA6NwSj7cpRekgTedrhLFPJ+Ydb5MCgYEAsM3Q7OjILcIg0t6uht9e\n"
					+ "vrlwTsz1mtCV2co2I6crzdj9HeI2vqf1KAElDt6G7PUHhglcr/yjd8uEqmWRPKNX\n"
					+ "ddnnfVZB10jYeP/93pac6z/Zmc3iU4yKeUe7U10ZFf0KkiiYDQd59CpLef/2XScS\n"
					+ "HB0oRofnxRQjfjLc4muNT+ECgYEAlcDk06MOOTly+F8lCc1bA1dgAmgwFd2usDBd\n"
					+ "Y07a3e0HGnGLN3Kfl7C5i0tZq64HvxLnMd2vgLVxQlXGPpdQrC1TH+XLXg+qnlZO\n"
					+ "ivSH7i0/gx75bHvj75eH1XK65V8pDVDEoSPottllAIs21CxLw3N1ObOZWJm2EfmR\n"
					+ "cuHICmsCgYAtFJ1idqMoHxES3mlRpf2JxyQudP3SCm2WpGmqVzhRYInqeatY5sUd\n"
					+ "lPLHm/p77RT7EyxQHTlwn8FJPuM/4ZH1rQd/vB+Y8qAtYJCexDMsbvLW+Js+VOvk\n"
					+ "jweEC0nrcL31j9mF0vz5E6tfRu4hhJ6L4yfWs0gSejskeVB/w8QY4g==\n";
	
			/* foreach */
			foreach (TpmBackEnd tpm  in  backEndList) {
				Name keyName = new Name("/Test/KeyName/KEY/1");
				tpm.deleteKey(keyName);
				Assert.AssertEquals(false, tpm.hasKey(keyName));
	
				TpmPrivateKey privateKey = new TpmPrivateKey();
				Blob privateKeyPkcs1Encoding = new Blob(
						net.named_data.jndn.util.Common.base64Decode(privateKeyPkcs1Base64));
				privateKey.loadPkcs1(privateKeyPkcs1Encoding.buf());
	
				ByteBuffer password = new Blob("password").buf();
				Blob encryptedPkcs8 = privateKey.toEncryptedPkcs8(password);
	
				tpm.importKey(keyName, encryptedPkcs8.buf(), password);
				Assert.AssertEquals(true, tpm.hasKey(keyName));
				try {
					// Can't import the same keyName again.
					tpm.importKey(keyName, encryptedPkcs8.buf(), password);
					Assert.Fail("Did not throw the expected exception");
				} catch (TpmBackEnd.Error ex) {
				} catch (Exception ex_0) {
					Assert.Fail("Did not throw the expected exception");
				}
	
				Blob exportedKey = tpm.exportKey(keyName, password);
				Assert.AssertEquals(true, tpm.hasKey(keyName));
	
				TpmPrivateKey privateKey2 = new TpmPrivateKey();
				privateKey2.loadEncryptedPkcs8(exportedKey.buf(), password);
				Blob privateKey2Pkcs1Encoding = privateKey2.toPkcs1();
				Assert.AssertTrue(privateKeyPkcs1Encoding.equals(privateKey2Pkcs1Encoding));
	
				tpm.deleteKey(keyName);
				Assert.AssertEquals(false, tpm.hasKey(keyName));
				try {
					tpm.exportKey(keyName, password);
					Assert.Fail("Did not throw the expected exception");
				} catch (TpmBackEnd.Error ex_1) {
				} catch (Exception ex_2) {
					Assert.Fail("Did not throw the expected exception");
				}
			}
		}
	
		public void testRandomKeyId() {
			TpmBackEnd tpm = backEndMemory;
	
			Name identityName = new Name("/Test/KeyName");
	
			HashedSet<Name> keyNames = new HashedSet<Name>();
			for (int i = 0; i < 100; i++) {
				TpmKeyHandle key = tpm.createKey(identityName, new RsaKeyParams());
				Name keyName = key.getKeyName();
				Assert.AssertTrue(ILOG.J2CsMapping.Collections.Collections.Add(keyNames,keyName));
			}
		}
	}
}
