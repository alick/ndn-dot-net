// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2014-2019 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.tests.integration_tests {
	
	using ILOG.J2CsMapping.Threading;
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Threading;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.util;
	
	internal class CallbackCounter : OnData, OnTimeout, OnNetworkNack {
		public CallbackCounter() {
			this.onDataCallCount_ = 0;
			this.onTimeoutCallCount_ = 0;
			this.onNetworkNackCallCount_ = 0;
		}
	
		public virtual void onData(Interest interest, Data data) {
			interest_ = interest;
			data_ = data;
			++onDataCallCount_;
		}
	
		public virtual void onTimeout(Interest interest) {
			interest_ = interest;
			++onTimeoutCallCount_;
		}
	
		public virtual void onNetworkNack(Interest interest, NetworkNack networkNack) {
			networkNack_ = networkNack;
			++onNetworkNackCallCount_;
		}
	
		public int onDataCallCount_;
		public int onTimeoutCallCount_;
		public int onNetworkNackCallCount_;
		public Interest interest_;
		public Data data_;
		public NetworkNack networkNack_;
	}
	
	public class TestFaceInterestMethods {
		public static double getNowMilliseconds() {
			return net.named_data.jndn.util.Common.getNowMilliseconds();
		}
	
		// Returns a CallbackCounter object so we can test data callback, nack callback
		// and timeout behavior.
		private static CallbackCounter runExpressNameTest(Face face,
				String interestName, double timeout, bool useOnNack) {
			Name name = new Name(interestName);
			CallbackCounter counter = new CallbackCounter();
			try {
				if (useOnNack)
					// Debug: Use one of the simpler forms
					face.expressInterest(new Interest(name), counter, counter,
							counter, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
				else
					face.expressInterest(name, counter, counter);
			} catch (IOException ex) {
				ILOG.J2CsMapping.Util.Logging.Logger.getLogger(typeof(TestFaceInterestMethods).FullName).log(
						ILOG.J2CsMapping.Util.Logging.Level.SEVERE, null, ex);
				return null;
			}
	
			double startTime = getNowMilliseconds();
			while (getNowMilliseconds() - startTime < timeout
					&& counter.onDataCallCount_ == 0
					&& counter.onTimeoutCallCount_ == 0
					&& counter.onNetworkNackCallCount_ == 0) {
				try {
					try {
						face.processEvents();
					} catch (IOException ex_0) {
						ILOG.J2CsMapping.Util.Logging.Logger.getLogger(typeof(TestFaceInterestMethods).FullName)
								.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, null, ex_0);
						break;
					} catch (EncodingException ex_1) {
						ILOG.J2CsMapping.Util.Logging.Logger.getLogger(typeof(TestFaceInterestMethods).FullName)
								.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, null, ex_1);
						break;
					}
	
					// We need to sleep for a few milliseconds so we don't use 100% of the CPU.
					ILOG.J2CsMapping.Threading.ThreadWrapper.sleep(10);
				} catch (ThreadInterruptedException ex_2) {
					ILOG.J2CsMapping.Util.Logging.Logger.getLogger(typeof(TestFaceInterestMethods).FullName).log(
							ILOG.J2CsMapping.Util.Logging.Level.SEVERE, null, ex_2);
					break;
				}
			}
	
			return counter;
		}
	
		private static CallbackCounter runExpressNameTest(Face face,
				String interestName) {
			return runExpressNameTest(face, interestName, 10000, false);
		}
	
		internal Face face;
	
		public void setUp() {
			face = new Face("localhost");
		}
	
		/*
		TODO: Replace this with a test that connects to a Face on localhost
		def test_specific_interest(self):
		  uri = "/ndn/edu/ucla/remap/ndn-js-test/howdy.txt/%FD%052%A1%DF%5E%A4"
		  (dataCallback, timeoutCallback) = self.run_express_name_test(uri)
		  self.assertTrue(timeoutCallback.call_count == 0, 'Unexpected timeout on expressed interest')
	
		  // check that the callback was correct
		  self.assertEqual(dataCallback.call_count, 1, 'Expected 1 onData callback, got '+str(dataCallback.call_count))
	
		  onDataArgs = dataCallback.call_args[0] # the args are returned as ([ordered arguments], [keyword arguments])
	
		  // just check that the interest was returned correctly?
		  callbackInterest = onDataArgs[0]
		  self.assertTrue(callbackInterest.getName().equals(Name(uri)), 'Interest returned on callback had different name')
		*/
	
		public void testTimeout() {
			String uri = "/test123/timeout";
			CallbackCounter counter = runExpressNameTest(face, uri);
	
			// we're expecting a timeout callback, and only 1
			Assert.AssertEquals("Data callback called for invalid interest", 0,
					counter.onDataCallCount_);
	
			Assert.AssertTrue("Expected 1 timeout call, got "
					+ counter.onTimeoutCallCount_, counter.onTimeoutCallCount_ == 1);
	
			// just check that the interest was returned correctly.
			Interest callbackInterest = counter.interest_;
			Assert.AssertTrue("Interest returned on callback had different name",
					callbackInterest.getName().equals(new Name(uri)));
		}
	
		public void testRemovePending() {
			Name name = new Name("/ndn/edu/ucla/remap/");
			CallbackCounter counter = new CallbackCounter();
			long interestID;
			try {
				interestID = face.expressInterest(name, counter, counter);
			} catch (IOException ex) {
				Assert.Fail("Error in expressInterest: " + ex);
				return;
			}
	
			face.removePendingInterest(interestID);
	
			double timeout = 10000;
			double startTime = getNowMilliseconds();
			while (getNowMilliseconds() - startTime < timeout
					&& counter.onDataCallCount_ == 0
					&& counter.onTimeoutCallCount_ == 0) {
				try {
					face.processEvents();
				} catch (IOException ex_0) {
					Assert.Fail("Error in processEvents: " + ex_0);
					return;
				} catch (EncodingException ex_1) {
					Assert.Fail("Error in processEvents: " + ex_1);
					return;
				}
	
				try {
					// We need to sleep for a few milliseconds so we don't use 100% of the CPU.
					ILOG.J2CsMapping.Threading.ThreadWrapper.sleep(10);
				} catch (ThreadInterruptedException ex_2) {
					Assert.Fail("Error in sleep: " + ex_2);
					return;
				}
			}
	
			Assert.AssertEquals(
					"Should not have called data callback after interest was removed",
					0, counter.onDataCallCount_);
			Assert.AssertTrue(
					"Should not have called timeout callback after interest was removed",
					counter.onTimeoutCallCount_ == 0);
		}
	
		public void testMaxNdnPacketSize() {
			// Construct an interest whose encoding is one byte larger than getMaxNdnPacketSize.
			int targetSize = net.named_data.jndn.Face.getMaxNdnPacketSize() + 1;
			// Start with an interest which is almost the right size.
			Interest interest = new Interest();
			interest.getName().append(new byte[targetSize]);
			int initialSize = interest.wireEncode().size();
			// Now replace the component with the desired size which trims off the extra encoding.
			interest.setName(new Name().append(new byte[targetSize
					- (initialSize - targetSize)]));
			int interestSize = interest.wireEncode().size();
			Assert.AssertEquals("Wrong interest size for MaxNdnPacketSize", targetSize,
					interestSize);
	
			CallbackCounter counter = new CallbackCounter();
			bool gotError = true;
			try {
				face.expressInterest(interest, counter, counter);
				gotError = false;
			} catch (Exception ex) {
			}
			if (!gotError)
				Assert.Fail("expressInterest didn't throw an exception when the interest size exceeds getMaxNdnPacketSize()");
		}
	
		public void testNetworkNack() {
			String uri = "/noroute" + DateTime.Now.Millisecond;
			// Use a short timeout since we expect an immediate Nack.
			CallbackCounter counter = runExpressNameTest(face, uri, 1000, true);
	
			// We're expecting a network Nack callback, and only 1.
			Assert.AssertEquals("Data callback called for unroutable interest", 0,
					counter.onDataCallCount_);
			Assert.AssertEquals("Timeout callback called for unroutable interest", 0,
					counter.onTimeoutCallCount_);
			Assert.AssertEquals("Expected 1 network Nack call", 1,
					counter.onNetworkNackCallCount_);
	
			Assert.AssertEquals("Network Nack has unexpected reason",
					net.named_data.jndn.NetworkNack.Reason.NO_ROUTE, counter.networkNack_.getReason());
		}
	
		// This is to force an import of net.named_data.jndn.util.
		private static Common dummyCommon_ = new Common();
	}
}
