// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 12/23/15 3:55 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2015 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.util {
	
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	
	/// <summary>
	/// An NdnRegexMatcher has static methods to convert an NDN regex
	/// (http://redmine.named-data.net/projects/ndn-cxx/wiki/Regex) to a Regex that
	/// can match against URIs.
	/// </summary>
	///
	public class NdnRegexMatcher {
		/// <summary>
		/// Determine if the provided NDN regex matches the given Name.
		/// </summary>
		///
		/// <param name="pattern">The NDN regex.</param>
		/// <param name="name">The Name to match against the regex.</param>
		/// <returns>The Matcher object from Pattern.matcher after the first find, or
		/// null if the pattern does not match.</returns>
		public static Matcher match(String pattern, Name name) {
			String nameUri = name.toUri();
	
			pattern = sanitizeSets(pattern);
	
			pattern = pattern.Replace("<>", "(?:<.+?>)");
			pattern = pattern.Replace(">", "");
			pattern = pattern.Replace("<(?!!)", "/");
	
			Matcher match = ILOG.J2CsMapping.Text.Pattern.Compile(pattern).Matcher(nameUri);
			if (match.Find())
				return match;
			else
				return null;
		}
	
		private static String sanitizeSets(String pattern) {
			String newPattern = pattern;
	
			// Positive sets can be changed to (comp1|comp2).
			// Negative sets must be changed to negative lookahead assertions.
	
			Pattern regex1 = ILOG.J2CsMapping.Text.Pattern.Compile("\\[(\\^?)(.*?)\\]");
			Matcher match = regex1.Matcher(pattern);
			while (match.Find()) {
				// Insert | between components.
				int start = match.start(2);
				int end = match.end(2);
				if (start - end == 0)
					continue;
				String oldStr = match.Group(2);
				String newStr = oldStr.replace("><", ">|<");
				newPattern = newPattern.Substring(0,(start)-(0)) + newStr
						+ newPattern.Substring(end);
			}
	
			// Replace [] with (),  or (?! ) for negative lookahead.
			// If we use negative lookahead, we also have to consume one component.
			bool isNegative = newPattern.contains("[^");
			if (isNegative) {
				newPattern = newPattern.replace("[^", "(?:(?!");
				newPattern = newPattern.replace("]", ")(?:/.*)*)");
			} else {
				newPattern = newPattern.replace("[", "(");
				newPattern = newPattern.replace("]", ")");
			}
	
			return newPattern;
		}
	}
}
