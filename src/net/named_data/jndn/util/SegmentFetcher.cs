// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 1/22/16 11:38 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2015-2016 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.util {
	
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding;
	
	/// <summary>
	/// SegmentFetcher is a utility class to fetch the latest version of segmented data.
	/// SegmentFetcher assumes that the data is named /<prefix>/<version>/<segment>,
	/// where:
	/// - <prefix> is the specified name prefix,
	/// - <version> is an unknown version that needs to be discovered, and
	/// - <segment> is a segment number. (The number of segments is unknown and is
	/// controlled by the `FinalBlockId` field in at least the last Data packet.
	/// The following logic is implemented in SegmentFetcher:
	/// 1. Express the first Interest to discover the version:
	/// >> Interest: /<prefix>?ChildSelector=1&MustBeFresh=true
	/// 2. Infer the latest version of the Data: <version> = Data.getName().get(-2)
	/// 3. If the segment number in the retrieved packet == 0, go to step 5.
	/// 4. Send an Interest for segment 0:
	/// >> Interest: /<prefix>/<version>/<segment=0>
	/// 5. Keep sending Interests for the next segment while the retrieved Data does
	/// not have a FinalBlockId or the FinalBlockId != Data.getName().get(-1).
	/// >> Interest: /<prefix>/<version>/<segment=(N+1))>
	/// 6. Call the OnComplete callback with a blob that concatenates the content
	/// from all the segmented objects.
	/// If an error occurs during the fetching process, the OnError callback is called
	/// with a proper error code.  The following errors are possible:
	/// - `INTEREST_TIMEOUT`: if any of the Interests times out
	/// - `DATA_HAS_NO_SEGMENT`: if any of the retrieved Data packets don't have a segment
	/// as the last component of the name (not counting the implicit digest)
	/// - `SEGMENT_VERIFICATION_FAILED`: if any retrieved segment fails
	/// the user-provided VerifySegment callback
	/// - `IO_ERROR`: for I/O errors when sending an Interest.
	/// In order to validate individual segments, a VerifySegment callback needs to
	/// be specified. If the callback returns false, the fetching process is aborted
	/// with SEGMENT_VERIFICATION_FAILED. If data validation is not required, the
	/// provided DontVerifySegment object can be used.
	/// Example:
	/// Interest interest = new Interest(new Name("/data/prefix"));
	/// interest.setInterestLifetimeMilliseconds(1000);
	/// SegmentFetcher.fetch
	/// (face, interest, SegmentFetcher.DontVerifySegment,
	/// new SegmentFetcher.OnComplete() {
	/// public void onComplete(Blob content) {
	/// ...
	/// }},
	/// new SegmentFetcher.OnError() {
	/// public void onError(SegmentFetcher.ErrorCode errorCode, String message) {
	/// ...
	/// }});
	/// </summary>
	///
	public class SegmentFetcher : OnData, OnTimeout {
		public sealed class Anonymous_C0 : SegmentFetcher.VerifySegment  {
			public bool verifySegment(Data data) {
				return true;
			}
		}
		public enum ErrorCode {
			INTEREST_TIMEOUT, DATA_HAS_NO_SEGMENT, SEGMENT_VERIFICATION_FAILED, IO_ERROR
		}
	
		public interface OnComplete {
			void onComplete(Blob content);
		}
	
		public interface VerifySegment {
			bool verifySegment(Data data);
		}
	
		public interface OnError {
			void onError(SegmentFetcher.ErrorCode  errorCode, String message);
		}
	
		/// <summary>
		/// DontVerifySegment may be used in fetch to skip validation of Data packets.
		/// </summary>
		///
		public static readonly SegmentFetcher.VerifySegment  DontVerifySegment = new SegmentFetcher.Anonymous_C0 ();
	
		/// <summary>
		/// Initiate segment fetching. For more details, see the documentation for
		/// the class.
		/// </summary>
		///
		/// <param name="face">This calls face.expressInterest to fetch more segments.</param>
		/// <param name="baseInterest">This interest may include a custom InterestLifetime and selectors that will propagate to all subsequent Interests. The only exception is that the initial Interest will be forced to include selectors "ChildSelector=1" and "MustBeFresh=true" which will be turned off in subsequent Interests.</param>
		/// <param name="verifySegment">and call onError.onError with ErrorCode.SEGMENT_VERIFICATION_FAILED. If data validation is not required, use DontVerifySegment.</param>
		/// <param name="onComplete">content of all the segments.</param>
		/// <param name="onError"></param>
		public static void fetch(Face face, Interest baseInterest,
				SegmentFetcher.VerifySegment  verifySegment, SegmentFetcher.OnComplete  onComplete, SegmentFetcher.OnError  onError) {
			new SegmentFetcher(face, verifySegment, onComplete, onError)
					.fetchFirstSegment(baseInterest);
		}
	
		/// <summary>
		/// Create a new SegmentFetcher to use the Face.
		/// </summary>
		///
		/// <param name="face">This calls face.expressInterest to fetch more segments.</param>
		/// <param name="verifySegment">and call onError.onError with ErrorCode.SEGMENT_VERIFICATION_FAILED.</param>
		/// <param name="onComplete">content of all the segments.</param>
		/// <param name="onError"></param>
		private SegmentFetcher(Face face, SegmentFetcher.VerifySegment  verifySegment,
				SegmentFetcher.OnComplete  onComplete, SegmentFetcher.OnError  onError) {
			this.contentParts_ = new ArrayList();
			face_ = face;
			verifySegment_ = verifySegment;
			onComplete_ = onComplete;
			onError_ = onError;
		}
	
		private void fetchFirstSegment(Interest baseInterest) {
			Interest interest = new Interest(baseInterest);
			interest.setChildSelector(1);
			interest.setMustBeFresh(true);
	
			try {
				face_.expressInterest(interest, this, this);
			} catch (IOException ex) {
				onError_.onError(net.named_data.jndn.util.SegmentFetcher.ErrorCode.IO_ERROR,
						"I/O error fetching the first segment " + ex);
			}
		}
	
		private void fetchNextSegment(Interest originalInterest, Name dataName,
				long segment) {
			// Start with the original Interest to preserve any special selectors.
			Interest interest = new Interest(originalInterest);
			// Changing a field clears the nonce so that the library will generate a new one.
			interest.setMustBeFresh(false);
			interest.setName(dataName.getPrefix(-1).appendSegment(segment));
			try {
				face_.expressInterest(interest, this, this);
			} catch (IOException ex) {
				onError_.onError(net.named_data.jndn.util.SegmentFetcher.ErrorCode.IO_ERROR,
						"I/O error fetching the next segment " + ex);
			}
		}
	
		public virtual void onData(Interest originalInterest, Data data) {
			if (!verifySegment_.verifySegment(data)) {
				onError_.onError(net.named_data.jndn.util.SegmentFetcher.ErrorCode.SEGMENT_VERIFICATION_FAILED,
						"Segment verification failed");
				return;
			}
	
			if (!endsWithSegmentNumber(data.getName()))
				// We don't expect a name without a segment number.  Treat it as a bad packet.
				onError_.onError(net.named_data.jndn.util.SegmentFetcher.ErrorCode.DATA_HAS_NO_SEGMENT,
						"Got an unexpected packet without a segment number: "
								+ data.getName().toUri());
			else {
				long currentSegment;
				try {
					currentSegment = data.getName().get(-1).toSegment();
				} catch (EncodingException ex) {
					onError_.onError(net.named_data.jndn.util.SegmentFetcher.ErrorCode.DATA_HAS_NO_SEGMENT,
							"Error decoding the name segment number "
									+ data.getName().get(-1).toEscapedString()
									+ ": " + ex);
					return;
				}
	
				long expectedSegmentNumber = contentParts_.Count;
				if (currentSegment != expectedSegmentNumber) {
					// Try again to get the expected segment.  This also includes the case
					//   where the first segment is not segment 0.
					fetchNextSegment(originalInterest, data.getName(),
							expectedSegmentNumber);
				} else {
					// Save the content and check if we are finished.
					ILOG.J2CsMapping.Collections.Collections.Add(contentParts_,data.getContent());
	
					if (data.getMetaInfo().getFinalBlockId().getValue().size() > 0) {
						long finalSegmentNumber;
						try {
							finalSegmentNumber = data.getMetaInfo()
									.getFinalBlockId().toSegment();
						} catch (EncodingException ex_0) {
							onError_.onError(net.named_data.jndn.util.SegmentFetcher.ErrorCode.DATA_HAS_NO_SEGMENT,
									"Error decoding the FinalBlockId segment number "
											+ data.getMetaInfo().getFinalBlockId()
													.toEscapedString() + ": " + ex_0);
							return;
						}
	
						if (currentSegment == finalSegmentNumber) {
							// We are finished.
	
							// Get the total size and concatenate to get content.
							int totalSize = 0;
							for (int i = 0; i < contentParts_.Count; ++i)
								totalSize += ((Blob) contentParts_[i]).size();
							ByteBuffer content = ILOG.J2CsMapping.NIO.ByteBuffer.allocate(totalSize);
							for (int i_1 = 0; i_1 < contentParts_.Count; ++i_1)
								content.put(((Blob) contentParts_[i_1]).buf());
							content.flip();
	
							onComplete_.onComplete(new Blob(content, false));
							return;
						}
					}
	
					// Fetch the next segment.
					fetchNextSegment(originalInterest, data.getName(),
							expectedSegmentNumber + 1);
				}
			}
		}
	
		public virtual void onTimeout(Interest interest) {
			onError_.onError(net.named_data.jndn.util.SegmentFetcher.ErrorCode.INTEREST_TIMEOUT, "Time out for interest "
					+ interest.getName().toUri());
		}
	
		/// <summary>
		/// Check if the last component in the name is a segment number.
		/// </summary>
		///
		/// <param name="name">The name to check.</param>
		/// <returns>True if the name ends with a segment number, otherwise false.</returns>
		private static bool endsWithSegmentNumber(Name name) {
			return name.size() >= 1 && name.get(-1).getValue().size() >= 1
					&& name.get(-1).getValue().buf().get(0) == 0;
		}
	
		// Use a non-template ArrayList so it works with older Java compilers.
		private readonly ArrayList contentParts_; // of Blob
		private readonly Face face_;
		private readonly SegmentFetcher.VerifySegment  verifySegment_;
		private readonly SegmentFetcher.OnComplete  onComplete_;
		private readonly SegmentFetcher.OnError  onError_;
	}
}
