// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2015-2016 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.util {
	
	using ILOG.J2CsMapping.NIO;
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.security;
	
	/// <summary>
	/// SegmentFetcher is a utility class to fetch the latest version of segmented data.
	/// SegmentFetcher assumes that the data is named /{prefix}/{version}/{segment},
	/// where:
	/// - {prefix} is the specified name prefix,
	/// - {version} is an unknown version that needs to be discovered, and
	/// - {segment} is a segment number. (The number of segments is unknown and is
	/// controlled by the `FinalBlockId` field in at least the last Data packet.
	/// The following logic is implemented in SegmentFetcher:
	/// 1. Express the first Interest to discover the version:
	/// Interest: /{prefix}?ChildSelector=1&amp;MustBeFresh=true
	/// 2. Infer the latest version of the Data: {version} = Data.getName().get(-2)
	/// 3. If the segment number in the retrieved packet == 0, go to step 5.
	/// 4. Send an Interest for segment 0:
	/// Interest: /{prefix}/{version}/{segment=0}
	/// 5. Keep sending Interests for the next segment while the retrieved Data does
	/// not have a FinalBlockId or the FinalBlockId != Data.getName().get(-1).
	/// Interest: /{prefix}/{version}/{segment=(N+1))}
	/// 6. Call the OnComplete callback with a blob that concatenates the content
	/// from all the segmented objects.
	/// If an error occurs during the fetching process, the OnError callback is called
	/// with a proper error code.  The following errors are possible:
	/// - `INTEREST_TIMEOUT`: if any of the Interests times out
	/// - `DATA_HAS_NO_SEGMENT`: if any of the retrieved Data packets don't have a segment
	/// as the last component of the name (not counting the implicit digest)
	/// - `SEGMENT_VERIFICATION_FAILED`: if any retrieved segment fails
	/// the user-provided VerifySegment callback or KeyChain verifyData.
	/// - `IO_ERROR`: for I/O errors when sending an Interest.
	/// In order to validate individual segments, a KeyChain needs to be supplied.
	/// If verifyData fails, the fetching process is aborted with
	/// SEGMENT_VERIFICATION_FAILED. If data validation is not required, pass
	/// (KeyChain)null.
	/// Example:
	/// Interest interest = new Interest(new Name("/data/prefix"));
	/// interest.setInterestLifetimeMilliseconds(1000);
	/// SegmentFetcher.fetch
	/// (face, interest, 0, new SegmentFetcher.OnComplete() {
	/// public void onComplete(Blob content) {
	/// ...
	/// }},
	/// new SegmentFetcher.OnError() {
	/// public void onError(SegmentFetcher.ErrorCode errorCode, String message) {
	/// ...
	/// }});
	/// </summary>
	///
	public class SegmentFetcher : OnData, OnDataValidationFailed,
			OnTimeout {
		public sealed class Anonymous_C1 : SegmentFetcher.VerifySegment  {
			public bool verifySegment(Data data) {
				return true;
			}
		}
	
		public sealed class Anonymous_C0 : OnVerified {
			private readonly SegmentFetcher thisSegmentFetcher;
			private readonly Interest originalInterest;
	
			public Anonymous_C0(SegmentFetcher thisSegmentFetcher_0,
					Interest originalInterest_1) {
				this.thisSegmentFetcher = thisSegmentFetcher_0;
				this.originalInterest = originalInterest_1;
			}
	
			public void onVerified(Data localData) {
				thisSegmentFetcher.onVerified(localData,
						originalInterest);
			}
		}
		public enum ErrorCode {
			INTEREST_TIMEOUT, DATA_HAS_NO_SEGMENT, SEGMENT_VERIFICATION_FAILED, IO_ERROR
		}
	
		public interface OnComplete {
			void onComplete(Blob content);
		}
	
		public interface VerifySegment {
			bool verifySegment(Data data);
		}
	
		public interface OnError {
			void onError(SegmentFetcher.ErrorCode  errorCode, String message);
		}
	
		/// <summary>
		/// DontVerifySegment may be used in fetch to skip validation of Data packets.
		/// </summary>
		///
		public static readonly SegmentFetcher.VerifySegment  DontVerifySegment = new SegmentFetcher.Anonymous_C1 ();
	
		/// <summary>
		/// Initiate segment fetching. For more details, see the documentation for
		/// the class.
		/// </summary>
		///
		/// <param name="face">This calls face.expressInterest to fetch more segments.</param>
		/// <param name="baseInterest">This interest may include a custom InterestLifetime and selectors that will propagate to all subsequent Interests. The only exception is that the initial Interest will be forced to include selectors "ChildSelector=1" and "MustBeFresh=true" which will be turned off in subsequent Interests.</param>
		/// <param name="verifySegment">and call onError.onError with ErrorCode.SEGMENT_VERIFICATION_FAILED. If data validation is not required, use DontVerifySegment. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onComplete">content of all the segments. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onError">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		public static void fetch(Face face, Interest baseInterest,
				SegmentFetcher.VerifySegment  verifySegment, SegmentFetcher.OnComplete  onComplete, SegmentFetcher.OnError  onError) {
			new SegmentFetcher(face, null, verifySegment, onComplete, onError)
					.fetchFirstSegment(baseInterest);
		}
	
		/// <summary>
		/// Initiate segment fetching. For more details, see the documentation for
		/// the class.
		/// </summary>
		///
		/// <param name="face">This calls face.expressInterest to fetch more segments.</param>
		/// <param name="baseInterest">This interest may include a custom InterestLifetime and selectors that will propagate to all subsequent Interests. The only exception is that the initial Interest will be forced to include selectors "ChildSelector=1" and "MustBeFresh=true" which will be turned off in subsequent Interests.</param>
		/// <param name="validatorKeyChain">fetching and call onError with SEGMENT_VERIFICATION_FAILED. This does not make a copy of the KeyChain; the object must remain valid while fetching. If validatorKeyChain is null, this does not validate the data packet.</param>
		/// <param name="onComplete">content of all the segments. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onError">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		public static void fetch(Face face, Interest baseInterest,
				KeyChain validatorKeyChain, SegmentFetcher.OnComplete  onComplete, SegmentFetcher.OnError  onError) {
			new SegmentFetcher(face, validatorKeyChain, DontVerifySegment,
					onComplete, onError).fetchFirstSegment(baseInterest);
		}
	
		/// <summary>
		/// Create a new SegmentFetcher to use the Face. See the static fetch method
		/// for details. If validatorKeyChain is not null, use it and ignore
		/// verifySegment. After creating the SegmentFetcher, call fetchFirstSegment.
		/// </summary>
		///
		/// <param name="face">This calls face.expressInterest to fetch more segments.</param>
		/// <param name="validatorKeyChain"></param>
		/// <param name="verifySegment">and call onError.onError with ErrorCode.SEGMENT_VERIFICATION_FAILED.</param>
		/// <param name="onComplete">content of all the segments.</param>
		/// <param name="onError"></param>
		private SegmentFetcher(Face face, KeyChain validatorKeyChain,
				SegmentFetcher.VerifySegment  verifySegment, SegmentFetcher.OnComplete  onComplete, SegmentFetcher.OnError  onError) {
			this.contentParts_ = new ArrayList();
			face_ = face;
			validatorKeyChain_ = validatorKeyChain;
			verifySegment_ = verifySegment;
			onComplete_ = onComplete;
			onError_ = onError;
		}
	
		private void fetchFirstSegment(Interest baseInterest) {
			Interest interest = new Interest(baseInterest);
			interest.setChildSelector(1);
			interest.setMustBeFresh(true);
	
			try {
				face_.expressInterest(interest, this, this);
			} catch (IOException ex) {
				try {
					onError_.onError(net.named_data.jndn.util.SegmentFetcher.ErrorCode.IO_ERROR,
							"I/O error fetching the first segment " + ex);
				} catch (Exception exception) {
					logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onError", exception);
				}
			}
		}
	
		private void fetchNextSegment(Interest originalInterest_0, Name dataName,
				long segment) {
			// Start with the original Interest to preserve any special selectors.
			Interest interest = new Interest(originalInterest_0);
			// Changing a field clears the nonce so that the library will generate a new one.
			interest.setChildSelector(0);
			interest.setMustBeFresh(false);
			interest.setName(dataName.getPrefix(-1).appendSegment(segment));
			try {
				face_.expressInterest(interest, this, this);
			} catch (IOException ex) {
				try {
					onError_.onError(net.named_data.jndn.util.SegmentFetcher.ErrorCode.IO_ERROR,
							"I/O error fetching the next segment " + ex);
				} catch (Exception exception) {
					logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onError", exception);
				}
			}
		}
	
		public virtual void onData(Interest originalInterest_0, Data data) {
			if (validatorKeyChain_ != null) {
				try {
					SegmentFetcher thisSegmentFetcher_1 = this;
					validatorKeyChain_.verifyData(data, new SegmentFetcher.Anonymous_C0 (thisSegmentFetcher_1, originalInterest_0), this);
				} catch (Exception ex) {
					try {
						onError_.onError(net.named_data.jndn.util.SegmentFetcher.ErrorCode.SEGMENT_VERIFICATION_FAILED,
								"Error in KeyChain.verifyData " + ex.Message);
					} catch (Exception ex2) {
						logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onError", ex2);
					}
				}
			} else {
				bool verified = false;
				try {
					verified = verifySegment_.verifySegment(data);
				} catch (Exception ex_2) {
					logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in verifySegment", ex_2);
				}
				if (!verified) {
					try {
						onError_.onError(net.named_data.jndn.util.SegmentFetcher.ErrorCode.SEGMENT_VERIFICATION_FAILED,
								"Segment verification failed");
					} catch (Exception ex_3) {
						logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onError", ex_3);
					}
					return;
				}
	
				onVerified(data, originalInterest_0);
			}
		}
	
		public void onVerified(Data data, Interest originalInterest_0) {
			if (!endsWithSegmentNumber(data.getName())) {
				// We don't expect a name without a segment number.  Treat it as a bad packet.
				try {
					onError_.onError(net.named_data.jndn.util.SegmentFetcher.ErrorCode.DATA_HAS_NO_SEGMENT,
							"Got an unexpected packet without a segment number: "
									+ data.getName().toUri());
				} catch (Exception ex) {
					logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onError", ex);
				}
			} else {
				long currentSegment;
				try {
					currentSegment = data.getName().get(-1).toSegment();
				} catch (EncodingException ex_1) {
					try {
						onError_.onError(net.named_data.jndn.util.SegmentFetcher.ErrorCode.DATA_HAS_NO_SEGMENT,
								"Error decoding the name segment number "
										+ data.getName().get(-1).toEscapedString()
										+ ": " + ex_1);
					} catch (Exception exception) {
						logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onError", exception);
					}
					return;
				}
	
				long expectedSegmentNumber = contentParts_.Count;
				if (currentSegment != expectedSegmentNumber) {
					// Try again to get the expected segment.  This also includes the case
					//   where the first segment is not segment 0.
					fetchNextSegment(originalInterest_0, data.getName(),
							expectedSegmentNumber);
				} else {
					// Save the content and check if we are finished.
					ILOG.J2CsMapping.Collections.Collections.Add(contentParts_,data.getContent());
	
					if (data.getMetaInfo().getFinalBlockId().getValue().size() > 0) {
						long finalSegmentNumber;
						try {
							finalSegmentNumber = data.getMetaInfo()
									.getFinalBlockId().toSegment();
						} catch (EncodingException ex_2) {
							try {
								onError_.onError(net.named_data.jndn.util.SegmentFetcher.ErrorCode.DATA_HAS_NO_SEGMENT,
										"Error decoding the FinalBlockId segment number "
												+ data.getMetaInfo()
														.getFinalBlockId()
														.toEscapedString() + ": "
												+ ex_2);
							} catch (Exception exception_3) {
								logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onError",
										exception_3);
							}
							return;
						}
	
						if (currentSegment == finalSegmentNumber) {
							// We are finished.
	
							// Get the total size and concatenate to get content.
							int totalSize = 0;
							for (int i = 0; i < contentParts_.Count; ++i)
								totalSize += ((Blob) contentParts_[i]).size();
							ByteBuffer content = ILOG.J2CsMapping.NIO.ByteBuffer.allocate(totalSize);
							for (int i_4 = 0; i_4 < contentParts_.Count; ++i_4)
								content.put(((Blob) contentParts_[i_4]).buf());
							content.flip();
	
							try {
								onComplete_.onComplete(new Blob(content, false));
							} catch (Exception ex_5) {
								logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onComplete", ex_5);
							}
							return;
						}
					}
	
					// Fetch the next segment.
					fetchNextSegment(originalInterest_0, data.getName(),
							expectedSegmentNumber + 1);
				}
			}
		}
	
		public virtual void onDataValidationFailed(Data data, String reason) {
			try {
				onError_.onError(net.named_data.jndn.util.SegmentFetcher.ErrorCode.SEGMENT_VERIFICATION_FAILED,
						"Segment verification failed for " + data.getName().toUri()
								+ " . Reason: " + reason);
			} catch (Exception ex) {
				logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onError", ex);
			}
		}
	
		public virtual void onTimeout(Interest interest) {
			try {
				onError_.onError(net.named_data.jndn.util.SegmentFetcher.ErrorCode.INTEREST_TIMEOUT,
						"Time out for interest " + interest.getName().toUri());
			} catch (Exception ex) {
				logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onError", ex);
			}
		}
	
		/// <summary>
		/// Check if the last component in the name is a segment number.
		/// </summary>
		///
		/// <param name="name">The name to check.</param>
		/// <returns>True if the name ends with a segment number, otherwise false.</returns>
		private static bool endsWithSegmentNumber(Name name) {
			return name.size() >= 1 && name.get(-1).isSegment();
		}
	
		// Use a non-template ArrayList so it works with older Java compilers.
		private readonly ArrayList contentParts_; // of Blob
		private readonly Face face_;
		private readonly KeyChain validatorKeyChain_;
		private readonly SegmentFetcher.VerifySegment  verifySegment_;
		private readonly SegmentFetcher.OnComplete  onComplete_;
		private readonly SegmentFetcher.OnError  onError_;
		private static readonly Logger logger_ = ILOG.J2CsMapping.Util.Logging.Logger.getLogger(typeof(SegmentFetcher).FullName);
	}
}
