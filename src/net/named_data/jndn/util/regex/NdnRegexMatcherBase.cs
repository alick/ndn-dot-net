// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.util.regex {
	
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	
	public abstract class NdnRegexMatcherBase {
		/// <summary>
		/// NdnRegexMatcherBase.Error extends Exception for errors using
		/// NdnRegexMatcherBase methods. Note that even though this is called "Error"
		/// to be consistent with the other libraries, it extends the Java Exception
		/// class, not Error.
		/// </summary>
		///
		[Serializable]
		public class Error : Exception {
			public Error(String message) : base(message) {
			}
		}
	
		public enum NdnRegexExprType {
			TOP, PATTERN_LIST, REPEAT_PATTERN, BACKREF, COMPONENT_SET, COMPONENT, PSEUDO
		}
	
		public NdnRegexMatcherBase(String expr, NdnRegexMatcherBase.NdnRegexExprType  type,
				NdnRegexBackrefManager backrefManager) {
			this.matchers_ = new ArrayList<NdnRegexMatcherBase>();
					this.matchResult_ = new ArrayList<Name.Component>();
			expr_ = expr;
			type_ = type;
			backrefManager_ = backrefManager;
		}
	
		public NdnRegexMatcherBase(String expr, NdnRegexMatcherBase.NdnRegexExprType  type) {
			this.matchers_ = new ArrayList<NdnRegexMatcherBase>();
			this.matchResult_ = new ArrayList<Name.Component>();
			expr_ = expr;
			type_ = type;
			backrefManager_ = new NdnRegexBackrefManager();
		}
	
		public virtual bool match(Name name, int offset, int len) {
			bool result = false;
	
			ILOG.J2CsMapping.Collections.Collections.Clear(matchResult_);
	
			if (recursiveMatch(0, name, offset, len)) {
				for (int i = offset; i < offset + len; i++)
					ILOG.J2CsMapping.Collections.Collections.Add(matchResult_,name.get(i));
				result = true;
			} else
				result = false;
	
			return result;
		}
	
		/// <summary>
		/// Get the list of matched name components.
		/// </summary>
		///
		/// <returns>The matched name components. You must not modify this list.</returns>
		public ArrayList<Name.Component> getMatchResult() {
			return matchResult_;
		}
	
		public String getExpr() {
			return expr_;
		}
	
		/// <summary>
		/// Compile the regular expression to generate more matchers when necessary.
		/// </summary>
		///
		protected abstract internal void compile();
	
		private bool recursiveMatch(int matcherNo, Name name, int offset, int len) {
			int tried = len;
	
			if (matcherNo >= matchers_.Count)
				return (len == 0);
	
			NdnRegexMatcherBase matcher = matchers_[matcherNo];
	
			while (tried >= 0) {
				if (matcher.match(name, offset, tried)
						&& recursiveMatch(matcherNo + 1, name, offset + tried, len
								- tried))
					return true;
				--tried;
			}
	
			return false;
		}
	
		protected internal readonly String expr_;
		protected internal readonly NdnRegexMatcherBase.NdnRegexExprType  type_;
		protected internal readonly NdnRegexBackrefManager backrefManager_;
		protected internal readonly ArrayList<NdnRegexMatcherBase> matchers_;
		protected internal readonly ArrayList<Name.Component> matchResult_;
	}
}
