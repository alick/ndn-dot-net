// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017-2019 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.util.regex {
	
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	
	public class NdnRegexRepeatMatcher : NdnRegexMatcherBase {
		public NdnRegexRepeatMatcher(String expr,
				NdnRegexBackrefManager backrefManager, int indicator) : base(expr, net.named_data.jndn.util.regex.NdnRegexMatcherBase.NdnRegexExprType.REPEAT_PATTERN, backrefManager) {
			this.repeatMin_ = 0;
			this.repeatMax_ = 0;
			indicator_ = indicator;
	
			compile();
		}
	
		public override bool match(Name name, int offset, int len) {
			ILOG.J2CsMapping.Collections.Collections.Clear(matchResult_);
	
			if (0 == repeatMin_)
				if (0 == len)
					return true;
	
			if (recursiveMatch(0, name, offset, len)) {
				for (int i = offset; i < offset + len; ++i)
					ILOG.J2CsMapping.Collections.Collections.Add(matchResult_,name.get(i));
				return true;
			} else
				return false;
		}
	
		/// <summary>
		/// Compile the regular expression to generate more matchers when necessary.
		/// </summary>
		///
		protected internal override void compile() {
			NdnRegexMatcherBase matcher;
	
			if ('(' == expr_[0]) {
				matcher = new NdnRegexBackrefMatcher(
						expr_.Substring(0,(indicator_)-(0)), backrefManager_);
				backrefManager_.pushRef(matcher);
				((NdnRegexBackrefMatcher) matcher).lateCompile();
			} else
				matcher = new NdnRegexComponentSetMatcher(expr_.Substring(0,(indicator_)-(0)), backrefManager_);
	
			ILOG.J2CsMapping.Collections.Collections.Add(matchers_,matcher);
	
			parseRepetition();
		}
	
		private bool parseRepetition() {
			int exprSize = expr_.Length;
			int MAX_REPETITIONS = 32767;
	
			if (exprSize == indicator_) {
				repeatMin_ = 1;
				repeatMax_ = 1;
	
				return true;
			} else {
				if (exprSize == (indicator_ + 1)) {
					if ('?' == expr_[indicator_]) {
						repeatMin_ = 0;
						repeatMax_ = 1;
						return true;
					}
					if ('+' == expr_[indicator_]) {
						repeatMin_ = 1;
						repeatMax_ = MAX_REPETITIONS;
						return true;
					}
					if ('*' == expr_[indicator_]) {
						repeatMin_ = 0;
						repeatMax_ = MAX_REPETITIONS;
						return true;
					}
				} else {
					String repeatStruct = expr_.Substring(indicator_,(exprSize)-(indicator_));
					int rsSize = repeatStruct.Length;
					int min = 0;
					int max = 0;
	
					if (ILOG.J2CsMapping.Text.Pattern.matches("\\{[0-9]+,[0-9]+\\}", repeatStruct)) {
						int separator = repeatStruct.indexOf(',');
						min = Int32.Parse(repeatStruct.Substring(1,(separator)-(1)));
						max = Int32.Parse(repeatStruct.Substring(separator + 1,(rsSize - 1)-(separator + 1)));
					} else if (ILOG.J2CsMapping.Text.Pattern.matches("\\{,[0-9]+\\}", repeatStruct)) {
						int separator_0 = repeatStruct.indexOf(',');
						min = 0;
						max = Int32.Parse(repeatStruct.Substring(separator_0 + 1,(rsSize - 1)-(separator_0 + 1)));
					} else if (ILOG.J2CsMapping.Text.Pattern.matches("\\{[0-9]+,\\}", repeatStruct)) {
						int separator_1 = repeatStruct.indexOf(',');
						min = Int32.Parse(repeatStruct.Substring(1,(separator_1)-(1)));
						max = MAX_REPETITIONS;
					} else if (ILOG.J2CsMapping.Text.Pattern.matches("\\{[0-9]+\\}", repeatStruct)) {
						min = Int32.Parse(repeatStruct.Substring(1,(rsSize - 1)-(1)));
						max = min;
					} else
						throw new NdnRegexMatcherBase.Error(
								"Error: RegexRepeatMatcher.ParseRepetition(): Unrecognized format "
										+ expr_);
	
					if (min > MAX_REPETITIONS || max > MAX_REPETITIONS || min > max)
						throw new NdnRegexMatcherBase.Error(
								"Error: RegexRepeatMatcher.ParseRepetition(): Wrong number "
										+ expr_);
	
					repeatMin_ = min;
					repeatMax_ = max;
	
					return true;
				}
			}
	
			return false;
		}
	
		private bool recursiveMatch(int repeat, Name name, int offset, int len) {
			int tried = len;
			NdnRegexMatcherBase matcher = matchers_[0];
	
			if (0 < len && repeat >= repeatMax_)
				return false;
	
			if (0 == len && repeat < repeatMin_)
				return false;
	
			if (0 == len && repeat >= repeatMin_)
				return true;
	
			while (tried >= 0) {
				if (matcher.match(name, offset, tried)
						&& recursiveMatch(repeat + 1, name, offset + tried, len
								- tried))
					return true;
				--tried;
			}
	
			return false;
		}
	
		private readonly int indicator_;
		private int repeatMin_;
		private int repeatMax_;
	}
}
