// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017-2018 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.util.regex {
	
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	
	public class NdnRegexComponentMatcher : NdnRegexMatcherBase {
		/// <summary>
		/// Create a RegexComponent matcher from expr.
		/// </summary>
		///
		/// <param name="expr">The standard regular expression to match a component.</param>
		/// <param name="backrefManager">The back reference manager.</param>
		/// <param name="isExactMatch">The flag to provide exact match.</param>
		public NdnRegexComponentMatcher(String expr,
				NdnRegexBackrefManager backrefManager, bool isExactMatch) : base(expr, net.named_data.jndn.util.regex.NdnRegexMatcherBase.NdnRegexExprType.COMPONENT, backrefManager) {
			this.pseudoMatchers_ = new ArrayList<NdnRegexPseudoMatcher>();
			isExactMatch_ = isExactMatch;
	
			compile();
		}
	
		public NdnRegexComponentMatcher(String expr,
				NdnRegexBackrefManager backrefManager) : base(expr, net.named_data.jndn.util.regex.NdnRegexMatcherBase.NdnRegexExprType.COMPONENT, backrefManager) {
			this.pseudoMatchers_ = new ArrayList<NdnRegexPseudoMatcher>();
			isExactMatch_ = true;
	
			compile();
		}
	
		public override bool match(Name name, int offset, int len) {
			ILOG.J2CsMapping.Collections.Collections.Clear(matchResult_);
	
			if (expr_.equals("")) {
				ILOG.J2CsMapping.Collections.Collections.Add(matchResult_,name.get(offset));
				return true;
			}
	
			if (isExactMatch_) {
				String targetStr = name.get(offset).toEscapedString();
				Matcher subResult = componentRegex_.Matcher(targetStr);
				if (subResult.Find()) {
					for (int i = 1; i <= subResult.groupCount(); ++i) {
						pseudoMatchers_[i].resetMatchResult();
						pseudoMatchers_[i].setMatchResult(subResult.Group(i));
					}
	
					ILOG.J2CsMapping.Collections.Collections.Add(matchResult_,name.get(offset));
					return true;
				}
			} else
				throw new NdnRegexMatcherBase.Error(
						"Non-exact component search is not supported yet");
	
			return false;
		}
	
		/// <summary>
		/// Compile the regular expression to generate more matchers when necessary.
		/// </summary>
		///
		protected internal override void compile() {
			componentRegex_ = ILOG.J2CsMapping.Text.Pattern.Compile(expr_);
	
			ILOG.J2CsMapping.Collections.Collections.Clear(pseudoMatchers_);
			ILOG.J2CsMapping.Collections.Collections.Add(pseudoMatchers_,new NdnRegexPseudoMatcher());
	
			// Imitate C++ mark_count by just counting the number of open parentheses.
			if (expr_.contains("\\("))
				// We don't expect escaped parentheses, so don't try to handle them.
				throw new NdnRegexMatcherBase.Error(
						"Can't count subexpressions in regex with escaped parentheses: "
								+ expr_);
			int markCount = 0;
			for (int i = 0; i < expr_.Length; ++i) {
				if (expr_[i] == '(')
					++markCount;
			}
	
			for (int i_0 = 1; i_0 <= markCount; ++i_0) {
				NdnRegexPseudoMatcher pMatcher = new NdnRegexPseudoMatcher();
				ILOG.J2CsMapping.Collections.Collections.Add(pseudoMatchers_,pMatcher);
				backrefManager_.pushRef(pMatcher);
			}
		}
	
		private readonly bool isExactMatch_;
		private Pattern componentRegex_;
		private readonly ArrayList<NdnRegexPseudoMatcher> pseudoMatchers_;
	}
}
