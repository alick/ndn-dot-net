// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 1/22/16 11:38 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2015-2016 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.util {
	
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// BoostInfoTree is provided for compatibility with the Boost INFO property list
	/// format used in ndn-cxx.
	/// Each node in the tree may have a name and a value as well as associated
	/// sub-trees. The sub-tree names are not unique, and so sub-trees are stored as
	/// dictionaries where the key is a sub-tree name and the values are the
	/// sub-trees sharing the same name.
	/// Nodes can be accessed with a path syntax, as long as nodes in the path do not
	/// contain the path separator '/' in their names.
	/// </summary>
	///
	public class BoostInfoTree {
		public BoostInfoTree(String value_ren, BoostInfoTree parent) {
			this.subtrees_ = new ArrayList();
			this.value_ = "";
			this.parent_ = null;
			this.lastChild_ = null;
			value_ = value_ren;
			parent_ = parent;
		}
	
		public BoostInfoTree(String value_ren) {
			this.subtrees_ = new ArrayList();
			this.value_ = "";
			this.parent_ = null;
			this.lastChild_ = null;
			value_ = value_ren;
		}
	
		public BoostInfoTree() {
			this.subtrees_ = new ArrayList();
			this.value_ = "";
			this.parent_ = null;
			this.lastChild_ = null;
		}
	
		/// <summary>
		/// Insert a BoostInfoTree as a sub-tree with the given name.
		/// </summary>
		///
		/// <param name="treeName">The name of the new sub-tree.</param>
		/// <param name="newTree">The sub-tree to add.</param>
		public void addSubtree(String treeName, BoostInfoTree newTree) {
			ArrayList subtreeList = find(treeName);
			if (subtreeList != null)
				ILOG.J2CsMapping.Collections.Collections.Add(subtreeList,newTree);
			else {
				BoostInfoTree.TreeEntry  entry = new BoostInfoTree.TreeEntry (treeName);
				ILOG.J2CsMapping.Collections.Collections.Add(subtrees_,entry);
				ILOG.J2CsMapping.Collections.Collections.Add(entry.subtreeList_,newTree);
			}
	
			newTree.parent_ = this;
			lastChild_ = newTree;
		}
	
		/// <summary>
		/// Create a new BoostInfoTree and insert it as a sub-tree with the given name.
		/// </summary>
		///
		/// <param name="treeName">The name of the new sub-tree.</param>
		/// <param name="value">The value associated with the new sub-tree.</param>
		/// <returns>The created sub-tree.</returns>
		public BoostInfoTree createSubtree(String treeName, String value_ren) {
			BoostInfoTree newTree = new BoostInfoTree(value_ren, this);
			addSubtree(treeName, newTree);
			return newTree;
		}
	
		/// <summary>
		/// Create a new BoostInfoTree with where the value is an empty string,
		/// and insert it as a sub-tree with the given name.
		/// </summary>
		///
		/// <param name="treeName">The name of the new sub-tree.</param>
		/// <returns>The created sub-tree.</returns>
		public BoostInfoTree createSubtree(String treeName) {
			return createSubtree(treeName, "");
		}
	
		/// <summary>
		/// Look up using the key and return a list of the subtrees.
		/// </summary>
		///
		/// <param name="key">The key which may be a path separated with '/'.</param>
		/// <returns>A new ArrayList of BoostInfoTree which are the subtrees.</returns>
		public ArrayList get(String key) {
			ArrayList foundVals = new ArrayList();
	
			// Strip beginning '/'.
			key = ILOG.J2CsMapping.Util.StringUtil.ReplaceFirst(key,"^/+","");
			if (key.Length == 0) {
				ILOG.J2CsMapping.Collections.Collections.Add(foundVals,this);
				return foundVals;
			}
			String[] path = ILOG.J2CsMapping.Text.RegExUtil.Split(key, "/");
	
			ArrayList subtrees = find(path[0]);
			if (subtrees == null)
				return foundVals;
			if (path.Length == 1)
				return (ArrayList) subtrees.Clone();
	
			// newPath = path.slice(1).join('/')
			// Implement manually because older Java versions don't have join.
			String newPath = "";
			for (int i = 1; i < path.Length; ++i) {
				if (i > 1)
					newPath += "/";
				newPath += path[i];
			}
	
			for (int i_0 = 0; i_0 < subtrees.Count; ++i_0) {
				BoostInfoTree t = (BoostInfoTree) subtrees[i_0];
				ArrayList partial = t.get(newPath);
				foundVals.AddRange(partial);
			}
	
			return foundVals;
		}
	
		/// <summary>
		/// Look up using the key and return string value of the first subtree.
		/// </summary>
		///
		/// <param name="key">The key which may be a path separated with '/'.</param>
		/// <returns>A pointer to the string value or null if not found.</returns>
		public String getFirstValue(String key) {
			ArrayList list = get(key);
			if (list.Count >= 1)
				return ((BoostInfoTree) list[0]).value_;
			else
				return null;
		}
	
		public String getValue() {
			return value_;
		}
	
		public BoostInfoTree getParent() {
			return parent_;
		}
	
		public BoostInfoTree getLastChild() {
			return lastChild_;
		}
	
		public String prettyPrint(int indentLevel) {
			// Set prefix to indentLevel spaces.
			String prefix = ILOG.J2CsMapping.Util.StringUtil.NewString(new char[indentLevel]).replace(@"\0", " ");
			String s = "";
	
			if (parent_ != null) {
				if (value_.Length > 0)
					s += "\"" + value_ + "\"";
				s += "\n";
			}
	
			if (subtrees_.Count > 0) {
				if (parent_ != null)
					s += prefix + "{\n";
				String nextLevel = ILOG.J2CsMapping.Util.StringUtil.NewString(new char[indentLevel + 2]).replace(
						@"\0", " ");
				for (int i = 0; i < subtrees_.Count; ++i) {
					BoostInfoTree.TreeEntry  entry = (BoostInfoTree.TreeEntry ) subtrees_[i];
					for (int iSubTree = 0; iSubTree < entry.subtreeList_.Count; ++iSubTree)
						s += nextLevel
								+ entry.treeName_
								+ " "
								+ ((BoostInfoTree) entry.subtreeList_[iSubTree])
										.prettyPrint(indentLevel + 2);
				}
	
				if (parent_ != null)
					s += prefix + "}\n";
			}
	
			return s;
		}
	
		public String prettyPrint() {
			return prettyPrint(1);
		}
	
		public sealed override String toString() {
			return prettyPrint();
		}
	
		private class TreeEntry {
			public TreeEntry(String treeName) {
				this.subtreeList_ = new ArrayList();
				treeName_ = treeName;
			}
	
			public String treeName_;
			public ArrayList subtreeList_; // of BoostInfoTree.
		}
	
		/// <summary>
		/// Use treeName to find the vector of BoostInfoTree in subtrees_.
		/// </summary>
		///
		/// <param name="value"></param>
		/// <returns>A list of BoostInfoTree, or null if not found.</returns>
		private ArrayList find(String treeName) {
			for (int i = 0; i < subtrees_.Count; ++i) {
				BoostInfoTree.TreeEntry  entry = (BoostInfoTree.TreeEntry ) subtrees_[i];
				if (entry.treeName_.equals(treeName))
					return entry.subtreeList_;
			}
	
			return null;
		}
	
		// subtrees_ is a list of TreeEntry.
		// We can't use a map for subtrees_ because we want the keys to be in order.
		// Use ArrayList without generics so it works with older Java compilers.
		private ArrayList subtrees_;
		private String value_;
		private BoostInfoTree parent_;
		private BoostInfoTree lastChild_;
	}
}
