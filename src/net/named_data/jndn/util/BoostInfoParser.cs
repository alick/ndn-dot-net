// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2015-2018 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.util {
	
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// A BoostInfoParser reads files in Boost's INFO format and constructs a
	/// BoostInfoTree.
	/// </summary>
	///
	public class BoostInfoParser {
		public BoostInfoParser() {
			this.root_ = new BoostInfoTree();
		}
	
		/// <summary>
		/// Add the contents of the file to the root BoostInfoTree.
		/// </summary>
		///
		/// <param name="fileName">The path to the INFO file.</param>
		/// <returns>The new root BoostInfoTree.</returns>
		public BoostInfoTree read(String fileName) {
			TextReader stream = new FileReader(fileName);
			// Use "try/finally instead of "try-with-resources" or "using"
			// which are not supported before Java 7.
			try {
				read(stream, root_);
			} finally {
				stream.close();
			}
	
			return root_;
		}
	
		/// <summary>
		/// Add the contents of the input string to the root BoostInfoTree.
		/// </summary>
		///
		/// <param name="input"></param>
		/// <param name="inputName">Used for log messages, etc.</param>
		/// <returns>The new root BoostInfoTree.</returns>
		/// <exception cref="IOException"></exception>
		public BoostInfoTree read(String input, String inputName) {
			TextReader stream = new StringReader(input);
			read(stream, root_);
	
			return root_;
		}
	
		/// <summary>
		/// Write the root tree of this BoostInfoParser as file in Boost's INFO format.
		/// </summary>
		///
		/// <param name="fileName">The output path.</param>
		public void write(String fileName) {
			var writer = (new StreamWriter(fileName));
			try {
				writer.write("" + root_);
				writer.flush();
			} finally {
				writer.close();
			}
		}
	
		/// <summary>
		/// Get the root tree of this parser.
		/// </summary>
		///
		/// <returns>The root BoostInfoTree.</returns>
		public BoostInfoTree getRoot() {
			return root_;
		}
	
		/// <summary>
		/// Similar to Python's shlex.split, split s into an array of strings which are
		/// separated by whitespace, treating a string within quotes as a single entity
		/// regardless of whitespace between the quotes. Also allow a backslash to
		/// escape the next character.
		/// </summary>
		///
		/// <param name="s">The input string to split.</param>
		/// <param name="result"></param>
		private static void shlex_split(String s, ArrayList<String> result) {
			if (s.Length == 0)
				return;
			String whiteSpace = " \t\n\r";
			int iStart = 0;
	
			while (true) {
				// Move iStart past whitespace.
				while (whiteSpace.indexOf(s[iStart]) >= 0) {
					++iStart;
					if (iStart >= s.Length)
						// Done.
						return;
				}
	
				// Move iEnd to the end of the token.
				int iEnd = iStart;
				bool inQuotation = false;
				String token = "";
				while (true) {
					if (s[iEnd] == '\\') {
						// Append characters up to the backslash, skip the backslash and
						//   move iEnd past the escaped character.
						token += s.Substring(iStart,(iEnd)-(iStart));
						iStart = iEnd + 1;
						iEnd = iStart;
						if (iEnd >= s.Length) {
							// An unusual case: A backslash at the end of the string.
							break;
						}
					} else {
						if (inQuotation) {
							if (s[iEnd] == '\"') {
								// Append characters up to the end quote and skip.
								token += s.Substring(iStart,(iEnd)-(iStart));
								iStart = iEnd + 1;
								inQuotation = false;
							}
						} else {
							if (s[iEnd] == '\"') {
								// Append characters up to the start quote and skip.
								token += s.Substring(iStart,(iEnd)-(iStart));
								iStart = iEnd + 1;
								inQuotation = true;
							} else {
								if (whiteSpace.indexOf(s[iEnd]) >= 0)
									break;
							}
						}
					}
	
					++iEnd;
					if (iEnd >= s.Length)
						break;
				}
	
				token += s.Substring(iStart,(iEnd)-(iStart));
				ILOG.J2CsMapping.Collections.Collections.Add(result,token);
				if (iEnd >= s.Length)
					// Done.
					return;
	
				iStart = iEnd;
			}
		}
	
		/// <summary>
		/// Internal import method with an explicit context node.
		/// </summary>
		///
		/// <param name="stream">The stream for reading the INFO content.</param>
		/// <param name="ctx">The node currently being populated.</param>
		/// <returns>The ctx.</returns>
		private BoostInfoTree read(TextReader stream, BoostInfoTree ctx) {
			String line = null;
			while ((line = stream.readLine()) != null)
				ctx = parseLine(line.trim(), ctx);
	
			return ctx;
		}
	
		/// <summary>
		/// Internal helper method for parsing INFO files line by line.
		/// </summary>
		///
		private BoostInfoTree parseLine(String line, BoostInfoTree context) {
			// Skip blank lines and comments.
			int commentStart = line.indexOf(';');
			if (commentStart >= 0)
				line = line.Substring(0,(commentStart)-(0)).trim();
			if (line.Length == 0)
				return context;
	
			// Usually we are expecting key and optional value.
			// Use ArrayList without generics so it works with older Java compilers.
			ArrayList<String> strings = new ArrayList<String>();
			shlex_split(line, strings);
			bool isSectionStart = false;
			bool isSectionEnd = false;
			for (int i = 0; i < strings.Count; ++i) {
				isSectionStart = (isSectionStart || "{".equals(strings[i]));
				isSectionEnd = (isSectionEnd || "}".equals(strings[i]));
			}
	
			if (!isSectionStart && !isSectionEnd) {
				String key = strings[0];
				String val = "";
				if (strings.Count > 1)
					val = strings[1];
	
				// If it is an "#include", load the new file instead of inserting keys.
				if ("#include".equals(key)) {
					TextReader stream = new FileReader(val);
					// Use "try/finally instead of "try-with-resources" or "using"
					// which are not supported before Java 7.
					try {
						context = read(stream, context);
					} finally {
						stream.close();
					}
				} else
					context.createSubtree(key, val);
	
				return context;
			}
	
			// OK, who is the joker who put a { on the same line as the key name?!
			int sectionStart = line.indexOf('{');
			if (sectionStart > 0) {
				String firstPart = line.Substring(0,(sectionStart)-(0));
				String secondPart = line.Substring(sectionStart);
	
				BoostInfoTree ctx = parseLine(firstPart, context);
				return parseLine(secondPart, ctx);
			}
	
			// If we encounter a {, we are beginning a new context.
			// TODO: Error if there was already a subcontext here.
			if (line[0] == '{') {
				context = context.getLastChild();
				return context;
			}
	
			// If we encounter a }, we are ending a list context.
			if (line[0] == '}') {
				context = context.getParent();
				return context;
			}
	
			throw new Exception("BoostInfoParser: input line is malformed");
		}
	
		private BoostInfoTree root_;
	}
}
