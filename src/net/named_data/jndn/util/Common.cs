// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 1/22/16 11:38 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2014-2016 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.util {
	
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Security.Cryptography;
	using System.Text;
	
	/// <summary>
	/// The Common class has static utility functions.
	/// </summary>
	///
	public class Common {
		/// <summary>
		/// Get the current time in milliseconds.
		/// </summary>
		///
		/// <returns>The current time in milliseconds since 1/1/1970, including
		/// fractions of a millisecond.</returns>
		public static double getNowMilliseconds() {
			return (double) (DateTime.Now - new DateTime(1970, 1, 1)).TotalMilliseconds;
		}
	
		/// <summary>
		/// Compute the sha-256 digest of data.
		/// </summary>
		///
		/// <param name="data">The input byte buffer. This does not change the position.</param>
		/// <returns>The digest.</returns>
		public static byte[] digestSha256(ByteBuffer data) {
			SecuritySHA256 sha256;
			try {
				sha256 = System.Security.Cryptography.SecuritySHA256.Create();
			} catch (Exception exception) {
				// Don't expect this to happen.
				throw new Exception("MessageDigest: SHA-256 is not supported: "
						+ exception.Message);
			}
			int savePosition = data.position();
			sha256.update(data);
			data.position(savePosition);
			return sha256.Hash;
		}
	
		/// <summary>
		/// Return a hex string of the contents of buffer.
		/// </summary>
		///
		/// <param name="buffer">The buffer.</param>
		/// <returns>A string of hex bytes.</returns>
		public static String toHex(byte[] buffer) {
			StringBuilder output = new StringBuilder(buffer.Length * 2);
			for (int i = 0; i < buffer.Length; ++i) {
				String hex = ILOG.J2CsMapping.Util.IlNumber.ToString((int) buffer[i] & 0xff,16);
				if (hex.Length <= 1)
					// Append the leading zero.
					output.append("0");
				output.append(hex);
			}
	
			return output.toString();
		}
	
		/// <summary>
		/// Encode the input as base64 using the appropriate base64Converter_ from
		/// establishBase64Converter(), for ANDROID or Java 7+.
		/// </summary>
		///
		/// <param name="input">The bytes to encode.</param>
		/// <returns>The base64 string.</returns>
		/// <exception cref="System.NotSupportedException">If can't establish a base64 converter forthis platform.</exception>
		public static String base64Encode(byte[] input) {
			establishBase64Converter();
	
			try {
				if (base64ConverterType_ == net.named_data.jndn.util.Common.Base64ConverterType.ANDROID)
					// Base64.NO_WRAP  is 2.
					return (String) ILOG.J2CsMapping.Reflect.Helper.Invoke(ILOG.J2CsMapping.Reflect.Helper.GetMethod(base64Converter_,"encodeToString",typeof(byte[]),typeof(int)),null,input,2);
				else
					// Default to Base64ConverterType.JAVAX.
					return (String) ILOG.J2CsMapping.Reflect.Helper.Invoke(ILOG.J2CsMapping.Reflect.Helper.GetMethod(base64Converter_,"printBase64Binary",typeof(byte[])),null,input);
			} catch (Exception ex) {
				throw new NotSupportedException(
						"base64Encode: Error invoking method: " + ex);
			}
		}
	
		/// <summary>
		/// Decode the input as base64 using the appropriate base64Converter_ from
		/// establishBase64Converter(), for ANDROID or Java 7+.
		/// </summary>
		///
		/// <param name="encoding">The base64 string.</param>
		/// <returns>The decoded bytes.</returns>
		/// <exception cref="System.NotSupportedException">If can't establish a base64 converter forthis platform.</exception>
		public static byte[] base64Decode(String encoding) {
			establishBase64Converter();
	
			try {
				if (base64ConverterType_ == net.named_data.jndn.util.Common.Base64ConverterType.ANDROID)
					// Base64.DEFAULT is 0.
					return (byte[]) ILOG.J2CsMapping.Reflect.Helper.Invoke(ILOG.J2CsMapping.Reflect.Helper.GetMethod(base64Converter_,"decode",typeof(String),typeof(int)),null,encoding,0);
				else
					// Default to Base64ConverterType.JAVAX.
					return (byte[]) ILOG.J2CsMapping.Reflect.Helper.Invoke(ILOG.J2CsMapping.Reflect.Helper.GetMethod(base64Converter_,"parseBase64Binary",typeof(String)),null,encoding);
			} catch (Exception ex) {
				throw new NotSupportedException(
						"base64Decode: Error invoking method: " + ex);
			}
		}
	
		/// <summary>
		/// The practical limit of the size of a network-layer packet. If a packet is
		/// larger than this, the library or application MAY drop it. This constant is
		/// defined in this low-level class so that internal code can use it, but
		/// applications should use the static API method
		/// Face.getMaxNdnPacketSize() which is equivalent.
		/// </summary>
		///
		public const int MAX_NDN_PACKET_SIZE = 8800;
	
		public enum Base64ConverterType {
			UNINITIALIZED, JAVAX, ANDROID, UNSUPPORTED
		}
	
		/// <summary>
		/// If not already initialized, set base64Converter_ to the correct loaded
		/// class and set base64ConverterType_ to the loaded type.
		/// If base64ConverterType_ is UNINITIALIZED, set base64Converter_ to
		/// the class for javax.xml.bind.DatatypeConverter and set
		/// base64ConverterType_ to JAVAX.  Else try to set base64Converter_ to
		/// the class for android.util.Base64 and set base64ConverterType_ to ANDROID.
		/// If these fail, set base64ConverterType_ to UNSUPPORTED and throw an
		/// UnsupportedOperationException from now on.
		/// </summary>
		///
		private static void establishBase64Converter() {
			if (base64ConverterType_ == net.named_data.jndn.util.Common.Base64ConverterType.UNINITIALIZED) {
				try {
					base64Converter_ = ILOG.J2CsMapping.Reflect.Helper.GetNativeType("javax.xml.bind.DatatypeConverter");
					base64ConverterType_ = net.named_data.jndn.util.Common.Base64ConverterType.JAVAX;
					return;
				} catch (TypeLoadException ex) {
				}
	
				try {
					base64Converter_ = ILOG.J2CsMapping.Reflect.Helper.GetNativeType("android.util.Base64");
					base64ConverterType_ = net.named_data.jndn.util.Common.Base64ConverterType.ANDROID;
					return;
				} catch (TypeLoadException ex_0) {
				}
	
				base64ConverterType_ = net.named_data.jndn.util.Common.Base64ConverterType.UNSUPPORTED;
			}
	
			if (base64ConverterType_ == net.named_data.jndn.util.Common.Base64ConverterType.UNSUPPORTED)
				throw new NotSupportedException(
						"Common.establishBase64Converter: Cannot load a Base64 converter");
		}
	
		private static Common.Base64ConverterType  base64ConverterType_ = net.named_data.jndn.util.Common.Base64ConverterType.UNINITIALIZED;
		private static Type base64Converter_ = null;
	}
}
