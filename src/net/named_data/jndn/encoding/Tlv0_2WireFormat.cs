// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2016 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.encoding {
	
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding.tlv;
	using net.named_data.jndn.encrypt;
	using net.named_data.jndn.encrypt.algo;
	using net.named_data.jndn.lp;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// A Tlv0_2WireFormat implements the WireFormat interface for encoding and
	/// decoding with the NDN-TLV wire format, version 0.2.
	/// </summary>
	///
	public class Tlv0_2WireFormat : WireFormat {
		/// <summary>
		/// Encode name in NDN-TLV and return the encoding.
		/// </summary>
		///
		/// <param name="name">The Name object to encode.</param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeName(Name name) {
			TlvEncoder encoder = new TlvEncoder();
			encodeName(name, new int[1], new int[1], encoder);
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Decode input as a name in NDN-TLV and set the fields of the Name object.
		/// </summary>
		///
		/// <param name="name">The Name object whose fields are updated.</param>
		/// <param name="input">The input buffer to decode.  This reads from position() to limit(), but does not change the position.</param>
		/// <param name="copy">unchanged while the Blob values are used.</param>
		/// <exception cref="EncodingException">For invalid encoding.</exception>
		public override void decodeName(Name name, ByteBuffer input, bool copy) {
			TlvDecoder decoder = new TlvDecoder(input);
			decodeName(name, new int[1], new int[1], decoder, copy);
		}
	
		/// <summary>
		/// Encode interest using NDN-TLV and return the encoding.
		/// </summary>
		///
		/// <param name="interest">The Interest object to encode.</param>
		/// <param name="signedPortionBeginOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest).</param>
		/// <param name="signedPortionEndOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest).</param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeInterest(Interest interest,
				int[] signedPortionBeginOffset, int[] signedPortionEndOffset) {
			TlvEncoder encoder = new TlvEncoder();
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			encoder.writeOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.SelectedDelegation,
					interest.getSelectedDelegationIndex());
			try {
				Blob linkWireEncoding = interest.getLinkWireEncoding(this);
				if (!linkWireEncoding.isNull())
					// Encode the entire link as is.
					encoder.writeBuffer(linkWireEncoding.buf());
			} catch (EncodingException ex) {
				throw new Exception(ex.Message);
			}
	
			encoder.writeOptionalNonNegativeIntegerTlvFromDouble(
					net.named_data.jndn.encoding.tlv.Tlv.InterestLifetime,
					interest.getInterestLifetimeMilliseconds());
	
			// Encode the Nonce as 4 bytes.
			if (interest.getNonce().size() == 0) {
				// This is the most common case. Generate a nonce.
				ByteBuffer nonce = ILOG.J2CsMapping.NIO.ByteBuffer.allocate(4);
				random_.nextBytes(nonce.array());
				encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Nonce, nonce);
			} else if (interest.getNonce().size() < 4) {
				ByteBuffer nonce_0 = ILOG.J2CsMapping.NIO.ByteBuffer.allocate(4);
				// Copy existing nonce bytes.
				nonce_0.put(interest.getNonce().buf());
	
				// Generate random bytes for remaining bytes in the nonce.
				for (int i = 0; i < 4 - interest.getNonce().size(); ++i)
					nonce_0.put((byte) random_.Next());
	
				nonce_0.flip();
				encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Nonce, nonce_0);
			} else if (interest.getNonce().size() == 4)
				// Use the nonce as-is.
				encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Nonce, interest.getNonce().buf());
			else {
				// Truncate.
				ByteBuffer nonce_1 = interest.getNonce().buf();
				// buf() returns a new ByteBuffer, so we can change its limit.
				nonce_1.limit(nonce_1.position() + 4);
				encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Nonce, nonce_1);
			}
	
			encodeSelectors(interest, encoder);
			int[] tempSignedPortionBeginOffset = new int[1];
			int[] tempSignedPortionEndOffset = new int[1];
			encodeName(interest.getName(), tempSignedPortionBeginOffset,
					tempSignedPortionEndOffset, encoder);
			int signedPortionBeginOffsetFromBack = encoder.getLength()
					- tempSignedPortionBeginOffset[0];
			int signedPortionEndOffsetFromBack = encoder.getLength()
					- tempSignedPortionEndOffset[0];
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Interest, encoder.getLength()
					- saveLength);
			signedPortionBeginOffset[0] = encoder.getLength()
					- signedPortionBeginOffsetFromBack;
			signedPortionEndOffset[0] = encoder.getLength()
					- signedPortionEndOffsetFromBack;
	
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Decode input as an interest in  NDN-TLV and set the fields of the interest
		/// object.
		/// </summary>
		///
		/// <param name="interest">The Interest object whose fields are updated.</param>
		/// <param name="input"></param>
		/// <param name="signedPortionBeginOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest).</param>
		/// <param name="signedPortionEndOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest).</param>
		/// <param name="copy">unchanged while the Blob values are used.</param>
		/// <exception cref="EncodingException">For invalid encoding.</exception>
		public override void decodeInterest(Interest interest, ByteBuffer input,
				int[] signedPortionBeginOffset, int[] signedPortionEndOffset,
				bool copy) {
			TlvDecoder decoder = new TlvDecoder(input);
	
			int endOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Interest);
			decodeName(interest.getName(), signedPortionBeginOffset,
					signedPortionEndOffset, decoder, copy);
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.Selectors, endOffset))
				decodeSelectors(interest, decoder, copy);
			// Require a Nonce, but don't force it to be 4 bytes.
			ByteBuffer nonce = decoder.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Nonce);
			interest.setInterestLifetimeMilliseconds(decoder
					.readOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.InterestLifetime,
							endOffset));
	
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.Data, endOffset)) {
				// Get the bytes of the Link TLV.
				int linkBeginOffset = decoder.getOffset();
				int linkEndOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Data);
				decoder.seek(linkEndOffset);
	
				interest.setLinkWireEncoding(
						new Blob(decoder.getSlice(linkBeginOffset, linkEndOffset),
								copy), this);
			} else
				interest.unsetLink();
			interest.setSelectedDelegationIndex((int) decoder
					.readOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.SelectedDelegation,
							endOffset));
			if (interest.getSelectedDelegationIndex() >= 0 && !interest.hasLink())
				throw new EncodingException(
						"Interest has a selected delegation, but no link object");
	
			// Set the nonce last because setting other interest fields clears it.
			interest.setNonce(new Blob(nonce, copy));
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		/// <summary>
		/// Encode data in NDN-TLV and return the encoding.
		/// </summary>
		///
		/// <param name="data">The Data object to encode.</param>
		/// <param name="signedPortionBeginOffset">If you are not encoding in order to sign, you can call encodeData(data) to ignore this returned value.</param>
		/// <param name="signedPortionEndOffset">If you are not encoding in order to sign, you can call encodeData(data) to ignore this returned value.</param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeData(Data data, int[] signedPortionBeginOffset,
				int[] signedPortionEndOffset) {
			TlvEncoder encoder = new TlvEncoder(1500);
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureValue, (data.getSignature())
					.getSignature().buf());
			int signedPortionEndOffsetFromBack = encoder.getLength();
	
			encodeSignatureInfo(data.getSignature(), encoder);
			encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Content, data.getContent().buf());
			encodeMetaInfo(data.getMetaInfo(), encoder);
			encodeName(data.getName(), new int[1], new int[1], encoder);
			int signedPortionBeginOffsetFromBack = encoder.getLength();
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Data, encoder.getLength() - saveLength);
	
			signedPortionBeginOffset[0] = encoder.getLength()
					- signedPortionBeginOffsetFromBack;
			signedPortionEndOffset[0] = encoder.getLength()
					- signedPortionEndOffsetFromBack;
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Decode input as a data packet in NDN-TLV and set the fields in the data
		/// object.
		/// </summary>
		///
		/// <param name="data">The Data object whose fields are updated.</param>
		/// <param name="input"></param>
		/// <param name="signedPortionBeginOffset">If you are not decoding in order to verify, you can call decodeData(data, input) to ignore this returned value.</param>
		/// <param name="signedPortionEndOffset">not decoding in order to verify, you can call decodeData(data, input) to ignore this returned value.</param>
		/// <param name="copy">unchanged while the Blob values are used.</param>
		/// <exception cref="EncodingException">For invalid encoding.</exception>
		public override void decodeData(Data data, ByteBuffer input,
				int[] signedPortionBeginOffset, int[] signedPortionEndOffset,
				bool copy) {
			TlvDecoder decoder = new TlvDecoder(input);
	
			int endOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Data);
			signedPortionBeginOffset[0] = decoder.getOffset();
	
			decodeName(data.getName(), new int[1], new int[1], decoder, copy);
			decodeMetaInfo(data.getMetaInfo(), decoder, copy);
			data.setContent(new Blob(decoder.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Content), copy));
			decodeSignatureInfo(data, decoder, copy);
	
			signedPortionEndOffset[0] = decoder.getOffset();
			data.getSignature().setSignature(
					new Blob(decoder.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureValue), copy));
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		/// <summary>
		/// Encode controlParameters in NDN-TLV and return the encoding.
		/// </summary>
		///
		/// <param name="controlParameters">The ControlParameters object to encode.</param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeControlParameters(ControlParameters controlParameters) {
			TlvEncoder encoder = new TlvEncoder(256);
			encodeControlParameters(controlParameters, encoder);
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Decode input as a control parameters in NDN-TLV and set the fields of the
		/// controlParameters object.
		/// </summary>
		///
		/// <param name="controlParameters"></param>
		/// <param name="input"></param>
		/// <param name="copy">unchanged while the Blob values are used.</param>
		/// <exception cref="EncodingException">For invalid encoding</exception>
		public override void decodeControlParameters(ControlParameters controlParameters,
				ByteBuffer input, bool copy) {
			TlvDecoder decoder = new TlvDecoder(input);
			decodeControlParameters(controlParameters, decoder, copy);
		}
	
		/// <summary>
		/// Encode controlResponse in NDN-TLV and return the encoding.
		/// </summary>
		///
		/// <param name="controlResponse">The ControlResponse object to encode.</param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeControlResponse(ControlResponse controlResponse) {
			TlvEncoder encoder = new TlvEncoder(256);
			int saveLength = encoder.getLength();
	
			// Encode backwards.
	
			// Encode the body.
			if (controlResponse.getBodyAsControlParameters() != null)
				encodeControlParameters(
						controlResponse.getBodyAsControlParameters(), encoder);
	
			encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.NfdCommand_StatusText, new Blob(
					controlResponse.getStatusText()).buf());
			encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.NfdCommand_StatusCode,
					controlResponse.getStatusCode());
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.NfdCommand_ControlResponse,
					encoder.getLength() - saveLength);
	
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Decode input as a control parameters in NDN-TLV and set the fields of the
		/// controlResponse object.
		/// </summary>
		///
		/// <param name="controlResponse"></param>
		/// <param name="input"></param>
		/// <param name="copy">unchanged while the Blob values are used.</param>
		/// <exception cref="EncodingException">For invalid encoding</exception>
		public override void decodeControlResponse(ControlResponse controlResponse,
				ByteBuffer input, bool copy) {
			TlvDecoder decoder = new TlvDecoder(input);
			int endOffset = decoder
					.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.NfdCommand_ControlResponse);
	
			controlResponse.setStatusCode((int) decoder
					.readNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.NfdCommand_StatusCode));
			// Set copy false since we just immediately get a string.
			Blob statusText = new Blob(
					decoder.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.NfdCommand_StatusText), false);
			controlResponse.setStatusText(statusText.toString());
	
			// Decode the body.
			if (decoder
					.peekType(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_ControlParameters, endOffset)) {
				controlResponse.setBodyAsControlParameters(new ControlParameters());
				// Decode into the existing ControlParameters to avoid copying.
				decodeControlParameters(
						controlResponse.getBodyAsControlParameters(), decoder, copy);
			} else
				controlResponse.setBodyAsControlParameters(null);
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		/// <summary>
		/// Encode signature as a SignatureInfo in NDN-TLV and return the encoding.
		/// </summary>
		///
		/// <param name="signature">An object of a subclass of Signature to encode.</param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeSignatureInfo(Signature signature) {
			TlvEncoder encoder = new TlvEncoder(256);
			encodeSignatureInfo(signature, encoder);
	
			return new Blob(encoder.getOutput(), false);
		}
	
		private class SimpleSignatureHolder : SignatureHolder {
			public virtual Data setSignature(Signature signature) {
				signature_ = signature;
				return null;
			}
	
			public virtual Signature getSignature() {
				return signature_;
			}
	
			private Signature signature_;
		}
	
		/// <summary>
		/// Decode signatureInfo as an NDN-TLV signature info and signatureValue as the
		/// related NDN-TLV SignatureValue, and return a new object which is a subclass
		/// of Signature.
		/// </summary>
		///
		/// <param name="signatureInfo"></param>
		/// <param name="signatureValue"></param>
		/// <param name="copy">unchanged while the Blob values are used.</param>
		/// <returns>A new object which is a subclass of Signature.</returns>
		/// <exception cref="EncodingException">For invalid encoding.</exception>
		public override Signature decodeSignatureInfoAndValue(ByteBuffer signatureInfo,
				ByteBuffer signatureValue, bool copy) {
			// Use a SignatureHolder to imitate a Data object for _decodeSignatureInfo.
			Tlv0_2WireFormat.SimpleSignatureHolder  signatureHolder = new Tlv0_2WireFormat.SimpleSignatureHolder ();
			TlvDecoder decoder = new TlvDecoder(signatureInfo);
			decodeSignatureInfo(signatureHolder, decoder, copy);
	
			decoder = new TlvDecoder(signatureValue);
			signatureHolder.getSignature().setSignature(
					new Blob(decoder.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureValue), copy));
	
			return signatureHolder.getSignature();
		}
	
		/// <summary>
		/// Encode the signatureValue in the Signature object as a SignatureValue (the
		/// signature bits) in NDN-TLV and return the encoding.
		/// </summary>
		///
		/// <param name="signature"></param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeSignatureValue(Signature signature) {
			TlvEncoder encoder = new TlvEncoder(256);
			encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureValue, signature.getSignature().buf());
	
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Decode input as an NDN-TLV LpPacket and set the fields of the lpPacket object.
		/// </summary>
		///
		/// <param name="lpPacket">The LpPacket object whose fields are updated.</param>
		/// <param name="input"></param>
		/// <param name="copy">unchanged while the Blob values are used.</param>
		/// <exception cref="EncodingException">For invalid encoding.</exception>
		public override void decodeLpPacket(LpPacket lpPacket, ByteBuffer input, bool copy) {
			lpPacket.clear();
	
			TlvDecoder decoder = new TlvDecoder(input);
			int endOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.LpPacket_LpPacket);
	
			while (decoder.getOffset() < endOffset) {
				// Imitate TlvDecoder.readTypeAndLength.
				int fieldType = decoder.readVarNumber();
				int fieldLength = decoder.readVarNumber();
				int fieldEndOffset = decoder.getOffset() + fieldLength;
				if (fieldEndOffset > input.limit())
					throw new EncodingException(
							"TLV length exceeds the buffer length");
	
				if (fieldType == net.named_data.jndn.encoding.tlv.Tlv.LpPacket_Fragment) {
					// Set the fragment to the bytes of the TLV value.
					lpPacket.setFragmentWireEncoding(new Blob(decoder.getSlice(
							decoder.getOffset(), fieldEndOffset), copy));
					decoder.seek(fieldEndOffset);
	
					// The fragment is supposed to be the last field.
					break;
				} else if (fieldType == net.named_data.jndn.encoding.tlv.Tlv.LpPacket_Nack) {
					NetworkNack networkNack = new NetworkNack();
					int code = (int) decoder.readOptionalNonNegativeIntegerTlv(
							net.named_data.jndn.encoding.tlv.Tlv.LpPacket_NackReason, fieldEndOffset);
					// The enum numeric values are the same as this wire format, so use as is.
					if (code < 0
							|| code == net.named_data.jndn.NetworkNack.Reason.NONE.getNumericType())
						// This includes an omitted NackReason.
						networkNack.setReason(net.named_data.jndn.NetworkNack.Reason.NONE);
					else if (code == net.named_data.jndn.NetworkNack.Reason.CONGESTION.getNumericType())
						networkNack.setReason(net.named_data.jndn.NetworkNack.Reason.CONGESTION);
					else if (code == net.named_data.jndn.NetworkNack.Reason.DUPLICATE.getNumericType())
						networkNack.setReason(net.named_data.jndn.NetworkNack.Reason.DUPLICATE);
					else if (code == net.named_data.jndn.NetworkNack.Reason.NO_ROUTE.getNumericType())
						networkNack.setReason(net.named_data.jndn.NetworkNack.Reason.NO_ROUTE);
					else {
						// Unrecognized reason.
						networkNack.setReason(net.named_data.jndn.NetworkNack.Reason.OTHER_CODE);
						networkNack.setOtherReasonCode(code);
					}
	
					lpPacket.addHeaderField(networkNack);
				} else if (fieldType == net.named_data.jndn.encoding.tlv.Tlv.LpPacket_IncomingFaceId) {
					IncomingFaceId incomingFaceId = new IncomingFaceId();
					incomingFaceId.setFaceId(decoder
							.readNonNegativeInteger(fieldLength));
					lpPacket.addHeaderField(incomingFaceId);
				} else {
					// Unrecognized field type. The conditions for ignoring are here:
					// http://redmine.named-data.net/projects/nfd/wiki/NDNLPv2
					bool canIgnore = (fieldType >= net.named_data.jndn.encoding.tlv.Tlv.LpPacket_IGNORE_MIN
							&& fieldType <= net.named_data.jndn.encoding.tlv.Tlv.LpPacket_IGNORE_MAX && (fieldType & 0x01) == 1);
					if (!canIgnore)
						throw new EncodingException(
								"Did not get the expected TLV type");
	
					// Ignore.
					decoder.seek(fieldEndOffset);
				}
	
				decoder.finishNestedTlvs(fieldEndOffset);
			}
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		/// <summary>
		/// Encode delegationSet as a sequence of NDN-TLV Delegation, and return the
		/// encoding. Note that the sequence of Delegation does not have an outer TLV
		/// type and length because it is intended to use the type and length of a Data
		/// packet's Content.
		/// </summary>
		///
		/// <param name="delegationSet">The DelegationSet object to encode.</param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeDelegationSet(DelegationSet delegationSet) {
			TlvEncoder encoder = new TlvEncoder(256);
	
			// Encode backwards.
			for (int i = delegationSet.size() - 1; i >= 0; --i) {
				int saveLength = encoder.getLength();
	
				encodeName(delegationSet.get(i).getName(), new int[1], new int[1],
						encoder);
				encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.Link_Preference,
						delegationSet.get(i).getPreference());
	
				encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Link_Delegation, encoder.getLength()
						- saveLength);
			}
	
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Decode input as a sequence of NDN-TLV Delegation and set the fields of the
		/// delegationSet object. Note that the sequence of Delegation does not have an
		/// outer TLV type and length because it is intended to use the type and length
		/// of a Data packet's Content. This ignores any elements after the sequence
		/// of Delegation and before input.limit().
		/// </summary>
		///
		/// <param name="delegationSet">The DelegationSet object whose fields are updated.</param>
		/// <param name="input"></param>
		/// <param name="copy">unchanged while the Blob values are used.</param>
		/// <exception cref="EncodingException">For invalid encoding.</exception>
		public override void decodeDelegationSet(DelegationSet delegationSet,
				ByteBuffer input, bool copy) {
			TlvDecoder decoder = new TlvDecoder(input);
			int endOffset = input.limit();
	
			delegationSet.clear();
			while (decoder.getOffset() < endOffset) {
				decoder.readTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Link_Delegation);
				int preference = (int) decoder
						.readNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.Link_Preference);
				Name name = new Name();
				decodeName(name, new int[1], new int[1], decoder, copy);
	
				// Add unsorted to preserve the order so that Interest selected delegation
				// index will work.
				delegationSet.addUnsorted(preference, name);
			}
		}
	
		/// <summary>
		/// Encode the EncryptedContent in NDN-TLV and return the encoding.
		/// </summary>
		///
		/// <param name="encryptedContent">The EncryptedContent object to encode.</param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeEncryptedContent(EncryptedContent encryptedContent) {
			TlvEncoder encoder = new TlvEncoder(256);
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_EncryptedPayload, encryptedContent
					.getPayload().buf());
			encoder.writeOptionalBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_InitialVector,
					encryptedContent.getInitialVector().buf());
			// Assume the algorithmType value is the same as the TLV type.
			encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_EncryptionAlgorithm,
					encryptedContent.getAlgorithmType().getNumericType());
			Tlv0_2WireFormat.encodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.KeyLocator,
					encryptedContent.getKeyLocator(), encoder);
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_EncryptedContent,
					encoder.getLength() - saveLength);
	
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Decode input as a EncryptedContent in NDN-TLV and set the fields of the
		/// encryptedContent object.
		/// </summary>
		///
		/// <param name="encryptedContent"></param>
		/// <param name="input"></param>
		/// <param name="copy">unchanged while the Blob values are used.</param>
		/// <exception cref="EncodingException">For invalid encoding</exception>
		public override void decodeEncryptedContent(EncryptedContent encryptedContent,
				ByteBuffer input, bool copy) {
			TlvDecoder decoder = new TlvDecoder(input);
			int endOffset = decoder
					.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_EncryptedContent);
	
			Tlv0_2WireFormat.decodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.KeyLocator,
					encryptedContent.getKeyLocator(), decoder, copy);
	
			int algorithmType = (int) decoder
					.readNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_EncryptionAlgorithm);
			if (algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesEcb.getNumericType())
				encryptedContent.setAlgorithmType(net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesEcb);
			else if (algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesCbc.getNumericType())
				encryptedContent.setAlgorithmType(net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesCbc);
			else if (algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaPkcs.getNumericType())
				encryptedContent.setAlgorithmType(net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaPkcs);
			else if (algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaOaep.getNumericType())
				encryptedContent.setAlgorithmType(net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaOaep);
			else
				throw new EncodingException(
						"Unrecognized EncryptionAlgorithm code " + algorithmType);
	
			encryptedContent.setInitialVector(new Blob(decoder.readOptionalBlobTlv(
					net.named_data.jndn.encoding.tlv.Tlv.Encrypt_InitialVector, endOffset), copy));
			encryptedContent.setPayload(new Blob(decoder
					.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_EncryptedPayload), copy));
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		/// <summary>
		/// Get a singleton instance of a Tlv0_2WireFormat.  To always use the
		/// preferred version NDN-TLV, you should use TlvWireFormat.get().
		/// </summary>
		///
		/// <returns>The singleton instance.</returns>
		public static Tlv0_2WireFormat get() {
			return instance_;
		}
	
		/// <summary>
		/// Encode the name component to the encoder as NDN-TLV. This handles different
		/// component types such as ImplicitSha256DigestComponent.
		/// </summary>
		///
		/// <param name="component">The name component to encode.</param>
		/// <param name="encoder">The TlvEncoder to receive the encoding.</param>
		private static void encodeNameComponent(Name.Component component,
				TlvEncoder encoder) {
			int type = (component.isImplicitSha256Digest()) ? net.named_data.jndn.encoding.tlv.Tlv.ImplicitSha256DigestComponent
					: net.named_data.jndn.encoding.tlv.Tlv.NameComponent;
			encoder.writeBlobTlv(type, component.getValue().buf());
		}
	
		/// <summary>
		/// Decode the name component as NDN-TLV and return the component. This handles
		/// different component types such as ImplicitSha256DigestComponent.
		/// </summary>
		///
		/// <param name="decoder">The decoder with the input to decode.</param>
		/// <param name="copy">unchanged while the Blob values are used.</param>
		/// <returns>A new Name.Component.</returns>
		/// <exception cref="EncodingException"></exception>
		private static Name.Component decodeNameComponent(TlvDecoder decoder,
				bool copy) {
			int savePosition = decoder.getOffset();
			int type = decoder.readVarNumber();
			// Restore the position.
			decoder.seek(savePosition);
	
			Blob value_ren = new Blob(decoder.readBlobTlv(type), copy);
			if (type == net.named_data.jndn.encoding.tlv.Tlv.ImplicitSha256DigestComponent)
				return net.named_data.jndn.Name.Component.fromImplicitSha256Digest(value_ren);
			else
				return new Name.Component(value_ren);
		}
	
		/// <summary>
		/// Encode the name as NDN-TLV to the encoder.
		/// </summary>
		///
		/// <param name="name">The name to encode.</param>
		/// <param name="signedPortionBeginOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest).</param>
		/// <param name="signedPortionEndOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest).</param>
		/// <param name="encoder">The TlvEncoder to receive the encoding.</param>
		private static void encodeName(Name name, int[] signedPortionBeginOffset,
				int[] signedPortionEndOffset, TlvEncoder encoder) {
			int saveLength = encoder.getLength();
	
			// Encode the components backwards.
			int signedPortionEndOffsetFromBack = 0;
			for (int i = name.size() - 1; i >= 0; --i) {
				encodeNameComponent(name.get(i), encoder);
				if (i == name.size() - 1)
					signedPortionEndOffsetFromBack = encoder.getLength();
			}
	
			int signedPortionBeginOffsetFromBack = encoder.getLength();
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Name, encoder.getLength() - saveLength);
	
			signedPortionBeginOffset[0] = encoder.getLength()
					- signedPortionBeginOffsetFromBack;
			if (name.size() == 0)
				// There is no "final component", so set signedPortionEndOffset
				//   arbitrarily.
				signedPortionEndOffset[0] = signedPortionBeginOffset[0];
			else
				signedPortionEndOffset[0] = encoder.getLength()
						- signedPortionEndOffsetFromBack;
		}
	
		/// <summary>
		/// Decode the name as NDN-TLV and set the fields in name.
		/// </summary>
		///
		/// <param name="name">The name object whose fields are set.</param>
		/// <param name="signedPortionBeginOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest). If you are not decoding in order to verify, you can ignore this returned value.</param>
		/// <param name="signedPortionEndOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest). If you are not decoding in order to verify, you can ignore this returned value.</param>
		/// <param name="decoder">The decoder with the input to decode.</param>
		/// <param name="copy">unchanged while the Blob values are used.</param>
		/// <exception cref="EncodingException"></exception>
		private static void decodeName(Name name, int[] signedPortionBeginOffset,
				int[] signedPortionEndOffset, TlvDecoder decoder, bool copy) {
			name.clear();
	
			int endOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Name);
	
			signedPortionBeginOffset[0] = decoder.getOffset();
			// In case there are no components, set signedPortionEndOffset arbitrarily.
			signedPortionEndOffset[0] = signedPortionBeginOffset[0];
	
			while (decoder.getOffset() < endOffset) {
				signedPortionEndOffset[0] = decoder.getOffset();
				name.append(decodeNameComponent(decoder, copy));
			}
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		/// <summary>
		/// Encode the interest selectors.  If no selectors are written, do not output
		/// a  Selectors TLV.
		/// </summary>
		///
		private static void encodeSelectors(Interest interest, TlvEncoder encoder) {
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			if (interest.getMustBeFresh())
				encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.MustBeFresh, 0);
			encoder.writeOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.ChildSelector,
					interest.getChildSelector());
			if (interest.getExclude().size() > 0)
				encodeExclude(interest.getExclude(), encoder);
	
			if (interest.getKeyLocator().getType() != net.named_data.jndn.KeyLocatorType.NONE)
				encodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.PublisherPublicKeyLocator,
						interest.getKeyLocator(), encoder);
	
			encoder.writeOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.MaxSuffixComponents,
					interest.getMaxSuffixComponents());
			encoder.writeOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.MinSuffixComponents,
					interest.getMinSuffixComponents());
	
			// Only output the type and length if values were written.
			if (encoder.getLength() != saveLength)
				encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Selectors, encoder.getLength()
						- saveLength);
		}
	
		private static void decodeSelectors(Interest interest, TlvDecoder decoder,
				bool copy) {
			int endOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Selectors);
	
			interest.setMinSuffixComponents((int) decoder
					.readOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.MinSuffixComponents,
							endOffset));
			interest.setMaxSuffixComponents((int) decoder
					.readOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.MaxSuffixComponents,
							endOffset));
	
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.PublisherPublicKeyLocator, endOffset))
				decodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.PublisherPublicKeyLocator,
						interest.getKeyLocator(), decoder, copy);
			else
				interest.getKeyLocator().clear();
	
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.Exclude, endOffset))
				decodeExclude(interest.getExclude(), decoder, copy);
			else
				interest.getExclude().clear();
	
			interest.setChildSelector((int) decoder
					.readOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.ChildSelector, endOffset));
			interest.setMustBeFresh(decoder.readBooleanTlv(net.named_data.jndn.encoding.tlv.Tlv.MustBeFresh,
					endOffset));
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		private static void encodeExclude(Exclude exclude, TlvEncoder encoder) {
			int saveLength = encoder.getLength();
	
			// TODO: Do we want to order the components (except for ANY)?
			// Encode the entries backwards.
			for (int i = exclude.size() - 1; i >= 0; --i) {
				Exclude.Entry entry = exclude.get(i);
	
				if (entry.getType() == net.named_data.jndn.Exclude.Type.ANY)
					encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Any, 0);
				else
					encodeNameComponent(entry.getComponent(), encoder);
			}
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Exclude, encoder.getLength()
					- saveLength);
		}
	
		private static void decodeExclude(Exclude exclude, TlvDecoder decoder,
				bool copy) {
			int endOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Exclude);
	
			exclude.clear();
			while (decoder.getOffset() < endOffset) {
				if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.Any, endOffset)) {
					// Read past the Any TLV.
					decoder.readBooleanTlv(net.named_data.jndn.encoding.tlv.Tlv.Any, endOffset);
					exclude.appendAny();
				} else
					exclude.appendComponent(decodeNameComponent(decoder, copy));
			}
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		private static void encodeKeyLocator(int type, KeyLocator keyLocator,
				TlvEncoder encoder) {
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			if (keyLocator.getType() != net.named_data.jndn.KeyLocatorType.NONE) {
				if (keyLocator.getType() == net.named_data.jndn.KeyLocatorType.KEYNAME)
					encodeName(keyLocator.getKeyName(), new int[1], new int[1],
							encoder);
				else if (keyLocator.getType() == net.named_data.jndn.KeyLocatorType.KEY_LOCATOR_DIGEST
						&& keyLocator.getKeyData().size() > 0)
					encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.KeyLocatorDigest, keyLocator
							.getKeyData().buf());
				else
					throw new Exception("Unrecognized KeyLocatorType "
							+ keyLocator.getType());
			}
	
			encoder.writeTypeAndLength(type, encoder.getLength() - saveLength);
		}
	
		private static void decodeKeyLocator(int expectedType,
				KeyLocator keyLocator, TlvDecoder decoder, bool copy) {
			int endOffset = decoder.readNestedTlvsStart(expectedType);
	
			keyLocator.clear();
	
			if (decoder.getOffset() == endOffset)
				// The KeyLocator is omitted, so leave the fields as none.
				return;
	
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.Name, endOffset)) {
				// KeyLocator is a Name.
				keyLocator.setType(net.named_data.jndn.KeyLocatorType.KEYNAME);
				decodeName(keyLocator.getKeyName(), new int[1], new int[1],
						decoder, copy);
			} else if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.KeyLocatorDigest, endOffset)) {
				// KeyLocator is a KeyLocatorDigest.
				keyLocator.setType(net.named_data.jndn.KeyLocatorType.KEY_LOCATOR_DIGEST);
				keyLocator.setKeyData(new Blob(decoder
						.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.KeyLocatorDigest), copy));
			} else
				throw new EncodingException(
						"decodeKeyLocator: Unrecognized key locator type");
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		/// <summary>
		/// An internal method to encode signature as the appropriate form of
		/// SignatureInfo in NDN-TLV.
		/// </summary>
		///
		/// <param name="signature">An object of a subclass of Signature to encode.</param>
		/// <param name="encoder">The TlvEncoder to receive the encoding.</param>
		private void encodeSignatureInfo(Signature signature, TlvEncoder encoder) {
			if (signature  is  GenericSignature) {
				// Handle GenericSignature separately since it has the entire encoding.
				Blob encoding = ((GenericSignature) signature)
						.getSignatureInfoEncoding();
	
				// Do a test decoding to sanity check that it is valid TLV.
				try {
					TlvDecoder decoder = new TlvDecoder(encoding.buf());
					int endOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.SignatureInfo);
					decoder.readNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureType);
					decoder.finishNestedTlvs(endOffset);
				} catch (EncodingException ex) {
					throw new Exception(
							"The GenericSignature encoding is not a valid NDN-TLV SignatureInfo: "
									+ ex.Message);
				}
	
				encoder.writeBuffer(encoding.buf());
				return;
			}
	
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			if (signature  is  Sha256WithRsaSignature) {
				encodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.KeyLocator,
						((Sha256WithRsaSignature) signature).getKeyLocator(),
						encoder);
				encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureType,
						net.named_data.jndn.encoding.tlv.Tlv.SignatureType_SignatureSha256WithRsa);
			} else if (signature  is  Sha256WithEcdsaSignature) {
				encodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.KeyLocator,
						((Sha256WithEcdsaSignature) signature).getKeyLocator(),
						encoder);
				encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureType,
						net.named_data.jndn.encoding.tlv.Tlv.SignatureType_SignatureSha256WithEcdsa);
			} else if (signature  is  HmacWithSha256Signature) {
				encodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.KeyLocator,
						((HmacWithSha256Signature) signature).getKeyLocator(),
						encoder);
				encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureType,
						net.named_data.jndn.encoding.tlv.Tlv.SignatureType_SignatureHmacWithSha256);
			} else if (signature  is  DigestSha256Signature)
				encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureType,
						net.named_data.jndn.encoding.tlv.Tlv.SignatureType_DigestSha256);
			else
				throw new Exception(
						"encodeSignatureInfo: Unrecognized Signature object type");
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.SignatureInfo, encoder.getLength()
					- saveLength);
		}
	
		private static void decodeSignatureInfo(SignatureHolder signatureHolder,
				TlvDecoder decoder, bool copy) {
			int beginOffset = decoder.getOffset();
			int endOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.SignatureInfo);
	
			int signatureType = (int) decoder
					.readNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureType);
			if (signatureType == net.named_data.jndn.encoding.tlv.Tlv.SignatureType_SignatureSha256WithRsa) {
				signatureHolder.setSignature(new Sha256WithRsaSignature());
				// Modify the holder's signature object because if we create an object
				//   and set it, then the holder will have to copy all the fields.
				Sha256WithRsaSignature signatureInfo = (Sha256WithRsaSignature) signatureHolder
						.getSignature();
				decodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.KeyLocator, signatureInfo.getKeyLocator(),
						decoder, copy);
			} else if (signatureType == net.named_data.jndn.encoding.tlv.Tlv.SignatureType_SignatureSha256WithEcdsa) {
				signatureHolder.setSignature(new Sha256WithEcdsaSignature());
				Sha256WithEcdsaSignature signatureInfo_0 = (Sha256WithEcdsaSignature) signatureHolder
						.getSignature();
				decodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.KeyLocator, signatureInfo_0.getKeyLocator(),
						decoder, copy);
			} else if (signatureType == net.named_data.jndn.encoding.tlv.Tlv.SignatureType_SignatureHmacWithSha256) {
				signatureHolder.setSignature(new HmacWithSha256Signature());
				HmacWithSha256Signature signatureInfo_1 = (HmacWithSha256Signature) signatureHolder
						.getSignature();
				decodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.KeyLocator, signatureInfo_1.getKeyLocator(),
						decoder, copy);
			} else if (signatureType == net.named_data.jndn.encoding.tlv.Tlv.SignatureType_DigestSha256)
				signatureHolder.setSignature(new DigestSha256Signature());
			else {
				signatureHolder.setSignature(new GenericSignature());
				GenericSignature signatureInfo_2 = (GenericSignature) signatureHolder
						.getSignature();
	
				// Get the bytes of the SignatureInfo TLV.
				signatureInfo_2.setSignatureInfoEncoding(
						new Blob(decoder.getSlice(beginOffset, endOffset), copy),
						signatureType);
			}
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		private static void encodeMetaInfo(MetaInfo metaInfo, TlvEncoder encoder) {
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			ByteBuffer finalBlockIdBuf = metaInfo.getFinalBlockId().getValue()
					.buf();
			if (finalBlockIdBuf != null && finalBlockIdBuf.remaining() > 0) {
				// FinalBlockId has an inner NameComponent.
				int finalBlockIdSaveLength = encoder.getLength();
				encodeNameComponent(metaInfo.getFinalBlockId(), encoder);
				encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.FinalBlockId, encoder.getLength()
						- finalBlockIdSaveLength);
			}
	
			encoder.writeOptionalNonNegativeIntegerTlvFromDouble(
					net.named_data.jndn.encoding.tlv.Tlv.FreshnessPeriod, metaInfo.getFreshnessPeriod());
			if (!(metaInfo.getType() == net.named_data.jndn.ContentType.BLOB)) {
				// Not the default, so we need to encode the type.
				if (metaInfo.getType() == net.named_data.jndn.ContentType.LINK
						|| metaInfo.getType() == net.named_data.jndn.ContentType.KEY
						|| metaInfo.getType() == net.named_data.jndn.ContentType.NACK)
					// The ContentType enum is set up with the correct integer for
					// each NDN-TLV ContentType.
					encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.ContentType, metaInfo
							.getType().getNumericType());
				else if (metaInfo.getType() == net.named_data.jndn.ContentType.OTHER_CODE)
					encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.ContentType,
							metaInfo.getOtherTypeCode());
				else
					// We don't expect this to happen.
					throw new Exception("unrecognized TLV ContentType");
			}
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.MetaInfo, encoder.getLength()
					- saveLength);
		}
	
		private static void decodeMetaInfo(MetaInfo metaInfo, TlvDecoder decoder,
				bool copy) {
			int endOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.MetaInfo);
	
			// The ContentType enum is set up with the correct integer for each
			// NDN-TLV ContentType.
			int type = (int) decoder.readOptionalNonNegativeIntegerTlv(
					net.named_data.jndn.encoding.tlv.Tlv.ContentType, endOffset);
			if (type < 0 || type == net.named_data.jndn.ContentType.BLOB.getNumericType())
				// Default to BLOB if the value is omitted.
				metaInfo.setType(net.named_data.jndn.ContentType.BLOB);
			else if (type == net.named_data.jndn.ContentType.LINK.getNumericType())
				metaInfo.setType(net.named_data.jndn.ContentType.LINK);
			else if (type == net.named_data.jndn.ContentType.KEY.getNumericType())
				metaInfo.setType(net.named_data.jndn.ContentType.KEY);
			else if (type == net.named_data.jndn.ContentType.NACK.getNumericType())
				metaInfo.setType(net.named_data.jndn.ContentType.NACK);
			else {
				// Unrecognized content type.
				metaInfo.setType(net.named_data.jndn.ContentType.OTHER_CODE);
				metaInfo.setOtherTypeCode(type);
			}
	
			metaInfo.setFreshnessPeriod(decoder.readOptionalNonNegativeIntegerTlv(
					net.named_data.jndn.encoding.tlv.Tlv.FreshnessPeriod, endOffset));
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.FinalBlockId, endOffset)) {
				int finalBlockIdEndOffset = decoder
						.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.FinalBlockId);
				metaInfo.setFinalBlockId(decodeNameComponent(decoder, copy));
				decoder.finishNestedTlvs(finalBlockIdEndOffset);
			} else
				metaInfo.setFinalBlockId(null);
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		private static void encodeControlParameters(
				ControlParameters controlParameters, TlvEncoder encoder) {
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			encoder.writeOptionalNonNegativeIntegerTlvFromDouble(
					net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_ExpirationPeriod,
					controlParameters.getExpirationPeriod());
	
			// Encode strategy
			if (controlParameters.getStrategy().size() != 0) {
				int strategySaveLength = encoder.getLength();
				encodeName(controlParameters.getStrategy(), new int[1], new int[1],
						encoder);
				encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Strategy,
						encoder.getLength() - strategySaveLength);
			}
	
			// Encode ForwardingFlags
			int flags = controlParameters.getForwardingFlags()
					.getNfdForwardingFlags();
			if (flags != new ForwardingFlags().getNfdForwardingFlags())
				// The flags are not the default value.
				encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Flags,
						flags);
	
			encoder.writeOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Cost,
					controlParameters.getCost());
			encoder.writeOptionalNonNegativeIntegerTlv(
					net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Origin, controlParameters.getOrigin());
			encoder.writeOptionalNonNegativeIntegerTlv(
					net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_LocalControlFeature,
					controlParameters.getLocalControlFeature());
	
			// Encode URI
			if (controlParameters.getUri().Length != 0) {
				encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Uri, new Blob(
						controlParameters.getUri()).buf());
			}
	
			encoder.writeOptionalNonNegativeIntegerTlv(
					net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_FaceId, controlParameters.getFaceId());
	
			// Encode name
			if (controlParameters.getName() != null) {
				encodeName(controlParameters.getName(), new int[1], new int[1],
						encoder);
			}
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_ControlParameters,
					encoder.getLength() - saveLength);
		}
	
		private static void decodeControlParameters(
				ControlParameters controlParameters, TlvDecoder decoder,
				bool copy) {
			controlParameters.clear();
	
			int endOffset = decoder
					.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_ControlParameters);
	
			// decode name
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.Name, endOffset)) {
				Name name = new Name();
				decodeName(name, new int[1], new int[1], decoder, copy);
				controlParameters.setName(name);
			}
	
			// decode face ID
			controlParameters.setFaceId((int) decoder
					.readOptionalNonNegativeIntegerTlv(
							net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_FaceId, endOffset));
	
			// decode URI
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Uri, endOffset)) {
				// Set copy false since we just immediately get the string.
				Blob uri = new Blob(decoder.readOptionalBlobTlv(
						net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Uri, endOffset), false);
				controlParameters.setUri("" + uri);
			}
	
			// decode integers
			controlParameters.setLocalControlFeature((int) decoder
					.readOptionalNonNegativeIntegerTlv(
							net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_LocalControlFeature, endOffset));
			controlParameters.setOrigin((int) decoder
					.readOptionalNonNegativeIntegerTlv(
							net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Origin, endOffset));
			controlParameters.setCost((int) decoder
					.readOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Cost,
							endOffset));
	
			// set forwarding flags
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Flags, endOffset)) {
				ForwardingFlags flags = new ForwardingFlags();
				flags.setNfdForwardingFlags((int) decoder
						.readNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Flags));
				controlParameters.setForwardingFlags(flags);
			}
	
			// decode strategy
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Strategy, endOffset)) {
				int strategyEndOffset = decoder
						.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Strategy);
				decodeName(controlParameters.getStrategy(), new int[1], new int[1],
						decoder, copy);
				decoder.finishNestedTlvs(strategyEndOffset);
			}
	
			// decode expiration period
			controlParameters.setExpirationPeriod(decoder
					.readOptionalNonNegativeIntegerTlv(
							net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_ExpirationPeriod, endOffset));
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		private static readonly Random random_ = new Random();
		private static Tlv0_2WireFormat instance_ = new Tlv0_2WireFormat();
	}
}
