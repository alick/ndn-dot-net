// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 12/23/15 3:55 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2014-2015 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.encoding {
	
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding.tlv;
	using net.named_data.jndn.encrypt;
	using net.named_data.jndn.encrypt.algo;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// A Tlv0_1_1WireFormat implements the WireFormat interface for encoding and
	/// decoding with the NDN-TLV wire format, version 0.1.1.
	/// </summary>
	///
	public class Tlv0_1_1WireFormat : WireFormat {
		/// <summary>
		/// Encode name in NDN-TLV and return the encoding.
		/// </summary>
		///
		/// <param name="name">The Name object to encode.</param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeName(Name name) {
			TlvEncoder encoder = new TlvEncoder();
			encodeName(name, new int[1], new int[1], encoder);
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Decode input as a name in NDN-TLV and set the fields of the Name object.
		/// </summary>
		///
		/// <param name="name">The Name object whose fields are updated.</param>
		/// <param name="input">The input buffer to decode.  This reads from position() to limit(), but does not change the position.</param>
		/// <exception cref="EncodingException">For invalid encoding.</exception>
		public override void decodeName(Name name, ByteBuffer input) {
			TlvDecoder decoder = new TlvDecoder(input);
			decodeName(name, new int[1], new int[1], decoder);
		}
	
		/// <summary>
		/// Encode interest using NDN-TLV and return the encoding.
		/// </summary>
		///
		/// <param name="interest">The Interest object to encode.</param>
		/// <param name="signedPortionBeginOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest).</param>
		/// <param name="signedPortionEndOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest).</param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeInterest(Interest interest,
				int[] signedPortionBeginOffset, int[] signedPortionEndOffset) {
			TlvEncoder encoder = new TlvEncoder();
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			encoder.writeOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.SelectedDelegation,
					interest.getSelectedDelegationIndex());
			try {
				Blob linkWireEncoding = interest.getLinkWireEncoding(this);
				if (!linkWireEncoding.isNull())
					// Encode the entire link as is.
					encoder.writeBuffer(linkWireEncoding.buf());
			} catch (EncodingException ex) {
				throw new Exception(ex.Message);
			}
	
			encoder.writeOptionalNonNegativeIntegerTlvFromDouble(
					net.named_data.jndn.encoding.tlv.Tlv.InterestLifetime,
					interest.getInterestLifetimeMilliseconds());
	
			// Encode the Nonce as 4 bytes.
			if (interest.getNonce().size() == 0) {
				// This is the most common case. Generate a nonce.
				ByteBuffer nonce = ILOG.J2CsMapping.NIO.ByteBuffer.allocate(4);
				random_.nextBytes(nonce.array());
				encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Nonce, nonce);
			} else if (interest.getNonce().size() < 4) {
				ByteBuffer nonce_0 = ILOG.J2CsMapping.NIO.ByteBuffer.allocate(4);
				// Copy existing nonce bytes.
				nonce_0.put(interest.getNonce().buf());
	
				// Generate random bytes for remaining bytes in the nonce.
				for (int i = 0; i < 4 - interest.getNonce().size(); ++i)
					nonce_0.put((byte) random_.Next());
	
				nonce_0.flip();
				encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Nonce, nonce_0);
			} else if (interest.getNonce().size() == 4)
				// Use the nonce as-is.
				encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Nonce, interest.getNonce().buf());
			else {
				// Truncate.
				ByteBuffer nonce_1 = interest.getNonce().buf();
				// buf() returns a new ByteBuffer, so we can change its limit.
				nonce_1.limit(nonce_1.position() + 4);
				encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Nonce, nonce_1);
			}
	
			encodeSelectors(interest, encoder);
			int[] tempSignedPortionBeginOffset = new int[1];
			int[] tempSignedPortionEndOffset = new int[1];
			encodeName(interest.getName(), tempSignedPortionBeginOffset,
					tempSignedPortionEndOffset, encoder);
			int signedPortionBeginOffsetFromBack = encoder.getLength()
					- tempSignedPortionBeginOffset[0];
			int signedPortionEndOffsetFromBack = encoder.getLength()
					- tempSignedPortionEndOffset[0];
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Interest, encoder.getLength()
					- saveLength);
			signedPortionBeginOffset[0] = encoder.getLength()
					- signedPortionBeginOffsetFromBack;
			signedPortionEndOffset[0] = encoder.getLength()
					- signedPortionEndOffsetFromBack;
	
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Decode input as an interest in  NDN-TLV and set the fields of the interest
		/// object.
		/// </summary>
		///
		/// <param name="interest">The Interest object whose fields are updated.</param>
		/// <param name="input"></param>
		/// <param name="signedPortionBeginOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest).</param>
		/// <param name="signedPortionEndOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest).</param>
		/// <exception cref="EncodingException">For invalid encoding.</exception>
		public override void decodeInterest(Interest interest, ByteBuffer input,
				int[] signedPortionBeginOffset, int[] signedPortionEndOffset) {
			TlvDecoder decoder = new TlvDecoder(input);
	
			int endOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Interest);
			decodeName(interest.getName(), signedPortionBeginOffset,
					signedPortionEndOffset, decoder);
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.Selectors, endOffset))
				decodeSelectors(interest, decoder);
			// Require a Nonce, but don't force it to be 4 bytes.
			ByteBuffer nonce = decoder.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Nonce);
			interest.setInterestLifetimeMilliseconds(decoder
					.readOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.InterestLifetime,
							endOffset));
	
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.Data, endOffset)) {
				// Get the bytes of the Link TLV.
				int linkBeginOffset = decoder.getOffset();
				int linkEndOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Data);
				decoder.seek(linkEndOffset);
				ByteBuffer linkEncoding = input.duplicate();
				linkEncoding.limit(linkEndOffset);
				linkEncoding.position(linkBeginOffset);
	
				interest.setLinkWireEncoding(new Blob(linkEncoding, true), this);
			} else
				interest.unsetLink();
			interest.setSelectedDelegationIndex((int) decoder
					.readOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.SelectedDelegation,
							endOffset));
			if (interest.getSelectedDelegationIndex() >= 0 && !interest.hasLink())
				throw new EncodingException(
						"Interest has a selected delegation, but no link object");
	
			// Set the nonce last because setting other interest fields clears it.
			interest.setNonce(new Blob(nonce, true));
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		/// <summary>
		/// Encode data in NDN-TLV and return the encoding.
		/// </summary>
		///
		/// <param name="data">The Data object to encode.</param>
		/// <param name="signedPortionBeginOffset">If you are not encoding in order to sign, you can call encodeData(data) to ignore this returned value.</param>
		/// <param name="signedPortionEndOffset">If you are not encoding in order to sign, you can call encodeData(data) to ignore this returned value.</param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeData(Data data, int[] signedPortionBeginOffset,
				int[] signedPortionEndOffset) {
			TlvEncoder encoder = new TlvEncoder(1500);
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureValue, (data.getSignature())
					.getSignature().buf());
			int signedPortionEndOffsetFromBack = encoder.getLength();
	
			encodeSignatureInfo(data.getSignature(), encoder);
			encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Content, data.getContent().buf());
			encodeMetaInfo(data.getMetaInfo(), encoder);
			encodeName(data.getName(), new int[1], new int[1], encoder);
			int signedPortionBeginOffsetFromBack = encoder.getLength();
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Data, encoder.getLength() - saveLength);
	
			signedPortionBeginOffset[0] = encoder.getLength()
					- signedPortionBeginOffsetFromBack;
			signedPortionEndOffset[0] = encoder.getLength()
					- signedPortionEndOffsetFromBack;
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Decode input as a data packet in NDN-TLV and set the fields in the data
		/// object.
		/// </summary>
		///
		/// <param name="data">The Data object whose fields are updated.</param>
		/// <param name="input"></param>
		/// <param name="signedPortionBeginOffset">If you are not decoding in order to verify, you can call decodeData(data, input) to ignore this returned value.</param>
		/// <param name="signedPortionEndOffset">not decoding in order to verify, you can call decodeData(data, input) to ignore this returned value.</param>
		/// <exception cref="EncodingException">For invalid encoding.</exception>
		public override void decodeData(Data data, ByteBuffer input,
				int[] signedPortionBeginOffset, int[] signedPortionEndOffset) {
			TlvDecoder decoder = new TlvDecoder(input);
	
			int endOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Data);
			signedPortionBeginOffset[0] = decoder.getOffset();
	
			decodeName(data.getName(), new int[1], new int[1], decoder);
			decodeMetaInfo(data.getMetaInfo(), decoder);
			data.setContent(new Blob(decoder.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Content), true));
      decodeSignatureInfo(data, decoder);
	
			signedPortionEndOffset[0] = decoder.getOffset();
			data.getSignature().setSignature(
					new Blob(decoder.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureValue), true));
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		/// <summary>
		/// Encode controlParameters in NDN-TLV and return the encoding.
		/// </summary>
		///
		/// <param name="controlParameters">The ControlParameters object to encode.</param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeControlParameters(ControlParameters controlParameters) {
			TlvEncoder encoder = new TlvEncoder(256);
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			encoder.writeOptionalNonNegativeIntegerTlvFromDouble(
					net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_ExpirationPeriod,
					controlParameters.getExpirationPeriod());
	
			// Encode strategy
			if (controlParameters.getStrategy().size() != 0) {
				int strategySaveLength = encoder.getLength();
				encodeName(controlParameters.getStrategy(), new int[1], new int[1],
						encoder);
				encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Strategy,
						encoder.getLength() - strategySaveLength);
			}
	
			// Encode ForwardingFlags
			int flags = controlParameters.getForwardingFlags()
					.getNfdForwardingFlags();
			if (flags != new ForwardingFlags().getNfdForwardingFlags())
				// The flags are not the default value.
				encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Flags,
						flags);
	
			encoder.writeOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Cost,
					controlParameters.getCost());
			encoder.writeOptionalNonNegativeIntegerTlv(
					net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Origin, controlParameters.getOrigin());
			encoder.writeOptionalNonNegativeIntegerTlv(
					net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_LocalControlFeature,
					controlParameters.getLocalControlFeature());
	
			// Encode URI
			if (controlParameters.getUri().Length != 0) {
				encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Uri, new Blob(
						controlParameters.getUri()).buf());
			}
	
			encoder.writeOptionalNonNegativeIntegerTlv(
					net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_FaceId, controlParameters.getFaceId());
	
			// Encode name
			if (controlParameters.getName() != null) {
				encodeName(controlParameters.getName(), new int[1], new int[1],
						encoder);
			}
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_ControlParameters,
					encoder.getLength() - saveLength);
	
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Decode input as a control parameters in NDN-TLV and set the fields of the
		/// controlParameters object.
		/// </summary>
		///
		/// <param name="controlParameters"></param>
		/// <param name="input"></param>
		/// <exception cref="EncodingException">For invalid encoding</exception>
		public override void decodeControlParameters(ControlParameters controlParameters,
				ByteBuffer input) {
			controlParameters.clear();
	
			TlvDecoder decoder = new TlvDecoder(input);
			int endOffset = decoder
					.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_ControlParameters);
	
			// decode name
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.Name, endOffset)) {
				Name name = new Name();
				decodeName(name, new int[1], new int[1], decoder);
				controlParameters.setName(name);
			}
	
			// decode face ID
			controlParameters.setFaceId((int) decoder
					.readOptionalNonNegativeIntegerTlv(
							net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_FaceId, endOffset));
	
			// decode URI
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Uri, endOffset)) {
				Blob uri = new Blob(decoder.readOptionalBlobTlv(
						net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Uri, endOffset), true);
				controlParameters.setUri("" + uri);
			}
	
			// decode integers
			controlParameters.setLocalControlFeature((int) decoder
					.readOptionalNonNegativeIntegerTlv(
							net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_LocalControlFeature, endOffset));
			controlParameters.setOrigin((int) decoder
					.readOptionalNonNegativeIntegerTlv(
							net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Origin, endOffset));
			controlParameters.setCost((int) decoder
					.readOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Cost,
							endOffset));
	
			// set forwarding flags
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Flags, endOffset)) {
				ForwardingFlags flags = new ForwardingFlags();
				flags.setNfdForwardingFlags((int) decoder
						.readNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Flags));
				controlParameters.setForwardingFlags(flags);
			}
	
			// decode strategy
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Strategy, endOffset)) {
				int strategyEndOffset = decoder
						.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_Strategy);
				decodeName(controlParameters.getStrategy(), new int[1], new int[1],
						decoder);
				decoder.finishNestedTlvs(strategyEndOffset);
			}
	
			// decode expiration period
			controlParameters.setExpirationPeriod(decoder
					.readOptionalNonNegativeIntegerTlv(
							net.named_data.jndn.encoding.tlv.Tlv.ControlParameters_ExpirationPeriod, endOffset));
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		/// <summary>
		/// Encode signature as a SignatureInfo in NDN-TLV and return the encoding.
		/// </summary>
		///
		/// <param name="signature">An object of a subclass of Signature to encode.</param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeSignatureInfo(Signature signature) {
			TlvEncoder encoder = new TlvEncoder(256);
			encodeSignatureInfo(signature, encoder);
	
			return new Blob(encoder.getOutput(), false);
		}
	
		private class SimpleSignatureHolder : SignatureHolder {
			public virtual Data setSignature(Signature signature) {
				signature_ = signature;
				return null;
			}
	
			public virtual Signature getSignature() {
				return signature_;
			}
	
			private Signature signature_;
		}
	
		/// <summary>
		/// Decode signatureInfo as an NDN-TLV signature info and signatureValue as the
		/// related NDN-TLV SignatureValue, and return a new object which is a subclass
		/// of Signature.
		/// </summary>
		///
		/// <param name="signatureInfo"></param>
		/// <param name="signatureValue"></param>
		/// <returns>A new object which is a subclass of Signature.</returns>
		/// <exception cref="EncodingException">For invalid encoding.</exception>
		public override Signature decodeSignatureInfoAndValue(ByteBuffer signatureInfo,
				ByteBuffer signatureValue) {
			// Use a SignatureHolder to imitate a Data object for _decodeSignatureInfo.
			Tlv0_1_1WireFormat.SimpleSignatureHolder  signatureHolder = new Tlv0_1_1WireFormat.SimpleSignatureHolder ();
			TlvDecoder decoder = new TlvDecoder(signatureInfo);
			decodeSignatureInfo(signatureHolder, decoder);
	
			decoder = new TlvDecoder(signatureValue);
			signatureHolder.getSignature().setSignature(
					new Blob(decoder.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureValue), true));
	
			return signatureHolder.getSignature();
		}
	
		/// <summary>
		/// Encode the signatureValue in the Signature object as a SignatureValue (the
		/// signature bits) in NDN-TLV and return the encoding.
		/// </summary>
		///
		/// <param name="signature"></param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeSignatureValue(Signature signature) {
			TlvEncoder encoder = new TlvEncoder(256);
			encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureValue, signature.getSignature().buf());
	
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Encode the LocalControlHeader in NDN-TLV and return the encoding.
		/// </summary>
		///
		/// <param name="localControlHeader">The LocalControlHeader object to encode.</param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeLocalControlHeader(LocalControlHeader localControlHeader) {
			TlvEncoder encoder = new TlvEncoder(256);
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			// Encode the entire payload as is.
			encoder.writeBuffer(localControlHeader.getPayloadWireEncoding().buf());
	
			// TODO: Encode CachingPolicy when we want to include it for an outgoing Data.
			encoder.writeOptionalNonNegativeIntegerTlv(
					net.named_data.jndn.encoding.tlv.Tlv.LocalControlHeader_NextHopFaceId,
					localControlHeader.getNextHopFaceId());
			encoder.writeOptionalNonNegativeIntegerTlv(
					net.named_data.jndn.encoding.tlv.Tlv.LocalControlHeader_IncomingFaceId,
					localControlHeader.getIncomingFaceId());
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.LocalControlHeader_LocalControlHeader,
					encoder.getLength() - saveLength);
	
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Decode input as a LocalControlHeader in NDN-TLV and set the fields of the
		/// localControlHeader object.
		/// </summary>
		///
		/// <param name="localControlHeader"></param>
		/// <param name="input"></param>
		/// <exception cref="EncodingException">For invalid encoding</exception>
		public override void decodeLocalControlHeader(LocalControlHeader localControlHeader,
				ByteBuffer input) {
			TlvDecoder decoder = new TlvDecoder(input);
			int endOffset = decoder
					.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.LocalControlHeader_LocalControlHeader);
	
			localControlHeader.setIncomingFaceId(decoder
					.readOptionalNonNegativeIntegerTlv(
							net.named_data.jndn.encoding.tlv.Tlv.LocalControlHeader_IncomingFaceId, endOffset));
			localControlHeader.setNextHopFaceId(decoder
					.readOptionalNonNegativeIntegerTlv(
							net.named_data.jndn.encoding.tlv.Tlv.LocalControlHeader_NextHopFaceId, endOffset));
	
			// Ignore CachingPolicy. // TODO: Process CachingPolicy when we want the
			// client library to receive it for an incoming Data.
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.LocalControlHeader_CachingPolicy, endOffset)) {
				int cachingPolicyEndOffset = decoder
						.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.LocalControlHeader_CachingPolicy);
				decoder.finishNestedTlvs(cachingPolicyEndOffset);
			}
	
			// Set the payload to a slice of the remaining input.
			ByteBuffer payload = input.duplicate();
			payload.limit(endOffset);
			payload.position(decoder.getOffset());
			localControlHeader.setPayloadWireEncoding(new Blob(payload, false));
	
			// Don't call finishNestedTlvs since we got the payload and don't want to
			// decode any of it now.
		}
	
		/// <summary>
		/// Encode delegationSet as a sequence of NDN-TLV Delegation, and return the
		/// encoding. Note that the sequence of Delegation does not have an outer TLV
		/// type and length because it is intended to use the type and length of a Data
		/// packet's Content.
		/// </summary>
		///
		/// <param name="delegationSet">The DelegationSet object to encode.</param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeDelegationSet(DelegationSet delegationSet) {
			TlvEncoder encoder = new TlvEncoder(256);
	
			// Encode backwards.
			for (int i = delegationSet.size() - 1; i >= 0; --i) {
				int saveLength = encoder.getLength();
	
				encodeName(delegationSet.get(i).getName(), new int[1], new int[1],
						encoder);
				encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.Link_Preference,
						delegationSet.get(i).getPreference());
	
				encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Link_Delegation, encoder.getLength()
						- saveLength);
			}
	
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Decode input as a sequence of NDN-TLV Delegation and set the fields of the
		/// delegationSet object. Note that the sequence of Delegation does not have an
		/// outer TLV type and length because it is intended to use the type and length
		/// of a Data packet's Content. This ignores any elements after the sequence
		/// of Delegation and before input.limit().
		/// </summary>
		///
		/// <param name="delegationSet">The DelegationSet object whose fields are updated.</param>
		/// <param name="input"></param>
		/// <exception cref="EncodingException">For invalid encoding.</exception>
		public override void decodeDelegationSet(DelegationSet delegationSet,
				ByteBuffer input) {
			TlvDecoder decoder = new TlvDecoder(input);
			int endOffset = input.limit();
	
			delegationSet.clear();
			while (decoder.getOffset() < endOffset) {
				decoder.readTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Link_Delegation);
				int preference = (int) decoder
						.readNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.Link_Preference);
				Name name = new Name();
				decodeName(name, new int[1], new int[1], decoder);
	
				// Add unsorted to preserve the order so that Interest selected delegation
				// index will work.
				delegationSet.addUnsorted(preference, name);
			}
		}
	
		/// <summary>
		/// Encode the EncryptedContent in NDN-TLV and return the encoding.
		/// </summary>
		///
		/// <param name="encryptedContent">The EncryptedContent object to encode.</param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeEncryptedContent(EncryptedContent encryptedContent) {
			TlvEncoder encoder = new TlvEncoder(256);
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_EncryptedPayload, encryptedContent
					.getPayload().buf());
			encoder.writeOptionalBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_InitialVector,
					encryptedContent.getInitialVector().buf());
			// Assume the algorithmType value is the same as the TLV type.
			encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_EncryptionAlgorithm,
					encryptedContent.getAlgorithmType().getNumericType());
			Tlv0_1_1WireFormat.encodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.KeyLocator,
					encryptedContent.getKeyLocator(), encoder);
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_EncryptedContent,
					encoder.getLength() - saveLength);
	
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Decode input as a EncryptedContent in NDN-TLV and set the fields of the
		/// localControlHeader object.
		/// </summary>
		///
		/// <param name="encryptedContent"></param>
		/// <param name="input"></param>
		/// <exception cref="EncodingException">For invalid encoding</exception>
		public override void decodeEncryptedContent(EncryptedContent encryptedContent,
				ByteBuffer input) {
			TlvDecoder decoder = new TlvDecoder(input);
			int endOffset = decoder
					.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_EncryptedContent);
	
			Tlv0_1_1WireFormat.decodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.KeyLocator,
					encryptedContent.getKeyLocator(), decoder);
	
			int algorithmType = (int) decoder
					.readNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_EncryptionAlgorithm);
			if (algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesEcb.getNumericType())
				encryptedContent.setAlgorithmType(net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesEcb);
			else if (algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesCbc.getNumericType())
				encryptedContent.setAlgorithmType(net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesCbc);
			else if (algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaPkcs.getNumericType())
				encryptedContent.setAlgorithmType(net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaPkcs);
			else if (algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaOaep.getNumericType())
				encryptedContent.setAlgorithmType(net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaOaep);
			else
				throw new EncodingException(
						"Unrecognized EncryptionAlgorithm code " + algorithmType);
	
			encryptedContent.setInitialVector(new Blob(decoder.readOptionalBlobTlv(
					net.named_data.jndn.encoding.tlv.Tlv.Encrypt_InitialVector, endOffset), true));
			encryptedContent.setPayload(new Blob(decoder
					.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_EncryptedPayload), true));
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		/// <summary>
		/// Get a singleton instance of a Tlv0_1_1WireFormat.  To always use the
		/// preferred version NDN-TLV, you should use TlvWireFormat.get().
		/// </summary>
		///
		/// <returns>The singleton instance.</returns>
		public static Tlv0_1_1WireFormat get() {
			return instance_;
		}
	
		/// <summary>
		/// Encode the name to the encoder.
		/// </summary>
		///
		/// <param name="name">The name to encode.</param>
		/// <param name="signedPortionBeginOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest).</param>
		/// <param name="signedPortionEndOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest).</param>
		/// <param name="encoder">The TlvEncoder to receive the encoding.</param>
		private static void encodeName(Name name, int[] signedPortionBeginOffset,
				int[] signedPortionEndOffset, TlvEncoder encoder) {
			int saveLength = encoder.getLength();
	
			// Encode the components backwards.
			int signedPortionEndOffsetFromBack = 0;
			for (int i = name.size() - 1; i >= 0; --i) {
				encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.NameComponent, name.get(i).getValue()
						.buf());
				if (i == name.size() - 1)
					signedPortionEndOffsetFromBack = encoder.getLength();
			}
	
			int signedPortionBeginOffsetFromBack = encoder.getLength();
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Name, encoder.getLength() - saveLength);
	
			signedPortionBeginOffset[0] = encoder.getLength()
					- signedPortionBeginOffsetFromBack;
			if (name.size() == 0)
				// There is no "final component", so set signedPortionEndOffset
				//   arbitrarily.
				signedPortionEndOffset[0] = signedPortionBeginOffset[0];
			else
				signedPortionEndOffset[0] = encoder.getLength()
						- signedPortionEndOffsetFromBack;
		}
	
		/// <summary>
		/// Decode the name as NDN-TLV and set the fields in name.
		/// </summary>
		///
		/// <param name="name">The name object whose fields are set.</param>
		/// <param name="signedPortionBeginOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest). If you are not decoding in order to verify, you can ignore this returned value.</param>
		/// <param name="signedPortionEndOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest). If you are not decoding in order to verify, you can ignore this returned value.</param>
		/// <param name="decoder">The decoder with the input to decode.</param>
		/// <exception cref="EncodingException"></exception>
		private static void decodeName(Name name, int[] signedPortionBeginOffset,
				int[] signedPortionEndOffset, TlvDecoder decoder) {
			name.clear();
	
			int endOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Name);
	
			signedPortionBeginOffset[0] = decoder.getOffset();
			// In case there are no components, set signedPortionEndOffset arbitrarily.
			signedPortionEndOffset[0] = signedPortionBeginOffset[0];
	
			while (decoder.getOffset() < endOffset) {
				signedPortionEndOffset[0] = decoder.getOffset();
				name.append(new Blob(decoder.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.NameComponent), true));
			}
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		/// <summary>
		/// Encode the interest selectors.  If no selectors are written, do not output
		/// a  Selectors TLV.
		/// </summary>
		///
		private static void encodeSelectors(Interest interest, TlvEncoder encoder) {
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			if (interest.getMustBeFresh())
				encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.MustBeFresh, 0);
			encoder.writeOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.ChildSelector,
					interest.getChildSelector());
			if (interest.getExclude().size() > 0)
				encodeExclude(interest.getExclude(), encoder);
	
			if (interest.getKeyLocator().getType() != net.named_data.jndn.KeyLocatorType.NONE)
				encodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.PublisherPublicKeyLocator,
						interest.getKeyLocator(), encoder);
	
			encoder.writeOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.MaxSuffixComponents,
					interest.getMaxSuffixComponents());
			encoder.writeOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.MinSuffixComponents,
					interest.getMinSuffixComponents());
	
			// Only output the type and length if values were written.
			if (encoder.getLength() != saveLength)
				encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Selectors, encoder.getLength()
						- saveLength);
		}
	
		private static void decodeSelectors(Interest interest, TlvDecoder decoder) {
			int endOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Selectors);
	
			interest.setMinSuffixComponents((int) decoder
					.readOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.MinSuffixComponents,
							endOffset));
			interest.setMaxSuffixComponents((int) decoder
					.readOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.MaxSuffixComponents,
							endOffset));
	
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.PublisherPublicKeyLocator, endOffset))
				decodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.PublisherPublicKeyLocator,
						interest.getKeyLocator(), decoder);
			else
				interest.getKeyLocator().clear();
	
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.Exclude, endOffset))
				decodeExclude(interest.getExclude(), decoder);
			else
				interest.getExclude().clear();
	
			interest.setChildSelector((int) decoder
					.readOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.ChildSelector, endOffset));
			interest.setMustBeFresh(decoder.readBooleanTlv(net.named_data.jndn.encoding.tlv.Tlv.MustBeFresh,
					endOffset));
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		private static void encodeExclude(Exclude exclude, TlvEncoder encoder) {
			int saveLength = encoder.getLength();
	
			// TODO: Do we want to order the components (except for ANY)?
			// Encode the entries backwards.
			for (int i = exclude.size() - 1; i >= 0; --i) {
				Exclude.Entry entry = exclude.get(i);
	
				if (entry.getType() == net.named_data.jndn.Exclude.Type.ANY)
					encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Any, 0);
				else
					encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.NameComponent, entry.getComponent()
							.getValue().buf());
			}
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Exclude, encoder.getLength()
					- saveLength);
		}
	
		private static void decodeExclude(Exclude exclude, TlvDecoder decoder) {
			int endOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Exclude);
	
			exclude.clear();
			while (true) {
				if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.NameComponent, endOffset))
					exclude.appendComponent(new Name.Component(new Blob(decoder
							.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.NameComponent), true)));
				else if (decoder.readBooleanTlv(net.named_data.jndn.encoding.tlv.Tlv.Any, endOffset))
					exclude.appendAny();
				else
					// Else no more entries.
					break;
			}
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		private static void encodeKeyLocator(int type, KeyLocator keyLocator,
				TlvEncoder encoder) {
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			if (keyLocator.getType() != net.named_data.jndn.KeyLocatorType.NONE) {
				if (keyLocator.getType() == net.named_data.jndn.KeyLocatorType.KEYNAME)
					encodeName(keyLocator.getKeyName(), new int[1], new int[1],
							encoder);
				else if (keyLocator.getType() == net.named_data.jndn.KeyLocatorType.KEY_LOCATOR_DIGEST
						&& keyLocator.getKeyData().size() > 0)
					encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.KeyLocatorDigest, keyLocator
							.getKeyData().buf());
				else
					throw new Exception("Unrecognized KeyLocatorType "
							+ keyLocator.getType());
			}
	
			encoder.writeTypeAndLength(type, encoder.getLength() - saveLength);
		}
	
		private static void decodeKeyLocator(int expectedType,
				KeyLocator keyLocator, TlvDecoder decoder) {
			int endOffset = decoder.readNestedTlvsStart(expectedType);
	
			keyLocator.clear();
	
			if (decoder.getOffset() == endOffset)
				// The KeyLocator is omitted, so leave the fields as none.
				return;
	
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.Name, endOffset)) {
				// KeyLocator is a Name.
				keyLocator.setType(net.named_data.jndn.KeyLocatorType.KEYNAME);
				decodeName(keyLocator.getKeyName(), new int[1], new int[1], decoder);
			} else if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.KeyLocatorDigest, endOffset)) {
				// KeyLocator is a KeyLocatorDigest.
				keyLocator.setType(net.named_data.jndn.KeyLocatorType.KEY_LOCATOR_DIGEST);
				keyLocator.setKeyData(new Blob(decoder
						.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.KeyLocatorDigest), true));
			} else
				throw new EncodingException(
						"decodeKeyLocator: Unrecognized key locator type");
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		/// <summary>
		/// An internal method to encode signature as the appropriate form of
		/// SignatureInfo in NDN-TLV.
		/// </summary>
		///
		/// <param name="signature">An object of a subclass of Signature to encode.</param>
		/// <param name="encoder">The TlvEncoder to receive the encoding.</param>
		private void encodeSignatureInfo(Signature signature, TlvEncoder encoder) {
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			if (signature  is  Sha256WithRsaSignature) {
				encodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.KeyLocator,
						((Sha256WithRsaSignature) signature).getKeyLocator(),
						encoder);
				encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureType,
						net.named_data.jndn.encoding.tlv.Tlv.SignatureType_SignatureSha256WithRsa);
			} else if (signature  is  Sha256WithEcdsaSignature) {
				encodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.KeyLocator,
						((Sha256WithEcdsaSignature) signature).getKeyLocator(),
						encoder);
				encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureType,
						net.named_data.jndn.encoding.tlv.Tlv.SignatureType_SignatureSha256WithEcdsa);
			} else if (signature  is  DigestSha256Signature)
				encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureType,
						net.named_data.jndn.encoding.tlv.Tlv.SignatureType_DigestSha256);
			else
				throw new Exception(
						"encodeSignatureInfo: Unrecognized Signature object type");
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.SignatureInfo, encoder.getLength()
					- saveLength);
		}
	
		private static void decodeSignatureInfo(SignatureHolder signatureHolder,
				TlvDecoder decoder) {
			int endOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.SignatureInfo);
	
			int signatureType = (int) decoder
					.readNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.SignatureType);
			if (signatureType == net.named_data.jndn.encoding.tlv.Tlv.SignatureType_SignatureSha256WithRsa) {
				signatureHolder.setSignature(new Sha256WithRsaSignature());
				// Modify data's signature object because if we create an object
				//   and set it, then data will have to copy all the fields.
				Sha256WithRsaSignature signatureInfo = (Sha256WithRsaSignature) signatureHolder
						.getSignature();
				decodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.KeyLocator, signatureInfo.getKeyLocator(),
						decoder);
			} else if (signatureType == net.named_data.jndn.encoding.tlv.Tlv.SignatureType_SignatureSha256WithEcdsa) {
				signatureHolder.setSignature(new Sha256WithEcdsaSignature());
				Sha256WithEcdsaSignature signatureInfo_0 = (Sha256WithEcdsaSignature) signatureHolder
						.getSignature();
				decodeKeyLocator(net.named_data.jndn.encoding.tlv.Tlv.KeyLocator, signatureInfo_0.getKeyLocator(),
						decoder);
			} else if (signatureType == net.named_data.jndn.encoding.tlv.Tlv.SignatureType_DigestSha256)
				signatureHolder.setSignature(new DigestSha256Signature());
			else
				throw new EncodingException(
						"decodeSignatureInfo: unrecognized SignatureInfo type"
								+ signatureType);
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		private static void encodeMetaInfo(MetaInfo metaInfo, TlvEncoder encoder) {
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			ByteBuffer finalBlockIdBuf = metaInfo.getFinalBlockId().getValue()
					.buf();
			if (finalBlockIdBuf != null && finalBlockIdBuf.remaining() > 0) {
				// FinalBlockId has an inner NameComponent.
				int finalBlockIdSaveLength = encoder.getLength();
				encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.NameComponent, finalBlockIdBuf);
				encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.FinalBlockId, encoder.getLength()
						- finalBlockIdSaveLength);
			}
	
			encoder.writeOptionalNonNegativeIntegerTlvFromDouble(
					net.named_data.jndn.encoding.tlv.Tlv.FreshnessPeriod, metaInfo.getFreshnessPeriod());
			if (!(metaInfo.getType() == net.named_data.jndn.ContentType.BLOB)) {
				// Not the default, so we need to encode the type.
				if (metaInfo.getType() == net.named_data.jndn.ContentType.LINK
						|| metaInfo.getType() == net.named_data.jndn.ContentType.KEY
						|| metaInfo.getType() == net.named_data.jndn.ContentType.NACK)
					// The ContentType enum is set up with the correct integer for
					// each NDN-TLV ContentType.
					encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.ContentType, metaInfo
							.getType().getNumericType());
				else
					throw new Exception("unrecognized TLV ContentType");
			}
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.MetaInfo, encoder.getLength()
					- saveLength);
		}
	
		private static void decodeMetaInfo(MetaInfo metaInfo, TlvDecoder decoder) {
			int endOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.MetaInfo);
	
			// The ContentType enum is set up with the correct integer for each
			// NDN-TLV ContentType.  If readOptionalNonNegativeIntegerTlv returns
			// None, then setType will convert it to BLOB.
			int type = (int) decoder.readOptionalNonNegativeIntegerTlv(
					net.named_data.jndn.encoding.tlv.Tlv.ContentType, endOffset);
			if (type == net.named_data.jndn.ContentType.LINK.getNumericType())
				metaInfo.setType(net.named_data.jndn.ContentType.LINK);
			else if (type == net.named_data.jndn.ContentType.KEY.getNumericType())
				metaInfo.setType(net.named_data.jndn.ContentType.KEY);
			else if (type == net.named_data.jndn.ContentType.NACK.getNumericType())
				metaInfo.setType(net.named_data.jndn.ContentType.NACK);
			else
				// Default to BLOB.
				metaInfo.setType(net.named_data.jndn.ContentType.BLOB);
	
			metaInfo.setFreshnessPeriod(decoder.readOptionalNonNegativeIntegerTlv(
					net.named_data.jndn.encoding.tlv.Tlv.FreshnessPeriod, endOffset));
			if (decoder.peekType(net.named_data.jndn.encoding.tlv.Tlv.FinalBlockId, endOffset)) {
				int finalBlockIdEndOffset = decoder
						.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.FinalBlockId);
				metaInfo.setFinalBlockId(new Name.Component(new Blob(decoder
						.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.NameComponent), true)));
				decoder.finishNestedTlvs(finalBlockIdEndOffset);
			} else
				metaInfo.setFinalBlockId(null);
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		private static readonly SecureRandom random_ = new SecureRandom();
		private static Tlv0_1_1WireFormat instance_ = new Tlv0_1_1WireFormat();
	}
}
