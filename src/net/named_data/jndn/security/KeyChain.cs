// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2014-2017 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security {
	
	using ILOG.J2CsMapping.NIO;
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.encoding.der;
	using net.named_data.jndn.security.certificate;
	using net.named_data.jndn.security.identity;
	using net.named_data.jndn.security.policy;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// KeyChain is the main class of the security library.
	/// The KeyChain class provides a set of interfaces to the security library such
	/// as identity management, policy configuration and packet signing and
	/// verification.
	/// </summary>
	///
	/// @note This class is an experimental feature.  See the API docs for more
	/// detail at
	/// http://named-data.net/doc/ndn-ccl-api/key-chain.html .
	public class KeyChain {
		/// <summary>
		/// Create a new KeyChain with the given IdentityManager and PolicyManager.
		/// </summary>
		///
		/// <param name="identityManager">An object of a subclass of IdentityManager.</param>
		/// <param name="policyManager">An object of a subclass of PolicyManager.</param>
		public KeyChain(IdentityManager identityManager, PolicyManager policyManager) {
			this.face_ = null;
			identityManager_ = identityManager;
			policyManager_ = policyManager;
		}
	
		/// <summary>
		/// Create a new KeyChain with the given IdentityManager and a
		/// NoVerifyPolicyManager.
		/// </summary>
		///
		/// <param name="identityManager">An object of a subclass of IdentityManager.</param>
		public KeyChain(IdentityManager identityManager) {
			this.face_ = null;
			identityManager_ = identityManager;
			policyManager_ = new NoVerifyPolicyManager();
		}
	
#if false
		/// <summary>
		/// Create a new KeyChain with the the default IdentityManager and a
		/// NoVerifyPolicyManager.
		/// </summary>
		///
		public KeyChain() {
			this.face_ = null;
			identityManager_ = new IdentityManager();
			policyManager_ = new NoVerifyPolicyManager();
		}
#endif
	
		/*****************************************
		 *          Identity Management          *
		 *****************************************/
	
		/// <summary>
		/// Create an identity by creating a pair of Key-Signing-Key (KSK) for this
		/// identity and a self-signed certificate of the KSK. If a key pair or
		/// certificate for the identity already exists, use it.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="params"></param>
		/// <returns>The name of the default certificate of the identity.</returns>
		/// <exception cref="System.Security.SecurityException">if the identity has already been created.</exception>
		public Name createIdentityAndCertificate(Name identityName,
				KeyParams paras) {
			return identityManager_.createIdentityAndCertificate(identityName,
					paras);
		}
	
		/// <summary>
		/// Create an identity by creating a pair of Key-Signing-Key (KSK) for this
		/// identity and a self-signed certificate of the KSK. Use DEFAULT_KEY_PARAMS
		/// to create the key if needed. If a key pair or certificate for the identity
		/// already exists, use it.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The name of the default certificate of the identity.</returns>
		/// <exception cref="System.Security.SecurityException">if the identity has already been created.</exception>
		public Name createIdentityAndCertificate(Name identityName) {
			return createIdentityAndCertificate(identityName, DEFAULT_KEY_PARAMS);
		}
	
		/// <summary>
		/// Create an identity by creating a pair of Key-Signing-Key (KSK) for this
		/// identity and a self-signed certificate of the KSK.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="params"></param>
		/// <returns>The key name of the auto-generated KSK of the identity.</returns>
		/// <exception cref="System.Security.SecurityException">if the identity has already been created.</exception>
		public Name createIdentity(Name identityName, KeyParams paras) {
			return net.named_data.jndn.security.certificate.IdentityCertificate
					.certificateNameToPublicKeyName(createIdentityAndCertificate(
							identityName, paras));
		}
	
		/// <summary>
		/// Create an identity by creating a pair of Key-Signing-Key (KSK) for this
		/// identity and a self-signed certificate of the KSK. Use DEFAULT_KEY_PARAMS
		/// to create the key if needed.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The key name of the auto-generated KSK of the identity.</returns>
		/// <exception cref="System.Security.SecurityException">if the identity has already been created.</exception>
		public Name createIdentity(Name identityName) {
			return net.named_data.jndn.security.certificate.IdentityCertificate
					.certificateNameToPublicKeyName(createIdentityAndCertificate(identityName));
		}
	
		/// <summary>
		/// Delete the identity from the public and private key storage. If the
		/// identity to be deleted is the current default system default, this will not
		/// delete the identity and will return immediately.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		public void deleteIdentity(Name identityName) {
			identityManager_.deleteIdentity(identityName);
		}
	
		/// <summary>
		/// Get the default identity.
		/// </summary>
		///
		/// <returns>The name of default identity.</returns>
		/// <exception cref="System.Security.SecurityException">if the default identity is not set.</exception>
		public Name getDefaultIdentity() {
			return identityManager_.getDefaultIdentity();
		}
	
		/// <summary>
		/// Get the default certificate name of the default identity.
		/// </summary>
		///
		/// <returns>The requested certificate name.</returns>
		/// <exception cref="System.Security.SecurityException">if the default identity is not set or the defaultkey name for the identity is not set or the default certificate name forthe key name is not set.</exception>
		public Name getDefaultCertificateName() {
			return identityManager_.getDefaultCertificateName();
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <param name="keySize">The size of the key.</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPair(Name identityName, bool isKsk,
				int keySize) {
			return identityManager_
					.generateRSAKeyPair(identityName, isKsk, keySize);
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity and default keySize
		/// 2048.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPair(Name identityName, bool isKsk) {
			return identityManager_.generateRSAKeyPair(identityName, isKsk);
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity for a
		/// Data-Signing-Key and default keySize 2048.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPair(Name identityName) {
			return identityManager_.generateRSAKeyPair(identityName);
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <param name="keySize">The size of the key.</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPair(Name identityName, bool isKsk,
				int keySize) {
			return identityManager_.generateEcdsaKeyPair(identityName, isKsk,
					keySize);
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity and default keySize
		/// 256.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPair(Name identityName, bool isKsk) {
			return identityManager_.generateEcdsaKeyPair(identityName, isKsk);
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity for a
		/// Data-Signing-Key and default keySize 256.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPair(Name identityName) {
			return identityManager_.generateEcdsaKeyPair(identityName);
		}
	
		/// <summary>
		/// Set a key as the default key of an identity. The identity name is inferred
		/// from keyName.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <param name="identityNameCheck"></param>
		public void setDefaultKeyForIdentity(Name keyName,
				Name identityNameCheck) {
			identityManager_.setDefaultKeyForIdentity(keyName, identityNameCheck);
		}
	
		/// <summary>
		/// Set a key as the default key of an identity. The identity name is inferred
		/// from keyName.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		public void setDefaultKeyForIdentity(Name keyName) {
			identityManager_.setDefaultKeyForIdentity(keyName);
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity and set it as
		/// default key for the identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <param name="keySize">The size of the key.</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPairAsDefault(Name identityName,
				bool isKsk, int keySize) {
			return identityManager_.generateRSAKeyPairAsDefault(identityName,
					isKsk, keySize);
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity and set it as
		/// default key for the identity, using the default keySize 2048.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPairAsDefault(Name identityName,
				bool isKsk) {
			return identityManager_
					.generateRSAKeyPairAsDefault(identityName, isKsk);
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity and set it as
		/// default key for the identity for a Data-Signing-Key and using the default
		/// keySize 2048.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPairAsDefault(Name identityName) {
			return identityManager_.generateRSAKeyPairAsDefault(identityName);
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity and set it as
		/// default key for the identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <param name="keySize">The size of the key.</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPairAsDefault(Name identityName,
				bool isKsk, int keySize) {
			return identityManager_.generateEcdsaKeyPairAsDefault(identityName,
					isKsk, keySize);
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity and set it as
		/// default key for the identity, using the default keySize 256.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPairAsDefault(Name identityName,
				bool isKsk) {
			return identityManager_.generateEcdsaKeyPairAsDefault(identityName,
					isKsk);
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity and set it as
		/// default key for the identity for a Data-Signing-Key and using the default
		/// keySize 256.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPairAsDefault(Name identityName) {
			return identityManager_.generateEcdsaKeyPairAsDefault(identityName);
		}
	
		/// <summary>
		/// Create a public key signing request.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <returns>The signing request data.</returns>
		/// <exception cref="System.Security.SecurityException">if the keyName is not found.</exception>
		public Blob createSigningRequest(Name keyName) {
			return identityManager_.getPublicKey(keyName).getKeyDer();
		}
	
		/// <summary>
		/// Install an identity certificate into the public key identity storage.
		/// </summary>
		///
		/// <param name="certificate">The certificate to to added.</param>
		public void installIdentityCertificate(IdentityCertificate certificate) {
			identityManager_.addCertificate(certificate);
		}
	
		/// <summary>
		/// Set the certificate as the default for its corresponding key.
		/// </summary>
		///
		/// <param name="certificate">The certificate.</param>
		public void setDefaultCertificateForKey(
				IdentityCertificate certificate) {
			identityManager_.setDefaultCertificateForKey(certificate);
		}
	
		/// <summary>
		/// Get a certificate with the specified name.
		/// </summary>
		///
		/// <param name="certificateName">The name of the requested certificate.</param>
		/// <returns>The requested certificate.</returns>
		public IdentityCertificate getCertificate(Name certificateName) {
			return identityManager_.getCertificate(certificateName);
		}
	
		public IdentityCertificate getIdentityCertificate(Name certificateName) {
			return identityManager_.getCertificate(certificateName);
		}
	
		/// <summary>
		/// Revoke a key.
		/// </summary>
		///
		/// <param name="keyName">The name of the key that will be revoked.</param>
		public void revokeKey(Name keyName) {
			//TODO: Implement
		}
	
		/// <summary>
		/// Revoke a certificate.
		/// </summary>
		///
		/// <param name="certificateName">The name of the certificate that will be revoked.</param>
		public void revokeCertificate(Name certificateName) {
			//TODO: Implement
		}
	
		/// <summary>
		/// Get the identity manager given to or created by the constructor.
		/// </summary>
		///
		/// <returns>The identity manager.</returns>
		public IdentityManager getIdentityManager() {
			return identityManager_;
		}
	
		/*****************************************
		 *              Sign/Verify              *
		 *****************************************/
	
		/// <summary>
		/// Wire encode the Data object, sign it and set its signature.
		/// </summary>
		///
		/// <param name="data"></param>
		/// <param name="certificateName">The certificate name of the key to use for signing.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the input.</param>
		public void sign(Data data, Name certificateName,
				WireFormat wireFormat) {
			identityManager_.signByCertificate(data, certificateName, wireFormat);
		}
	
		/// <summary>
		/// Wire encode the Data object, sign it and set its signature.
		/// Use the default WireFormat.getDefaultWireFormat()
		/// </summary>
		///
		/// <param name="data"></param>
		/// <param name="certificateName">The certificate name of the key to use for signing.</param>
		public void sign(Data data, Name certificateName) {
			sign(data, certificateName, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Wire encode the Data object, sign it with the default identity and set its
		/// signature.
		/// </summary>
		///
		/// <param name="data"></param>
		/// <param name="wireFormat">A WireFormat object used to encode the input.</param>
		public void sign(Data data, WireFormat wireFormat) {
			identityManager_.signByCertificate(data,
					prepareDefaultCertificateName(), wireFormat);
		}
	
		/// <summary>
		/// Wire encode the Data object, sign it with the default identity and set its
		/// signature.
		/// Use the default WireFormat.getDefaultWireFormat()
		/// </summary>
		///
		/// <param name="data"></param>
		public void sign(Data data) {
			sign(data, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Append a SignatureInfo to the Interest name, sign the name components and
		/// append a final name component with the signature bits.
		/// </summary>
		///
		/// <param name="interest"></param>
		/// <param name="certificateName">The certificate name of the key to use for signing.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the input.</param>
		public void sign(Interest interest, Name certificateName,
				WireFormat wireFormat) {
			identityManager_.signInterestByCertificate(interest, certificateName,
					wireFormat);
		}
	
		/// <summary>
		/// Append a SignatureInfo to the Interest name, sign the name components and
		/// append a final name component with the signature bits.
		/// </summary>
		///
		/// <param name="interest"></param>
		/// <param name="certificateName">The certificate name of the key to use for signing.</param>
		public void sign(Interest interest, Name certificateName) {
			sign(interest, certificateName, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Append a SignatureInfo to the Interest name, sign the name components with
		/// the default identity and append a final name component with the signature
		/// bits.
		/// </summary>
		///
		/// <param name="interest"></param>
		/// <param name="wireFormat">A WireFormat object used to encode the input.</param>
		public void sign(Interest interest, WireFormat wireFormat) {
			identityManager_.signInterestByCertificate(interest,
					prepareDefaultCertificateName(), wireFormat);
		}
	
		/// <summary>
		/// Append a SignatureInfo to the Interest name, sign the name components with
		/// the default identity and append a final name component with the signature
		/// bits.
		/// </summary>
		///
		/// <param name="interest"></param>
		public void sign(Interest interest) {
			sign(interest, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Sign the byte buffer using a certificate name and return a Signature object.
		/// </summary>
		///
		/// <param name="buffer">The byte array to be signed.</param>
		/// <param name="certificateName">The certificate name used to get the signing key and which will be put into KeyLocator.</param>
		/// <returns>The Signature.</returns>
		public Signature sign(ByteBuffer buffer, Name certificateName) {
			return identityManager_.signByCertificate(buffer, certificateName);
		}
	
		/// <summary>
		/// Wire encode the Data object, sign it and set its signature.
		/// </summary>
		///
		/// <param name="data"></param>
		/// <param name="identityName"></param>
		/// <param name="wireFormat">A WireFormat object used to encode the input. If omitted, use WireFormat getDefaultWireFormat().</param>
		public void signByIdentity(Data data, Name identityName,
				WireFormat wireFormat) {
			Name signingCertificateName;
	
			if (identityName.size() == 0) {
				Name inferredIdentity = policyManager_.inferSigningIdentity(data
						.getName());
				if (inferredIdentity.size() == 0)
					signingCertificateName = identityManager_
							.getDefaultCertificateName();
				else
					signingCertificateName = identityManager_
							.getDefaultCertificateNameForIdentity(inferredIdentity);
			} else
				signingCertificateName = identityManager_
						.getDefaultCertificateNameForIdentity(identityName);
	
			if (signingCertificateName.size() == 0)
				throw new SecurityException("No qualified certificate name found!");
	
			if (!policyManager_.checkSigningPolicy(data.getName(),
					signingCertificateName))
				throw new SecurityException(
						"Signing Cert name does not comply with signing policy");
	
			identityManager_.signByCertificate(data, signingCertificateName,
					wireFormat);
		}
	
		/// <summary>
		/// Wire encode the Data object, sign it and set its signature.
		/// </summary>
		///
		/// <param name="data">Use the default WireFormat.getDefaultWireFormat().</param>
		/// <param name="identityName"></param>
		public void signByIdentity(Data data, Name identityName) {
			signByIdentity(data, identityName, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Wire encode the Data object, sign it and set its signature.
		/// </summary>
		///
		/// <param name="data">Infer the signing identity from the data packet name. Use the default WireFormat.getDefaultWireFormat().</param>
		public void signByIdentity(Data data) {
			signByIdentity(data, new Name(), net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Sign the byte buffer using an identity name and return a Signature object.
		/// </summary>
		///
		/// <param name="buffer">The byte array to be signed.</param>
		/// <param name="identityName">The identity name.</param>
		/// <returns>The Signature.</returns>
		public Signature signByIdentity(ByteBuffer buffer, Name identityName) {
			Name signingCertificateName = identityManager_
					.getDefaultCertificateNameForIdentity(identityName);
	
			if (signingCertificateName.size() == 0)
				throw new SecurityException("No qualified certificate name found!");
	
			return identityManager_.signByCertificate(buffer,
					signingCertificateName);
		}
	
		/// <summary>
		/// Wire encode the Data object, digest it and set its SignatureInfo to
		/// a DigestSha256.
		/// </summary>
		///
		/// <param name="data"></param>
		/// <param name="wireFormat">A WireFormat object used to encode the input.</param>
		public void signWithSha256(Data data, WireFormat wireFormat) {
			identityManager_.signWithSha256(data, wireFormat);
		}
	
		/// <summary>
		/// Wire encode the Data object, digest it and set its SignatureInfo to
		/// a DigestSha256.
		/// </summary>
		///
		/// <param name="data"></param>
		public void signWithSha256(Data data) {
			signWithSha256(data, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Append a SignatureInfo for DigestSha256 to the Interest name, digest the
		/// name components and append a final name component with the signature bits
		/// (which is the digest).
		/// </summary>
		///
		/// <param name="interest"></param>
		/// <param name="wireFormat">A WireFormat object used to encode the input.</param>
		public void signWithSha256(Interest interest, WireFormat wireFormat) {
			identityManager_.signInterestWithSha256(interest, wireFormat);
		}
	
		/// <summary>
		/// Append a SignatureInfo for DigestSha256 to the Interest name, digest the
		/// name components and append a final name component with the signature bits
		/// (which is the digest).
		/// </summary>
		///
		/// <param name="interest"></param>
		public void signWithSha256(Interest interest) {
			signWithSha256(interest, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		public void verifyData(Data data, OnVerified onVerified,
				OnDataValidationFailed onValidationFailed, int stepCount) {
			ILOG.J2CsMapping.Util.Logging.Logger.getLogger(this.GetType().FullName).log(ILOG.J2CsMapping.Util.Logging.Level.INFO,
					"Enter Verify");
	
			if (policyManager_.requireVerify(data)) {
				ValidationRequest nextStep = policyManager_
						.checkVerificationPolicy(data, stepCount, onVerified,
								onValidationFailed);
				if (nextStep != null) {
					KeyChain.VerifyCallbacks  callbacks = new KeyChain.VerifyCallbacks (this, nextStep,
							nextStep.retry_, onValidationFailed, data);
					try {
						face_.expressInterest(nextStep.interest_, callbacks,
								callbacks);
					} catch (IOException ex) {
						try {
							onValidationFailed.onDataValidationFailed(data,
									"Error calling expressInterest " + ex);
						} catch (Exception exception) {
							logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
									"Error in onDataValidationFailed", exception);
						}
					}
				}
			} else if (policyManager_.skipVerifyAndTrust(data)) {
				try {
					onVerified.onVerified(data);
				} catch (Exception ex_0) {
					logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onVerified", ex_0);
				}
			} else {
				try {
					onValidationFailed
							.onDataValidationFailed(data,
									"The packet has no verify rule but skipVerifyAndTrust is false");
				} catch (Exception ex_1) {
					logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onDataValidationFailed", ex_1);
				}
			}
		}
	
		/// <summary>
		/// Check the signature on the Data object and call either onVerify.onVerify or
		/// onVerifyFailed.onVerifyFailed.
		/// We use callback functions because verify may fetch information to check the
		/// signature.
		/// </summary>
		///
		/// <param name="data">To set the wireEncoding, you can call data.wireDecode.</param>
		/// <param name="onVerified">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onValidationFailed">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		public void verifyData(Data data, OnVerified onVerified,
				OnDataValidationFailed onValidationFailed) {
			verifyData(data, onVerified, onValidationFailed, 0);
		}
	
		/// <summary>
		/// Check the signature on the Data object and call either onVerify.onVerify or
		/// onVerifyFailed.onVerifyFailed.
		/// We use callback functions because verify may fetch information to check the
		/// signature.
		/// </summary>
		///
		/// <param name="data">To set the wireEncoding, you can call data.wireDecode.</param>
		/// <param name="onVerified">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onVerifyFailed">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		public void verifyData(Data data, OnVerified onVerified,
				OnVerifyFailed onVerifyFailed) {
			// Wrap the onVerifyFailed in an OnDataValidationFailed.
			verifyData(data, onVerified, new KeyChain.Anonymous_C1 (onVerifyFailed));
		}
	
		public void verifyInterest(Interest interest,
				OnVerifiedInterest onVerified,
				OnInterestValidationFailed onValidationFailed, int stepCount) {
			ILOG.J2CsMapping.Util.Logging.Logger.getLogger(this.GetType().FullName).log(ILOG.J2CsMapping.Util.Logging.Level.INFO,
					"Enter Verify");
	
			if (policyManager_.requireVerify(interest)) {
				ValidationRequest nextStep = policyManager_
						.checkVerificationPolicy(interest, stepCount, onVerified,
								onValidationFailed);
				if (nextStep != null) {
					KeyChain.VerifyCallbacksForVerifyInterest  callbacks = new KeyChain.VerifyCallbacksForVerifyInterest (
							this, nextStep, nextStep.retry_, onValidationFailed, interest);
					try {
						face_.expressInterest(nextStep.interest_, callbacks,
								callbacks);
					} catch (IOException ex) {
						try {
							onValidationFailed.onInterestValidationFailed(interest,
									"Error calling expressInterest " + ex);
						} catch (Exception exception) {
							logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
									"Error in onInterestValidationFailed",
									exception);
						}
					}
				}
			} else if (policyManager_.skipVerifyAndTrust(interest)) {
				try {
					onVerified.onVerifiedInterest(interest);
				} catch (Exception ex_0) {
					logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onVerifiedInterest", ex_0);
				}
			} else {
				try {
					onValidationFailed
							.onInterestValidationFailed(interest,
									"The packet has no verify rule but skipVerifyAndTrust is false");
				} catch (Exception ex_1) {
					logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
							"Error in onInterestValidationFailed", ex_1);
				}
			}
		}
	
		/// <summary>
		/// Check the signature on the signed interest and call either
		/// onVerify.onVerifiedInterest or onVerifyFailed.onVerifyInterestFailed. We
		/// use callback functions because verify may fetch information to check the
		/// signature.
		/// </summary>
		///
		/// <param name="interest">The interest with the signature to check.</param>
		/// <param name="onVerified">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onValidationFailed">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		public void verifyInterest(Interest interest,
				OnVerifiedInterest onVerified,
				OnInterestValidationFailed onValidationFailed) {
			verifyInterest(interest, onVerified, onValidationFailed, 0);
		}
	
		/// <summary>
		/// Check the signature on the signed interest and call either
		/// onVerify.onVerifiedInterest or onVerifyFailed.onVerifyInterestFailed. We
		/// use callback functions because verify may fetch information to check the
		/// signature.
		/// </summary>
		///
		/// <param name="interest">The interest with the signature to check.</param>
		/// <param name="onVerified">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onVerifyFailed">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		public void verifyInterest(Interest interest,
				OnVerifiedInterest onVerified,
				OnVerifyInterestFailed onVerifyFailed) {
			// Wrap the onVerifyFailed in an OnInterestValidationFailed.
			verifyInterest(interest, onVerified, new KeyChain.Anonymous_C0 (onVerifyFailed));
		}
	
		/// <summary>
		/// Set the Face which will be used to fetch required certificates.
		/// </summary>
		///
		/// <param name="face">The Face object.</param>
		public void setFace(Face face) {
			face_ = face;
		}
	
		/// <summary>
		/// Wire encode the data packet, compute an HmacWithSha256 and update the
		/// signature value.
		/// </summary>
		///
		/// @note This method is an experimental feature. The API may change.
		/// <param name="data">The Data object to be signed. This updates its signature.</param>
		/// <param name="key">The key for the HmacWithSha256.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the data packet.</param>
		public static void signWithHmacWithSha256(Data data, Blob key,
				WireFormat wireFormat) {
			// Encode once to get the signed portion.
			SignedBlob encoding = data.wireEncode(wireFormat);
			byte[] signatureBytes = net.named_data.jndn.util.Common.computeHmacWithSha256(
					key.getImmutableArray(), encoding.signedBuf());
			data.getSignature().setSignature(new Blob(signatureBytes, false));
		}
	
		/// <summary>
		/// Wire encode the data packet, compute an HmacWithSha256 and update the
		/// signature value.
		/// Use the default WireFormat.getDefaultWireFormat().
		/// </summary>
		///
		/// @note This method is an experimental feature. The API may change.
		/// <param name="data">The Data object to be signed. This updates its signature.</param>
		/// <param name="key">The key for the HmacWithSha256.</param>
		public static void signWithHmacWithSha256(Data data, Blob key) {
			signWithHmacWithSha256(data, key, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Compute a new HmacWithSha256 for the data packet and verify it against the
		/// signature value.
		/// </summary>
		///
		/// @note This method is an experimental feature. The API may change.
		/// <param name="data">The Data packet to verify.</param>
		/// <param name="key">The key for the HmacWithSha256.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the data packet.</param>
		/// <returns>True if the signature verifies, otherwise false.</returns>
		public static bool verifyDataWithHmacWithSha256(Data data, Blob key,
				WireFormat wireFormat) {
			// wireEncode returns the cached encoding if available.
			SignedBlob encoding = data.wireEncode(wireFormat);
			byte[] newSignatureBytes = net.named_data.jndn.util.Common.computeHmacWithSha256(
					key.getImmutableArray(), encoding.signedBuf());
	
			return ILOG.J2CsMapping.NIO.ByteBuffer.wrap(newSignatureBytes).equals(
					data.getSignature().getSignature().buf());
		}
	
		/// <summary>
		/// Compute a new HmacWithSha256 for the data packet and verify it against the
		/// signature value.
		/// Use the default WireFormat.getDefaultWireFormat().
		/// </summary>
		///
		/// @note This method is an experimental feature. The API may change.
		/// <param name="data">The Data packet to verify.</param>
		/// <param name="key">The key for the HmacWithSha256.</param>
		/// <returns>True if the signature verifies, otherwise false.</returns>
		public static bool verifyDataWithHmacWithSha256(Data data, Blob key) {
			return verifyDataWithHmacWithSha256(data, key,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		public static readonly RsaKeyParams DEFAULT_KEY_PARAMS = new RsaKeyParams();
	
		public sealed class Anonymous_C1 : OnDataValidationFailed {
			private readonly OnVerifyFailed onVerifyFailed;
	
			public Anonymous_C1(OnVerifyFailed onVerifyFailed_0) {
				this.onVerifyFailed = onVerifyFailed_0;
			}
	
			public void onDataValidationFailed(Data localData, String reason) {
				onVerifyFailed.onVerifyFailed(localData);
			}
		}
	
		public sealed class Anonymous_C0 : OnInterestValidationFailed {
			private readonly OnVerifyInterestFailed onVerifyFailed;
	
			public Anonymous_C0(OnVerifyInterestFailed onVerifyFailed_0) {
				this.onVerifyFailed = onVerifyFailed_0;
			}
	
			public void onInterestValidationFailed(Interest localInterest,
					String reason) {
				onVerifyFailed.onVerifyInterestFailed(localInterest);
			}
		}
	
		/// <summary>
		/// A VerifyCallbacks is used for callbacks from verifyData.
		/// </summary>
		///
			internal class VerifyCallbacks : OnData, OnTimeout {
				private KeyChain outer_KeyChain;
				public VerifyCallbacks(KeyChain chain, ValidationRequest nextStep, int retry,
						OnDataValidationFailed onValidationFailed, Data originalData) {
					outer_KeyChain = chain;
					nextStep_ = nextStep;
					retry_ = retry;
					onValidationFailed_ = onValidationFailed;
					originalData_ = originalData;
				}
		
				public void onData(Interest interest, Data data) {
					try {
						// Try to verify the certificate (data) according to the parameters in
						//   nextStep.
						outer_KeyChain.verifyData(data, nextStep_.onVerified_,
								nextStep_.onValidationFailed_, nextStep_.stepCount_);
					} catch (SecurityException ex) {
						ILOG.J2CsMapping.Util.Logging.Logger.getLogger(typeof(KeyChain).FullName).log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
								null, ex);
					}
				}
		
				public void onTimeout(Interest interest) {
					if (retry_ > 0) {
						// Issue the same expressInterest as in verifyData except decrement
						//   retry.
						KeyChain.VerifyCallbacks  callbacks = new KeyChain.VerifyCallbacks (outer_KeyChain, nextStep_,
								retry_ - 1, onValidationFailed_, originalData_);
						try {
							outer_KeyChain.face_.expressInterest(interest, callbacks, callbacks);
						} catch (IOException ex) {
							try {
								onValidationFailed_.onDataValidationFailed(
										originalData_,
										"Error in expressInterest to retry after timeout for fetching "
												+ interest.getName().toUri() + ": "
												+ ex);
							} catch (Exception exception) {
								net.named_data.jndn.security.KeyChain.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
										"Error in onDataValidationFailed", exception);
							}
						}
					} else {
						try {
							onValidationFailed_.onDataValidationFailed(originalData_,
									"The retry count is zero after timeout for fetching "
											+ interest.getName().toUri());
						} catch (Exception ex_0) {
							net.named_data.jndn.security.KeyChain.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
									"Error in onDataValidationFailed", ex_0);
						}
					}
				}
		
				private readonly ValidationRequest nextStep_;
				private readonly int retry_;
				private readonly OnDataValidationFailed onValidationFailed_;
				private readonly Data originalData_;
			}
	
		/// <summary>
		/// A VerifyCallbacksForVerifyInterest is used for callbacks from verifyInterest.
		/// This is the same as VerifyCallbacks, but we call
		/// onValidationFailed.onInterestValidationFailed(originalInterest, reason) if
		/// we have too many retries.
		/// </summary>
		///
			internal class VerifyCallbacksForVerifyInterest : OnData, OnTimeout {
				private KeyChain outer_KeyChain;
				public VerifyCallbacksForVerifyInterest(KeyChain chain, ValidationRequest nextStep,
						int retry, OnInterestValidationFailed onValidationFailed,
						Interest originalInterest) {
					outer_KeyChain = chain;
					nextStep_ = nextStep;
					retry_ = retry;
					onValidationFailed_ = onValidationFailed;
					originalInterest_ = originalInterest;
				}
		
				public void onData(Interest interest, Data data) {
					try {
						// Try to verify the certificate (data) according to the parameters in
						//   nextStep.
						outer_KeyChain.verifyData(data, nextStep_.onVerified_,
								nextStep_.onValidationFailed_, nextStep_.stepCount_);
					} catch (SecurityException ex) {
						ILOG.J2CsMapping.Util.Logging.Logger.getLogger(typeof(KeyChain).FullName).log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
								null, ex);
					}
				}
		
				public void onTimeout(Interest interest) {
					if (retry_ > 0) {
						// Issue the same expressInterest as in verifyData except decrement
						//   retry.
						KeyChain.VerifyCallbacksForVerifyInterest  callbacks = new KeyChain.VerifyCallbacksForVerifyInterest (
								outer_KeyChain, nextStep_, retry_ - 1, onValidationFailed_,
								originalInterest_);
						try {
							outer_KeyChain.face_.expressInterest(interest, callbacks, callbacks);
						} catch (IOException ex) {
							try {
								onValidationFailed_.onInterestValidationFailed(
										originalInterest_,
										"Error in expressInterest to retry after timeout for fetching "
												+ interest.getName().toUri() + ": "
												+ ex);
							} catch (Exception exception) {
								net.named_data.jndn.security.KeyChain.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
										"Error in onInterestValidationFailed",
										exception);
							}
						}
					} else {
						try {
							onValidationFailed_.onInterestValidationFailed(
									originalInterest_,
									"The retry count is zero after timeout for fetching "
											+ interest.getName().toUri());
						} catch (Exception ex_0) {
							net.named_data.jndn.security.KeyChain.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
									"Error in onInterestValidationFailed", ex_0);
						}
					}
				}
		
				private readonly ValidationRequest nextStep_;
				private readonly int retry_;
				private readonly OnInterestValidationFailed onValidationFailed_;
				private readonly Interest originalInterest_;
			}
	
		/// <summary>
		/// Get the default certificate from the identity storage and return its name.
		/// If there is no default identity or default certificate, then create one.
		/// </summary>
		///
		/// <returns>The default certificate name.</returns>
		private Name prepareDefaultCertificateName() {
			IdentityCertificate signingCertificate = identityManager_
					.getDefaultCertificate();
			if (signingCertificate == null) {
				setDefaultCertificate();
				signingCertificate = identityManager_.getDefaultCertificate();
			}
	
			return signingCertificate.getName();
		}
	
		/// <summary>
		/// Create the default certificate if it is not initialized. If there is no
		/// default identity yet, creating a new tmp-identity.
		/// </summary>
		///
		private void setDefaultCertificate() {
			if (identityManager_.getDefaultCertificate() == null) {
				Name defaultIdentity;
				try {
					defaultIdentity = identityManager_.getDefaultIdentity();
				} catch (SecurityException e) {
					// Create a default identity name.
					ByteBuffer randomComponent = ILOG.J2CsMapping.NIO.ByteBuffer.allocate(4);
					net.named_data.jndn.util.Common.getRandom().nextBytes(randomComponent.array());
					defaultIdentity = new Name().append("tmp-identity").append(
							new Blob(randomComponent, false));
				}
	
				createIdentityAndCertificate(defaultIdentity);
				identityManager_.setDefaultIdentity(defaultIdentity);
			}
		}
	
		private readonly IdentityManager identityManager_;
		private readonly PolicyManager policyManager_;
		internal Face face_;
		static internal readonly Logger logger_ = ILOG.J2CsMapping.Util.Logging.Logger.getLogger(typeof(KeyChain).FullName);
	}
}
