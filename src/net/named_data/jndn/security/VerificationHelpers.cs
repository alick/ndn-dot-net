// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security {
	
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.spec;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.security.certificate;
	using net.named_data.jndn.security.v2;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// The VerificationHelpers class has static methods to verify signatures and
	/// digests.
	/// </summary>
	///
	public class VerificationHelpers {
		/// <summary>
		/// Verify the buffer against the signature using the public key.
		/// </summary>
		///
		/// <param name="buffer">The input buffer to verify.</param>
		/// <param name="signature">The signature bytes.</param>
		/// <param name="publicKey">The object containing the public key.</param>
		/// <param name="digestAlgorithm">The digest algorithm.</param>
		/// <returns>True if verification succeeds, false if verification fails.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type ordigestAlgorithm.</exception>
		public static bool verifySignature(ByteBuffer buffer, byte[] signature,
				PublicKey publicKey, DigestAlgorithm digestAlgorithm) {
			if (digestAlgorithm == net.named_data.jndn.security.DigestAlgorithm.SHA256) {
				if (publicKey.getKeyType() == net.named_data.jndn.security.KeyType.RSA) {
					try {
						KeyFactory keyFactory = System.KeyFactory.getInstance("RSA");
						System.SecurityPublicKey securityPublicKey = keyFactory
								.generatePublic(new X509EncodedKeySpec(publicKey
										.getKeyDer().getImmutableArray()));
	
						System.SecuritySignature rsaSignature = System.SecuritySignature
								.getInstance("SHA256withRSA");
						rsaSignature.initVerify(securityPublicKey);
						rsaSignature.update(buffer);
						return rsaSignature.verify(signature);
					} catch (Exception ex) {
						return false;
					}
				} else if (publicKey.getKeyType() == net.named_data.jndn.security.KeyType.ECDSA) {
					try {
						KeyFactory keyFactory_0 = System.KeyFactory.getInstance("EC");
						System.SecurityPublicKey securityPublicKey_1 = keyFactory_0
								.generatePublic(new X509EncodedKeySpec(publicKey
										.getKeyDer().getImmutableArray()));
	
						System.SecuritySignature ecdsaSignature = System.SecuritySignature
								.getInstance("SHA256withECDSA");
						ecdsaSignature.initVerify(securityPublicKey_1);
						ecdsaSignature.update(buffer);
						return ecdsaSignature.verify(signature);
					} catch (Exception ex_2) {
						return false;
					}
				} else
					throw new ArgumentException(
							"verifySignature: Invalid key type");
			} else
				throw new ArgumentException(
						"verifySignature: Invalid digest algorithm");
		}
	
		/// <summary>
		/// Verify the buffer against the signature using the public key and
		/// digest algorithm SHA256.
		/// </summary>
		///
		/// <param name="buffer">The input buffer to verify.</param>
		/// <param name="signature">The signature bytes.</param>
		/// <param name="publicKey">The object containing the public key.</param>
		/// <returns>True if verification succeeds, false if verification fails.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type.</exception>
		public static bool verifySignature(ByteBuffer buffer, byte[] signature,
				PublicKey publicKey) {
			return verifySignature(buffer, signature, publicKey,
					net.named_data.jndn.security.DigestAlgorithm.SHA256);
		}
	
		/// <summary>
		/// Verify the buffer against the signature using the public key.
		/// </summary>
		///
		/// <param name="buffer">The input buffer to verify.</param>
		/// <param name="signature">The signature bytes.</param>
		/// <param name="publicKey">The object containing the public key.</param>
		/// <param name="digestAlgorithm">The digest algorithm.</param>
		/// <returns>True if verification succeeds, false if verification fails.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type ordigestAlgorithm.</exception>
		public static bool verifySignature(ByteBuffer buffer, Blob signature,
				PublicKey publicKey, DigestAlgorithm digestAlgorithm) {
			return verifySignature(buffer, signature.getImmutableArray(),
					publicKey, digestAlgorithm);
		}
	
		/// <summary>
		/// Verify the buffer against the signature using the public key and
		/// digest algorithm SHA256.
		/// </summary>
		///
		/// <param name="buffer">The input buffer to verify.</param>
		/// <param name="signature">The signature bytes.</param>
		/// <param name="publicKey">The object containing the public key.</param>
		/// <returns>True if verification succeeds, false if verification fails.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type.</exception>
	
		public static bool verifySignature(ByteBuffer buffer, Blob signature,
				PublicKey publicKey) {
			return verifySignature(buffer, signature.getImmutableArray(),
					publicKey, net.named_data.jndn.security.DigestAlgorithm.SHA256);
		}
	
		/// <summary>
		/// Verify the buffer against the signature using the public key.
		/// </summary>
		///
		/// <param name="buffer">The input buffer to verify.</param>
		/// <param name="signature">The signature bytes.</param>
		/// <param name="publicKey">The object containing the public key.</param>
		/// <param name="digestAlgorithm">The digest algorithm.</param>
		/// <returns>True if verification succeeds, false if verification fails.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type ordigestAlgorithm.</exception>
		public static bool verifySignature(Blob buffer, Blob signature,
				PublicKey publicKey, DigestAlgorithm digestAlgorithm) {
			return verifySignature(buffer.buf(), signature.getImmutableArray(),
					publicKey, digestAlgorithm);
		}
	
		/// <summary>
		/// Verify the buffer against the signature using the public key and
		/// digest algorithm SHA256.
		/// </summary>
		///
		/// <param name="buffer">The input buffer to verify.</param>
		/// <param name="signature">The signature bytes.</param>
		/// <param name="publicKey">The object containing the public key.</param>
		/// <returns>True if verification succeeds, false if verification fails.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type.</exception>
		public static bool verifySignature(Blob buffer, Blob signature,
				PublicKey publicKey) {
			return verifySignature(buffer.buf(), signature.getImmutableArray(),
					publicKey, net.named_data.jndn.security.DigestAlgorithm.SHA256);
		}
	
		/// <summary>
		/// Verify the buffer against the signature using the encoded public key.
		/// If the public key can't be decoded, this returns false instead of throwing
		/// a decoding exception. If you want to get a decoding exception then use
		/// the PublicKey constructor to decode and call verifySignature with the
		/// PublicKey object.
		/// </summary>
		///
		/// <param name="buffer">The input buffer to verify.</param>
		/// <param name="signature">The signature bytes.</param>
		/// <param name="publicKeyDer">The DER-encoded public key.</param>
		/// <param name="digestAlgorithm">The digest algorithm.</param>
		/// <returns>True if verification succeeds, false if verification fails or for
		/// an error decoding the public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid keyType or digestAlgorithm.</exception>
		public static bool verifySignature(ByteBuffer buffer, byte[] signature,
				Blob publicKeyDer, DigestAlgorithm digestAlgorithm) {
			try {
				return verifySignature(buffer, signature, new PublicKey(
						publicKeyDer), digestAlgorithm);
			} catch (UnrecognizedKeyFormatException ex) {
				return false;
			}
		}
	
		/// <summary>
		/// Verify the buffer against the signature using the encoded public key and
		/// digest algorithm SHA256.
		/// If the public key can't be decoded, this returns false instead of throwing
		/// a decoding exception. If you want to get a decoding exception then use
		/// the PublicKey constructor to decode and call verifySignature with the
		/// PublicKey object.
		/// </summary>
		///
		/// <param name="buffer">The input buffer to verify.</param>
		/// <param name="signature">The signature bytes.</param>
		/// <param name="publicKeyDer">The DER-encoded public key.</param>
		/// <returns>True if verification succeeds, false if verification fails or for
		/// an error decoding the public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid keyType.</exception>
		public static bool verifySignature(ByteBuffer buffer, byte[] signature,
				Blob publicKeyDer) {
			return verifySignature(buffer, signature, publicKeyDer,
					net.named_data.jndn.security.DigestAlgorithm.SHA256);
		}
	
		/// <summary>
		/// Verify the buffer against the signature using the encoded public key.
		/// If the public key can't be decoded, this returns false instead of throwing
		/// a decoding exception. If you want to get a decoding exception then use
		/// the PublicKey constructor to decode and call verifySignature with the
		/// PublicKey object.
		/// </summary>
		///
		/// <param name="buffer">The input buffer to verify.</param>
		/// <param name="signature">The signature bytes.</param>
		/// <param name="publicKeyDer">The DER-encoded public key.</param>
		/// <param name="digestAlgorithm">The digest algorithm.</param>
		/// <returns>True if verification succeeds, false if verification fails or for
		/// an error decoding the public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid keyType or digestAlgorithm.</exception>
		public static bool verifySignature(ByteBuffer buffer, Blob signature,
				Blob publicKeyDer, DigestAlgorithm digestAlgorithm) {
			return verifySignature(buffer, signature.getImmutableArray(),
					publicKeyDer, digestAlgorithm);
		}
	
		/// <summary>
		/// Verify the buffer against the signature using the encoded public key and
		/// digest algorithm SHA256.
		/// If the public key can't be decoded, this returns false instead of throwing
		/// a decoding exception. If you want to get a decoding exception then use
		/// the PublicKey constructor to decode and call verifySignature with the
		/// PublicKey object.
		/// </summary>
		///
		/// <param name="buffer">The input buffer to verify.</param>
		/// <param name="signature">The signature bytes.</param>
		/// <param name="publicKeyDer">The DER-encoded public key.</param>
		/// <returns>True if verification succeeds, false if verification fails or for
		/// an error decoding the public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid keyType.</exception>
		public static bool verifySignature(ByteBuffer buffer, Blob signature,
				Blob publicKeyDer) {
			return verifySignature(buffer, signature.getImmutableArray(),
					publicKeyDer, net.named_data.jndn.security.DigestAlgorithm.SHA256);
		}
	
		/// <summary>
		/// Verify the buffer against the signature using the encoded public key.
		/// If the public key can't be decoded, this returns false instead of throwing
		/// a decoding exception. If you want to get a decoding exception then use
		/// the PublicKey constructor to decode and call verifySignature with the
		/// PublicKey object.
		/// </summary>
		///
		/// <param name="buffer">The input buffer to verify.</param>
		/// <param name="signature">The signature bytes.</param>
		/// <param name="publicKeyDer">The DER-encoded public key.</param>
		/// <param name="digestAlgorithm">The digest algorithm.</param>
		/// <returns>True if verification succeeds, false if verification fails or for
		/// an error decoding the public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid keyType or digestAlgorithm.</exception>
		public static bool verifySignature(Blob buffer, Blob signature,
				Blob publicKeyDer, DigestAlgorithm digestAlgorithm) {
			return verifySignature(buffer.buf(), signature.getImmutableArray(),
					publicKeyDer, digestAlgorithm);
		}
	
		/// <summary>
		/// Verify the buffer against the signature using the encoded public key and
		/// digest algorithm SHA256.
		/// If the public key can't be decoded, this returns false instead of throwing
		/// a decoding exception. If you want to get a decoding exception then use
		/// the PublicKey constructor to decode and call verifySignature with the
		/// PublicKey object.
		/// </summary>
		///
		/// <param name="buffer">The input buffer to verify.</param>
		/// <param name="signature">The signature bytes.</param>
		/// <param name="publicKeyDer">The DER-encoded public key.</param>
		/// <returns>True if verification succeeds, false if verification fails or for
		/// an error decoding the public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid keyType.</exception>
		public static bool verifySignature(Blob buffer, Blob signature,
				Blob publicKeyDer) {
			return verifySignature(buffer.buf(), signature.getImmutableArray(),
					publicKeyDer, net.named_data.jndn.security.DigestAlgorithm.SHA256);
		}
	
		/// <summary>
		/// Verify the Data packet using the public key. This does not check the
		/// type of public key or digest algorithm against the type of SignatureInfo in
		/// the Data packet such as Sha256WithRsaSignature.
		/// </summary>
		///
		/// <param name="data">The Data packet to verify.</param>
		/// <param name="publicKey">The object containing the public key.</param>
		/// <param name="digestAlgorithm">The digest algorithm.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the Data packet.</param>
		/// <returns>True if verification succeeds, false if verification fails.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type ordigestAlgorithm.</exception>
		public static bool verifyDataSignature(Data data, PublicKey publicKey,
				DigestAlgorithm digestAlgorithm, WireFormat wireFormat) {
			SignedBlob encoding = data.wireEncode(wireFormat);
			return verifySignature(encoding.signedBuf(), data.getSignature()
					.getSignature(), publicKey, digestAlgorithm);
		}
	
		/// <summary>
		/// Verify the Data packet using the public key. This does not check the
		/// type of public key or digest algorithm against the type of SignatureInfo in
		/// the Data packet such as Sha256WithRsaSignature.
		/// Encode the Data packet with the default wire format.
		/// </summary>
		///
		/// <param name="data">The Data packet to verify.</param>
		/// <param name="publicKey">The object containing the public key.</param>
		/// <param name="digestAlgorithm">The digest algorithm.</param>
		/// <returns>True if verification succeeds, false if verification fails.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type ordigestAlgorithm.</exception>
		public static bool verifyDataSignature(Data data, PublicKey publicKey,
				DigestAlgorithm digestAlgorithm) {
			return verifyDataSignature(data, publicKey, digestAlgorithm,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Verify the Data packet using the public key and digest algorithm SHA256.
		/// This does not check the type of public key or digest algorithm against the
		/// type of SignatureInfo in the Data packet such as Sha256WithRsaSignature.
		/// Encode the Data packet with the default wire format.
		/// </summary>
		///
		/// <param name="data">The Data packet to verify.</param>
		/// <param name="publicKey">The object containing the public key.</param>
		/// <returns>True if verification succeeds, false if verification fails.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type.</exception>
		public static bool verifyDataSignature(Data data, PublicKey publicKey) {
			return verifyDataSignature(data, publicKey, net.named_data.jndn.security.DigestAlgorithm.SHA256,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Verify the Data packet using the public key. This does not check the
		/// type of public key or digest algorithm against the type of SignatureInfo in
		/// the Data packet such as Sha256WithRsaSignature.
		/// If the public key can't be decoded, this returns false instead of throwing
		/// a decoding exception. If you want to get a decoding exception then use
		/// the PublicKey constructor to decode and call verifyDataSignature with the
		/// PublicKey object.
		/// </summary>
		///
		/// <param name="data">The Data packet to verify.</param>
		/// <param name="publicKeyDer">The DER-encoded public key.</param>
		/// <param name="digestAlgorithm">The digest algorithm.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the Data packet.</param>
		/// <returns>True if verification succeeds, false if verification fails or for
		/// an error decoding the public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type ordigestAlgorithm.</exception>
		public static bool verifyDataSignature(Data data, Blob publicKeyDer,
				DigestAlgorithm digestAlgorithm, WireFormat wireFormat) {
			try {
				return verifyDataSignature(data, new PublicKey(publicKeyDer),
						digestAlgorithm);
			} catch (UnrecognizedKeyFormatException ex) {
				return false;
			}
		}
	
		/// <summary>
		/// Verify the Data packet using the public key. This does not check the
		/// type of public key or digest algorithm against the type of SignatureInfo in
		/// the Data packet such as Sha256WithRsaSignature.
		/// If the public key can't be decoded, this returns false instead of throwing
		/// a decoding exception. If you want to get a decoding exception then use
		/// the PublicKey constructor to decode and call verifyDataSignature with the
		/// PublicKey object.
		/// Encode the Data packet with the default wire format.
		/// </summary>
		///
		/// <param name="data">The Data packet to verify.</param>
		/// <param name="publicKeyDer">The DER-encoded public key.</param>
		/// <param name="digestAlgorithm">The digest algorithm.</param>
		/// <returns>True if verification succeeds, false if verification fails or for
		/// an error decoding the public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type ordigestAlgorithm.</exception>
		public static bool verifyDataSignature(Data data, Blob publicKeyDer,
				DigestAlgorithm digestAlgorithm) {
			return verifyDataSignature(data, publicKeyDer, digestAlgorithm,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Verify the Data packet using the public key and digest algorithm SHA256.
		/// This does not check the type of public key or digest algorithm against the
		/// type of SignatureInfo in the Data packet such as Sha256WithRsaSignature.
		/// If the public key can't be decoded, this returns false instead of throwing
		/// a decoding exception. If you want to get a decoding exception then use
		/// the PublicKey constructor to decode and call verifyDataSignature with the
		/// PublicKey object.
		/// Encode the Data packet with the default wire format.
		/// </summary>
		///
		/// <param name="data">The Data packet to verify.</param>
		/// <param name="publicKeyDer">The DER-encoded public key.</param>
		/// <returns>True if verification succeeds, false if verification fails or for
		/// an error decoding the public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type ordigestAlgorithm.</exception>
		public static bool verifyDataSignature(Data data, Blob publicKeyDer) {
			return verifyDataSignature(data, publicKeyDer, net.named_data.jndn.security.DigestAlgorithm.SHA256,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Verify the Data packet using the public key in the certificate. This does
		/// not check the type of public key or digest algorithm against the type of
		/// SignatureInfo in the Data packet such as Sha256WithRsaSignature.
		/// </summary>
		///
		/// <param name="data">The Data packet to verify.</param>
		/// <param name="certificate">The certificate containing the public key.</param>
		/// <param name="digestAlgorithm">The digest algorithm.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the Data packet.</param>
		/// <returns>True if verification succeeds, false if verification fails or for
		/// an error decoding the public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type ordigestAlgorithm.</exception>
		public static bool verifyDataSignature(Data data,
				CertificateV2 certificate, DigestAlgorithm digestAlgorithm,
				WireFormat wireFormat) {
			try {
				return verifyDataSignature(data, certificate.getPublicKey(),
						digestAlgorithm, wireFormat);
			} catch (CertificateV2.Error ex) {
				return false;
			}
		}
	
		/// <summary>
		/// Verify the Data packet using the public key in the certificate. This does
		/// not check the type of public key or digest algorithm against the type of
		/// SignatureInfo in the Data packet such as Sha256WithRsaSignature.
		/// Encode the Data packet with the default wire format.
		/// </summary>
		///
		/// <param name="data">The Data packet to verify.</param>
		/// <param name="certificate">The certificate containing the public key.</param>
		/// <param name="digestAlgorithm">The digest algorithm.</param>
		/// <returns>True if verification succeeds, false if verification fails or for
		/// an error decoding the public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type ordigestAlgorithm.</exception>
		public static bool verifyDataSignature(Data data,
				CertificateV2 certificate, DigestAlgorithm digestAlgorithm) {
			return verifyDataSignature(data, certificate, digestAlgorithm,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Verify the Data packet using the public key in the certificate and digest
		/// algorithm SHA256. This does not check the type of public key or digest
		/// algorithm against the type of SignatureInfo in the Data packet such as
		/// Sha256WithRsaSignature.
		/// Encode the Data packet with the default wire format.
		/// </summary>
		///
		/// <param name="data">The Data packet to verify.</param>
		/// <param name="certificate">The certificate containing the public key.</param>
		/// <returns>True if verification succeeds, false if verification fails or for
		/// an error decoding the public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type.</exception>
		public static bool verifyDataSignature(Data data,
				CertificateV2 certificate) {
			return verifyDataSignature(data, certificate, net.named_data.jndn.security.DigestAlgorithm.SHA256,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Verify the Interest packet using the public key, where the last two name
		/// components are the SignatureInfo and signature bytes. This does not check
		/// the type of public key or digest algorithm against the type of
		/// SignatureInfo such as Sha256WithRsaSignature.
		/// </summary>
		///
		/// <param name="interest">The Interest packet to verify.</param>
		/// <param name="publicKey">The object containing the public key.</param>
		/// <param name="digestAlgorithm">The digest algorithm.</param>
		/// <param name="wireFormat">A WireFormat object used to decode the Interest packet.</param>
		/// <returns>True if verification succeeds, false if verification fails or
		/// cannot decode the Interest.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type ordigestAlgorithm.</exception>
		public static bool verifyInterestSignature(Interest interest,
				PublicKey publicKey, DigestAlgorithm digestAlgorithm,
				WireFormat wireFormat) {
			Signature signature = extractSignature(interest, wireFormat);
			if (signature == null)
				return false;
	
			SignedBlob encoding = interest.wireEncode(wireFormat);
	
			return verifySignature(encoding.signedBuf(), signature.getSignature(),
					publicKey, digestAlgorithm);
		}
	
		/// <summary>
		/// Verify the Interest packet using the public key, where the last two name
		/// components are the SignatureInfo and signature bytes. This does not check
		/// the type of public key or digest algorithm against the type of
		/// SignatureInfo such as Sha256WithRsaSignature.
		/// Decode the Interest packet with the default wire format.
		/// </summary>
		///
		/// <param name="interest">The Interest packet to verify.</param>
		/// <param name="publicKey">The object containing the public key.</param>
		/// <param name="digestAlgorithm">The digest algorithm.</param>
		/// <returns>True if verification succeeds, false if verification fails or
		/// cannot decode the Interest.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type ordigestAlgorithm.</exception>
		public static bool verifyInterestSignature(Interest interest,
				PublicKey publicKey, DigestAlgorithm digestAlgorithm) {
			return verifyInterestSignature(interest, publicKey, digestAlgorithm,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Verify the Interest packet using the public key and digest algorithm SHA256,
		/// where the last two name components are the SignatureInfo and signature
		/// bytes. This does not check the type of public key or digest algorithm
		/// against the type of SignatureInfo such as Sha256WithRsaSignature.
		/// Decode the Interest packet with the default wire format.
		/// </summary>
		///
		/// <param name="interest">The Interest packet to verify.</param>
		/// <param name="publicKey">The object containing the public key.</param>
		/// <returns>True if verification succeeds, false if verification fails or
		/// cannot decode the Interest.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type.</exception>
		public static bool verifyInterestSignature(Interest interest,
				PublicKey publicKey) {
			return verifyInterestSignature(interest, publicKey,
					net.named_data.jndn.security.DigestAlgorithm.SHA256, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Verify the Interest packet using the public key, where the last two name
		/// components are the SignatureInfo and signature bytes. This does not check
		/// the type of public key or digest algorithm against the type of
		/// SignatureInfo such as Sha256WithRsaSignature.
		/// If the public key can't be decoded, this returns false instead of throwing
		/// a decoding exception. If you want to get a decoding exception then use
		/// the PublicKey constructor to decode and call verifyInterestSignature with
		/// the PublicKey object.
		/// </summary>
		///
		/// <param name="interest">The Interest packet to verify.</param>
		/// <param name="publicKeyDer">The DER-encoded public key.</param>
		/// <param name="digestAlgorithm">The digest algorithm.</param>
		/// <param name="wireFormat">A WireFormat object used to decode the Interest packet.</param>
		/// <returns>True if verification succeeds, false if verification fails or
		/// cannot decode the Interest or public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type ordigestAlgorithm.</exception>
		public static bool verifyInterestSignature(Interest interest,
				Blob publicKeyDer, DigestAlgorithm digestAlgorithm,
				WireFormat wireFormat) {
			try {
				return verifyInterestSignature(interest,
						new PublicKey(publicKeyDer), digestAlgorithm);
			} catch (UnrecognizedKeyFormatException ex) {
				return false;
			}
		}
	
		/// <summary>
		/// Verify the Interest packet using the public key, where the last two name
		/// components are the SignatureInfo and signature bytes. This does not check
		/// the type of public key or digest algorithm against the type of
		/// SignatureInfo such as Sha256WithRsaSignature.
		/// If the public key can't be decoded, this returns false instead of throwing
		/// a decoding exception. If you want to get a decoding exception then use
		/// the PublicKey constructor to decode and call verifyInterestSignature with
		/// the PublicKey object.
		/// Decode the Interest packet with the default wire format.
		/// </summary>
		///
		/// <param name="interest">The Interest packet to verify.</param>
		/// <param name="publicKeyDer">The DER-encoded public key.</param>
		/// <param name="digestAlgorithm">The digest algorithm.</param>
		/// <returns>True if verification succeeds, false if verification fails or
		/// cannot decode the Interest or public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type ordigestAlgorithm.</exception>
		public static bool verifyInterestSignature(Interest interest,
				Blob publicKeyDer, DigestAlgorithm digestAlgorithm) {
			return verifyInterestSignature(interest, publicKeyDer, digestAlgorithm,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Verify the Interest packet using the public key and digest algorithm SHA256,
		/// where the last two name components are the SignatureInfo and signature
		/// bytes. This does not check the type of public key or digest algorithm
		/// against the type of SignatureInfo such as Sha256WithRsaSignature.
		/// If the public key can't be decoded, this returns false instead of throwing
		/// a decoding exception. If you want to get a decoding exception then use
		/// the PublicKey constructor to decode and call verifyInterestSignature with
		/// the PublicKey object.
		/// Decode the Interest packet with the default wire format.
		/// </summary>
		///
		/// <param name="interest">The Interest packet to verify.</param>
		/// <param name="publicKeyDer">The DER-encoded public key.</param>
		/// <returns>True if verification succeeds, false if verification fails or
		/// cannot decode the Interest or public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type.</exception>
		public static bool verifyInterestSignature(Interest interest,
				Blob publicKeyDer) {
			return verifyInterestSignature(interest, publicKeyDer,
					net.named_data.jndn.security.DigestAlgorithm.SHA256, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Verify the Interest packet using the public key in the certificate, where
		/// the last two name components are the SignatureInfo and signature bytes.
		/// This does not check the type of public key or digest algorithm against the
		/// type of SignatureInfo such as Sha256WithRsaSignature.
		/// </summary>
		///
		/// <param name="interest">The Interest packet to verify.</param>
		/// <param name="certificate">The certificate containing the public key.</param>
		/// <param name="digestAlgorithm">(optional) The digest algorithm. If omitted, use SHA256.</param>
		/// <param name="wireFormat"></param>
		/// <returns>True if verification succeeds, false if verification fails or
		/// cannot decode the Interest or public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type ordigestAlgorithm.</exception>
		public static bool verifyInterestSignature(Interest interest,
				CertificateV2 certificate, DigestAlgorithm digestAlgorithm,
				WireFormat wireFormat) {
			try {
				return verifyInterestSignature(interest,
						certificate.getPublicKey(), digestAlgorithm, wireFormat);
			} catch (CertificateV2.Error ex) {
				return false;
			}
		}
	
		/// <summary>
		/// Verify the Interest packet using the public key in the certificate, where
		/// the last two name components are the SignatureInfo and signature bytes.
		/// This does not check the type of public key or digest algorithm against the
		/// type of SignatureInfo such as Sha256WithRsaSignature.
		/// Decode the Interest packet with the default wire format.
		/// </summary>
		///
		/// <param name="interest">The Interest packet to verify.</param>
		/// <param name="certificate">The certificate containing the public key.</param>
		/// <param name="digestAlgorithm">(optional) The digest algorithm. If omitted, use SHA256.</param>
		/// <returns>True if verification succeeds, false if verification fails or
		/// cannot decode the Interest or public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type ordigestAlgorithm.</exception>
		public static bool verifyInterestSignature(Interest interest,
				CertificateV2 certificate, DigestAlgorithm digestAlgorithm) {
			return verifyInterestSignature(interest, certificate, digestAlgorithm,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Verify the Interest packet using the public key and digest algorithm SHA256
		/// in the certificate, where the last two name components are the
		/// SignatureInfo and signature bytes.
		/// This does not check the type of public key or digest algorithm against the
		/// type of SignatureInfo such as Sha256WithRsaSignature.
		/// Decode the Interest packet with the default wire format.
		/// </summary>
		///
		/// <param name="interest">The Interest packet to verify.</param>
		/// <param name="certificate">The certificate containing the public key.</param>
		/// <returns>True if verification succeeds, false if verification fails or
		/// cannot decode the Interest or public key.</returns>
		/// <exception cref="System.ArgumentException">for an invalid public key type.</exception>
		public static bool verifyInterestSignature(Interest interest,
				CertificateV2 certificate) {
			return verifyInterestSignature(interest, certificate,
					net.named_data.jndn.security.DigestAlgorithm.SHA256, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/////////////////////////////////////////////////////////////
	
		/// <summary>
		/// Verify the buffer against the digest using the digest algorithm.
		/// </summary>
		///
		/// <param name="buffer">The input buffer to verify.</param>
		/// <param name="digest">The digest bytes.</param>
		/// <param name="digestAlgorithm">The digest algorithm, such as DIGEST_ALGORITHM_SHA256.</param>
		/// <returns>True if verification succeeds, false if verification fails.</returns>
		/// <exception cref="System.ArgumentException">for an invalid digestAlgorithm.</exception>
		public static bool verifyDigest(ByteBuffer buffer, byte[] digest,
				DigestAlgorithm digestAlgorithm) {
			if (digestAlgorithm == net.named_data.jndn.security.DigestAlgorithm.SHA256) {
				byte[] bufferDigest = net.named_data.jndn.util.Common.digestSha256(buffer);
				return ILOG.J2CsMapping.Collections.Arrays.Equals(bufferDigest,digest);
			} else
				throw new ArgumentException(
						"verifySignature: Invalid digest algorithm");
		}
	
		/// <summary>
		/// Verify the buffer against the digest using the digest algorithm.
		/// </summary>
		///
		/// <param name="buffer">The input buffer to verify.</param>
		/// <param name="digest">The digest bytes.</param>
		/// <param name="digestAlgorithm">The digest algorithm, such as DIGEST_ALGORITHM_SHA256.</param>
		/// <returns>True if verification succeeds, false if verification fails.</returns>
		/// <exception cref="System.ArgumentException">for an invalid digestAlgorithm.</exception>
		public static bool verifyDigest(ByteBuffer buffer, Blob digest,
				DigestAlgorithm digestAlgorithm) {
			return verifyDigest(buffer, digest.getImmutableArray(), digestAlgorithm);
		}
	
		/// <summary>
		/// Verify the buffer against the digest using the digest algorithm.
		/// </summary>
		///
		/// <param name="buffer">The input buffer to verify.</param>
		/// <param name="digest">The digest bytes.</param>
		/// <param name="digestAlgorithm">The digest algorithm, such as DIGEST_ALGORITHM_SHA256.</param>
		/// <returns>True if verification succeeds, false if verification fails.</returns>
		/// <exception cref="System.ArgumentException">for an invalid digestAlgorithm.</exception>
		public static bool verifyDigest(Blob buffer, Blob digest,
				DigestAlgorithm digestAlgorithm) {
			return verifyDigest(buffer.buf(), digest.getImmutableArray(),
					digestAlgorithm);
		}
	
		/// <summary>
		/// Verify the Data packet using the digest algorithm. This does not check the
		/// digest algorithm against the type of SignatureInfo in the Data packet such
		/// as DigestSha256Signature.
		/// </summary>
		///
		/// <param name="data">The Data packet to verify.</param>
		/// <param name="digestAlgorithm">The digest algorithm, such as DIGEST_ALGORITHM_SHA256.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the Data packet.</param>
		/// <returns>True if verification succeeds, false if verification fails.</returns>
		/// <exception cref="System.ArgumentException">for an invalid digestAlgorithm.</exception>
		public static bool verifyDataDigest(Data data,
				DigestAlgorithm digestAlgorithm, WireFormat wireFormat) {
			SignedBlob encoding = data.wireEncode(wireFormat);
			return verifyDigest(encoding.signedBuf(), data.getSignature()
					.getSignature(), digestAlgorithm);
		}
	
		/// <summary>
		/// Verify the Data packet using the digest algorithm. This does not check the
		/// digest algorithm against the type of SignatureInfo in the Data packet such
		/// as DigestSha256Signature.
		/// Encode the Data packet with the default wire format.
		/// </summary>
		///
		/// <param name="data">The Data packet to verify.</param>
		/// <param name="digestAlgorithm">The digest algorithm, such as DIGEST_ALGORITHM_SHA256.</param>
		/// <returns>True if verification succeeds, false if verification fails.</returns>
		/// <exception cref="System.ArgumentException">for an invalid digestAlgorithm.</exception>
		public static bool verifyDataDigest(Data data,
				DigestAlgorithm digestAlgorithm) {
			return verifyDataDigest(data, digestAlgorithm,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Verify the Interest packet using the digest algorithm, where the last two
		/// name components are the SignatureInfo and signature bytes. This does not
		/// check the digest algorithm against the type of SignatureInfo such as
		/// DigestSha256Signature.
		/// </summary>
		///
		/// <param name="interest">The Interest packet to verify.</param>
		/// <param name="digestAlgorithm">The digest algorithm, such as DIGEST_ALGORITHM_SHA256.</param>
		/// <param name="wireFormat">A WireFormat object used to decode the Interest packet.</param>
		/// <returns>True if verification succeeds, false if verification fails or
		/// cannot decode the Interest.</returns>
		/// <exception cref="System.ArgumentException">for an invalid digestAlgorithm.</exception>
		public static bool verifyInterestDigest(Interest interest,
				DigestAlgorithm digestAlgorithm, WireFormat wireFormat) {
			Signature signature = extractSignature(interest, wireFormat);
			if (signature == null)
				return false;
	
			SignedBlob encoding = interest.wireEncode(wireFormat);
			return verifyDigest(encoding.signedBuf(), signature.getSignature(),
					digestAlgorithm);
		}
	
		/// <summary>
		/// Verify the Interest packet using the digest algorithm, where the last two
		/// name components are the SignatureInfo and signature bytes. This does not
		/// check the digest algorithm against the type of SignatureInfo such as
		/// DigestSha256Signature.
		/// Decode the Interest packet with the default wire format.
		/// </summary>
		///
		/// <param name="interest">The Interest packet to verify.</param>
		/// <param name="digestAlgorithm">The digest algorithm, such as DIGEST_ALGORITHM_SHA256.</param>
		/// <returns>True if verification succeeds, false if verification fails or
		/// cannot decode the Interest.</returns>
		/// <exception cref="System.ArgumentException">for an invalid digestAlgorithm.</exception>
		public static bool verifyInterestDigest(Interest interest,
				DigestAlgorithm digestAlgorithm) {
			return verifyInterestDigest(interest, digestAlgorithm,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Extract the signature information from the interest name.
		/// </summary>
		///
		/// <param name="interest">The interest whose signature is needed.</param>
		/// <param name="wireFormat"></param>
		/// <returns>The Signature object, or null if can't decode.</returns>
		private static Signature extractSignature(Interest interest,
				WireFormat wireFormat) {
			if (interest.getName().size() < 2)
				return null;
	
			try {
				return wireFormat.decodeSignatureInfoAndValue(interest.getName()
						.get(-2).getValue().buf(), interest.getName().get(-1)
						.getValue().buf(), false);
			} catch (EncodingException ex) {
				return null;
			}
		}
	}
}
