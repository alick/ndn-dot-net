// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017-2018 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security.tpm {
	
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.spec;
	using javax.crypto;
	using javax.crypto.spec;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.encoding.der;
	using net.named_data.jndn.encrypt.algo;
	using net.named_data.jndn.security;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// A TpmPrivateKey holds an in-memory private key and provides cryptographic
	/// operations such as for signing by the in-memory TPM.
	/// </summary>
	///
	public class TpmPrivateKey {
		/// <summary>
		/// A TpmPrivateKey.Error extends Exception and represents an error in private
		/// key processing.
		/// Note that even though this is called "Error" to be consistent with the
		/// other libraries, it extends the Java Exception class, not Error.
		/// </summary>
		///
		[Serializable]
		public class Error : Exception {
			public Error(String message) : base(message) {
			}
		}
	
		/// <summary>
		/// Create an uninitialized TpmPrivateKey. You must call a load method to
		/// initialize it, such as loadPkcs1.
		/// </summary>
		///
		public TpmPrivateKey() {
			this.keyType_ =  default(KeyType)/* was: null */;
		}
	
		/// <summary>
		/// Load the unencrypted private key from a buffer with the PKCS #1 encoding.
		/// This replaces any existing private key in this object.
		/// </summary>
		///
		/// <param name="encoding">The byte buffer with the private key encoding.</param>
		/// <param name="keyType"></param>
		/// <exception cref="TpmPrivateKey.Error">for errors decoding the key.</exception>
		public void loadPkcs1(ByteBuffer encoding, KeyType keyType) {
			if (keyType == null) {
				// Try to determine the key type.
				try {
					DerNode parsedNode = net.named_data.jndn.encoding.der.DerNode.parse(encoding);
					IList children = parsedNode.getChildren();
	
					// An RsaPrivateKey has integer version 0 and 8 integers.
					if (children.Count == 9
							&& children[0]   is  DerNode.DerInteger
							&& ((int) ((DerNode.DerInteger) children[0])
									.toVal()) == 0
							&& children[1]   is  DerNode.DerInteger
							&& children[2]   is  DerNode.DerInteger
							&& children[3]   is  DerNode.DerInteger
							&& children[4]   is  DerNode.DerInteger
							&& children[5]   is  DerNode.DerInteger
							&& children[6]   is  DerNode.DerInteger
							&& children[7]   is  DerNode.DerInteger
							&& children[8]   is  DerNode.DerInteger)
						keyType = net.named_data.jndn.security.KeyType.RSA;
					else
						// Assume it is an EC key. Try decoding it below.
						keyType = net.named_data.jndn.security.KeyType.EC;
				} catch (DerDecodingException ex) {
					// Assume it is an EC key. Try decoding it below.
					keyType = net.named_data.jndn.security.KeyType.EC;
				}
			}
	
			// Java can't decode a PKCS #1 private key, so make a PKCS #8 private key
			// and decode that.
			Blob pkcs8;
			if (keyType == net.named_data.jndn.security.KeyType.EC) {
				throw new TpmPrivateKey.Error(
						"TODO: loadPkcs1 for EC is not implemented");
			} else if (keyType == net.named_data.jndn.security.KeyType.RSA)
				pkcs8 = encodePkcs8PrivateKey(encoding,
						new OID(RSA_ENCRYPTION_OID), new DerNode.DerNull());
			else
				throw new TpmPrivateKey.Error("loadPkcs1: Unrecognized keyType: "
						+ keyType);
	
			loadPkcs8(pkcs8.buf(), keyType);
		}
	
		/// <summary>
		/// Load the unencrypted private key from a buffer with the PKCS #1 encoding.
		/// This replaces any existing private key in this object. This partially
		/// decodes the private key to determine the key type.
		/// </summary>
		///
		/// <param name="encoding">The byte buffer with the private key encoding.</param>
		/// <exception cref="TpmPrivateKey.Error">for errors decoding the key.</exception>
		public void loadPkcs1(ByteBuffer encoding) {
			loadPkcs1(encoding,  default(KeyType)/* was: null */);
		}
	
		/// <summary>
		/// Load the unencrypted private key from a buffer with the PKCS #8 encoding.
		/// This replaces any existing private key in this object.
		/// </summary>
		///
		/// <param name="encoding">The byte buffer with the private key encoding.</param>
		/// <param name="keyType"></param>
		/// <exception cref="TpmPrivateKey.Error">for errors decoding the key.</exception>
		public void loadPkcs8(ByteBuffer encoding, KeyType keyType) {
			if (keyType == null) {
				// Decode the PKCS #8 DER to find the algorithm OID.
				String oidString = null;
				try {
					DerNode parsedNode = net.named_data.jndn.encoding.der.DerNode.parse(encoding, 0);
					IList pkcs8Children = parsedNode.getChildren();
					IList algorithmIdChildren = net.named_data.jndn.encoding.der.DerNode
							.getSequence(pkcs8Children, 1).getChildren();
					oidString = ""
							+ ((DerNode.DerOid) algorithmIdChildren[0]).toVal();
				} catch (DerDecodingException ex) {
					throw new TpmPrivateKey.Error(
							"Cannot decode the PKCS #8 private key: " + ex);
				}
	
				if (oidString.equals(EC_ENCRYPTION_OID))
					keyType = net.named_data.jndn.security.KeyType.EC;
				else if (oidString.equals(RSA_ENCRYPTION_OID))
					keyType = net.named_data.jndn.security.KeyType.RSA;
				else
					throw new TpmPrivateKey.Error(
							"loadPkcs8: Unrecognized private key OID: " + oidString);
			}
	
			// Use a Blob to get the byte array.
			PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(new Blob(encoding,
					false).getImmutableArray());
			if (keyType == net.named_data.jndn.security.KeyType.EC) {
				try {
					KeyFactory kf = System.KeyFactory.getInstance("EC");
					privateKey_ = kf.generatePrivate(spec);
					keyType_ = net.named_data.jndn.security.KeyType.EC;
				} catch (InvalidKeySpecException ex_0) {
					// Don't expect this to happen.
					throw new TpmPrivateKey.Error(
							"loadPkcs8: EC is not supported: " + ex_0);
				} catch (Exception ex_1) {
					// Don't expect this to happen.
					throw new TpmPrivateKey.Error(
							"loadPkcs8: PKCS8EncodedKeySpec is not supported for EC: "
									+ ex_1);
				}
			} else if (keyType == net.named_data.jndn.security.KeyType.RSA) {
				try {
					KeyFactory kf_2 = System.KeyFactory.getInstance("RSA");
					privateKey_ = kf_2.generatePrivate(spec);
					keyType_ = net.named_data.jndn.security.KeyType.RSA;
				} catch (InvalidKeySpecException ex_3) {
					// Don't expect this to happen.
					throw new TpmPrivateKey.Error(
							"loadPkcs8: RSA is not supported: " + ex_3);
				} catch (Exception ex_4) {
					// Don't expect this to happen.
					throw new TpmPrivateKey.Error(
							"loadPkcs8: PKCS8EncodedKeySpec is not supported for RSA: "
									+ ex_4);
				}
			} else
				throw new TpmPrivateKey.Error("loadPkcs8: Unrecognized keyType: "
						+ keyType);
		}
	
		/// <summary>
		/// Load the unencrypted private key from a buffer with the PKCS #8 encoding.
		/// This replaces any existing private key in this object. This partially
		/// decodes the private key to determine the key type.
		/// </summary>
		///
		/// <param name="encoding">The byte buffer with the private key encoding.</param>
		/// <exception cref="TpmPrivateKey.Error">for errors decoding the key.</exception>
		public void loadPkcs8(ByteBuffer encoding) {
			loadPkcs8(encoding,  default(KeyType)/* was: null */);
		}
	
		/// <summary>
		/// Load the encrypted private key from a buffer with the PKCS #8 encoding of
		/// the EncryptedPrivateKeyInfo.
		/// This replaces any existing private key in this object. This partially
		/// decodes the private key to determine the key type.
		/// </summary>
		///
		/// <param name="encoding">The byte buffer with the private key encoding.</param>
		/// <param name="password">The password for decrypting the private key.</param>
		/// <exception cref="TpmPrivateKey.Error">for errors decoding or decrypting the key.</exception>
		public void loadEncryptedPkcs8(ByteBuffer encoding,
				ByteBuffer password) {
			// Decode the PKCS #8 EncryptedPrivateKeyInfo.
			// See https://tools.ietf.org/html/rfc5208.
			String oidString;
			Object parameters;
			Blob encryptedKey;
			try {
				DerNode parsedNode = net.named_data.jndn.encoding.der.DerNode.parse(encoding, 0);
				IList encryptedPkcs8Children = parsedNode.getChildren();
				IList algorithmIdChildren = net.named_data.jndn.encoding.der.DerNode.getSequence(
						encryptedPkcs8Children, 0).getChildren();
				oidString = ""
						+ ((DerNode.DerOid) algorithmIdChildren[0]).toVal();
				parameters = algorithmIdChildren[1];
	
				encryptedKey = (Blob) ((DerNode.DerOctetString) encryptedPkcs8Children[1]).toVal();
			} catch (Exception ex) {
				throw new TpmPrivateKey.Error(
						"Cannot decode the PKCS #8 EncryptedPrivateKeyInfo: " + ex);
			}
	
			// Use the password to get the unencrypted pkcs8Encoding.
			byte[] pkcs8Encoding;
			if (oidString.equals(PBES2_OID)) {
				// Decode the PBES2 parameters. See https://www.ietf.org/rfc/rfc2898.txt .
				String keyDerivationOidString;
				Object keyDerivationParameters;
				String encryptionSchemeOidString;
				Object encryptionSchemeParameters;
				try {
					IList parametersChildren = ((DerNode.DerSequence) parameters)
							.getChildren();
	
					IList keyDerivationAlgorithmIdChildren = net.named_data.jndn.encoding.der.DerNode.getSequence(
							parametersChildren, 0).getChildren();
					keyDerivationOidString = ""
							+ ((DerNode.DerOid) keyDerivationAlgorithmIdChildren[0]).toVal();
					keyDerivationParameters = keyDerivationAlgorithmIdChildren[1];
	
					IList encryptionSchemeAlgorithmIdChildren = net.named_data.jndn.encoding.der.DerNode.getSequence(
							parametersChildren, 1).getChildren();
					encryptionSchemeOidString = ""
							+ ((DerNode.DerOid) encryptionSchemeAlgorithmIdChildren[0]).toVal();
					encryptionSchemeParameters = encryptionSchemeAlgorithmIdChildren[1];
				} catch (Exception ex_0) {
					throw new TpmPrivateKey.Error(
							"Cannot decode the PBES2 parameters: " + ex_0);
				}
	
				// Get the derived key from the password.
				byte[] derivedKey = null;
				if (keyDerivationOidString.equals(PBKDF2_OID)) {
					// Decode the PBKDF2 parameters.
					Blob salt;
					int nIterations;
					try {
						IList Pbkdf2ParametersChildren = ((DerNode.DerSequence) keyDerivationParameters)
								.getChildren();
						salt = (Blob) ((DerNode.DerOctetString) Pbkdf2ParametersChildren[0]).toVal();
						nIterations = (int) ((DerNode.DerInteger) Pbkdf2ParametersChildren[1]).toVal();
					} catch (Exception ex_1) {
						throw new TpmPrivateKey.Error(
								"Cannot decode the PBES2 parameters: " + ex_1);
					}
	
					// Check the encryption scheme here to get the needed result length.
					int resultLength;
					if (encryptionSchemeOidString.equals(DES_EDE3_CBC_OID))
						resultLength = DES_EDE3_KEY_LENGTH;
					else
						throw new TpmPrivateKey.Error(
								"Unrecognized PBES2 encryption scheme OID: "
										+ encryptionSchemeOidString);
	
					try {
						derivedKey = net.named_data.jndn.util.Common.computePbkdf2WithHmacSha1(new Blob(
								password, false).getImmutableArray(), salt
								.getImmutableArray(), nIterations, resultLength);
					} catch (Exception ex_2) {
						throw new TpmPrivateKey.Error(
								"Error computing the derived key using PBKDF2 with HMAC SHA1: "
										+ ex_2);
					}
				} else
					throw new TpmPrivateKey.Error(
							"Unrecognized PBES2 key derivation OID: "
									+ keyDerivationOidString);
	
				// Use the derived key to get the unencrypted pkcs8Encoding.
				if (encryptionSchemeOidString.equals(DES_EDE3_CBC_OID)) {
					// Decode the DES-EDE3-CBC parameters.
					Blob initialVector;
					try {
						initialVector = (Blob) ((DerNode.DerOctetString) encryptionSchemeParameters)
								.toVal();
					} catch (Exception ex_3) {
						throw new TpmPrivateKey.Error(
								"Cannot decode the DES-EDE3-CBC parameters: " + ex_3);
					}
	
					try {
						Cipher cipher = javax.crypto.Cipher
								.getInstance("DESede/CBC/PKCS5Padding");
						cipher.init(javax.crypto.Cipher.DECRYPT_MODE, new SecretKeySpec(
								derivedKey, "DESede"), new IvParameterSpec(
								initialVector.getImmutableArray()));
						pkcs8Encoding = cipher.doFinal(encryptedKey
								.getImmutableArray());
					} catch (Exception ex_4) {
						throw new TpmPrivateKey.Error(
								"Error decrypting PKCS #8 key with DES-EDE3-CBC: "
										+ ex_4);
					}
				} else
					throw new TpmPrivateKey.Error(
							"Unrecognized PBES2 encryption scheme OID: "
									+ encryptionSchemeOidString);
			} else
				throw new TpmPrivateKey.Error(
						"Unrecognized PKCS #8 EncryptedPrivateKeyInfo OID: "
								+ oidString);
	
			loadPkcs8(ILOG.J2CsMapping.NIO.ByteBuffer.wrap(pkcs8Encoding));
		}
	
		/// <summary>
		/// Get the encoded public key for this private key.
		/// </summary>
		///
		/// <returns>The public key encoding Blob.</returns>
		/// <exception cref="TpmPrivateKey.Error">if no private key is loaded, or errorconverting to a public key.</exception>
		public Blob derivePublicKey() {
			if (keyType_ == net.named_data.jndn.security.KeyType.EC) {
				throw new TpmPrivateKey.Error(
						"TODO: derivePublicKey for EC is not implemented");
			} else if (keyType_ == net.named_data.jndn.security.KeyType.RSA) {
				// Decode the PKCS #1 RSAPrivateKey. (We don't use RSAPrivateCrtKey because
				// the Android library doesn't have an easy way to decode into it.)
				IList rsaPrivateKeyChildren;
				try {
					DerNode parsedNode = net.named_data.jndn.encoding.der.DerNode.parse(toPkcs1().buf(), 0);
					rsaPrivateKeyChildren = parsedNode.getChildren();
				} catch (DerDecodingException ex) {
					throw new TpmPrivateKey.Error("Error parsing RSA PKCS #1 key: "
							+ ex);
				}
				Blob modulus = ((DerNode) rsaPrivateKeyChildren[1])
						.getPayload();
				Blob publicExponent = ((DerNode) rsaPrivateKeyChildren[2])
						.getPayload();
	
				try {
					System.SecurityPublicKey publicKey = System.KeyFactory.getInstance(
							"RSA").generatePublic(
							new RSAPublicKeySpec((modulus
									.getImmutableArray()), (
									publicExponent.getImmutableArray())));
					return new Blob(publicKey.getEncoded(), false);
				} catch (Exception ex_0) {
					throw new TpmPrivateKey.Error("Error making RSA public key: "
							+ ex_0);
				}
			} else
				throw new TpmPrivateKey.Error(
						"derivePublicKey: The private key is not loaded");
		}
	
		/// <summary>
		/// Decrypt the cipherText using this private key according the encryption
		/// algorithmType. Only RSA encryption is supported for now.
		/// </summary>
		///
		/// <param name="cipherText">The cipher text byte buffer.</param>
		/// <param name="algorithmType">This decrypts according to algorithmType.</param>
		/// <returns>The decrypted data.</returns>
		/// <exception cref="TpmPrivateKey.Error">if the private key is not loaded, ifdecryption is not supported for this key type, or for error decrypting.</exception>
		public Blob decrypt(ByteBuffer cipherText,
				EncryptAlgorithmType algorithmType) {
			if (keyType_ == null)
				throw new TpmPrivateKey.Error(
						"decrypt: The private key is not loaded");
	
			String transformation;
			if (algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaPkcs)
				transformation = "RSA/ECB/PKCS1Padding";
			else if (algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaOaep)
				transformation = "RSA/ECB/OAEPWithSHA-1AndMGF1Padding";
			else
				throw new TpmPrivateKey.Error("unsupported padding scheme");
	
			try {
				Cipher cipher = javax.crypto.Cipher.getInstance(transformation);
				cipher.init(javax.crypto.Cipher.DECRYPT_MODE, privateKey_);
				// Use Blob to get the byte array.
				byte[] cipherByteArray = new Blob(cipherText, false)
						.getImmutableArray();
				return new Blob(cipher.doFinal(cipherByteArray), false);
			} catch (Exception ex) {
				throw new TpmPrivateKey.Error("Error decrypting with private key: "
						+ ex.Message);
			}
		}
	
		/// <summary>
		/// Call the main decrypt where algorithmType is RsaOaep.
		/// </summary>
		///
		public Blob decrypt(ByteBuffer cipherText) {
			return decrypt(cipherText, net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaOaep);
		}
	
		/// <summary>
		/// Sign the data with this private key, returning a signature Blob.
		/// </summary>
		///
		/// <param name="data">The input byte buffer.</param>
		/// <param name="digestAlgorithm">the digest algorithm.</param>
		/// <returns>The signature Blob, or an isNull Blob if this private key is not
		/// initialized.</returns>
		/// <exception cref="TpmPrivateKey.Error">for unrecognized digestAlgorithm or an errorin signing.</exception>
		public Blob sign(ByteBuffer data, DigestAlgorithm digestAlgorithm) {
			if (digestAlgorithm != net.named_data.jndn.security.DigestAlgorithm.SHA256)
				throw new TpmPrivateKey.Error(
						"TpmPrivateKey.sign: Unsupported digest algorithm");
	
			System.SecuritySignature signature = null;
			if (keyType_ == net.named_data.jndn.security.KeyType.EC) {
				try {
					signature = System.SecuritySignature
							.getInstance("SHA256withECDSA");
				} catch (Exception e) {
					// Don't expect this to happen.
					throw new TpmPrivateKey.Error(
							"SHA256withECDSA algorithm is not supported");
				}
			} else if (keyType_ == net.named_data.jndn.security.KeyType.RSA) {
				try {
					signature = System.SecuritySignature
							.getInstance("SHA256withRSA");
				} catch (Exception e_0) {
					// Don't expect this to happen.
					throw new TpmPrivateKey.Error(
							"SHA256withRSA algorithm is not supported");
				}
			} else
				return new Blob();
	
			try {
				signature.initSign(privateKey_);
			} catch (InvalidKeyException exception) {
				throw new TpmPrivateKey.Error("InvalidKeyException: "
						+ exception.Message);
			}
			try {
				signature.update(data);
				return new Blob(signature.sign(), false);
			} catch (SignatureException exception_1) {
				throw new TpmPrivateKey.Error("SignatureException: "
						+ exception_1.Message);
			}
		}
	
		/// <summary>
		/// Get the encoded unencrypted private key in PKCS #1.
		/// </summary>
		///
		/// <returns>The private key encoding Blob.</returns>
		/// <exception cref="TpmPrivateKey.Error">if no private key is loaded, or error encoding.</exception>
		public Blob toPkcs1() {
			if (keyType_ == null)
				throw new TpmPrivateKey.Error(
						"toPkcs1: The private key is not loaded");
	
			// Decode the PKCS #8 private key.
			DerNode parsedNode;
			try {
				parsedNode = net.named_data.jndn.encoding.der.DerNode.parse(toPkcs8().buf(), 0);
				IList pkcs8Children = parsedNode.getChildren();
				return ((DerNode) pkcs8Children[2]).getPayload();
			} catch (DerDecodingException ex) {
				throw new TpmPrivateKey.Error(
						"Error decoding PKCS #8 private key: " + ex);
			}
		}
	
		/// <summary>
		/// Get the encoded unencrypted private key in PKCS #8.
		/// </summary>
		///
		/// <returns>The private key encoding Blob.</returns>
		/// <exception cref="TpmPrivateKey.Error">if no private key is loaded, or error encoding.</exception>
		public Blob toPkcs8() {
			if (keyType_ == null)
				throw new TpmPrivateKey.Error(
						"toPkcs8: The private key is not loaded");
	
			return new Blob(privateKey_.getEncoded());
		}
	
		/// <summary>
		/// Get the encoded encrypted private key in PKCS #8.
		/// </summary>
		///
		/// <param name="password">The password for encrypting the private key.</param>
		/// <returns>The encoding Blob of the EncryptedPrivateKeyInfo.</returns>
		/// <exception cref="TpmPrivateKey.Error">if no private key is loaded, or error encoding.</exception>
		public Blob toEncryptedPkcs8(ByteBuffer password) {
			if (keyType_ == null)
				throw new TpmPrivateKey.Error(
						"toEncryptedPkcs8: The private key is not loaded");
	
			// Create the derivedKey from the password.
			int nIterations = 2048;
			byte[] salt = new byte[8];
			net.named_data.jndn.util.Common.getRandom().nextBytes(salt);
			byte[] derivedKey;
			try {
				derivedKey = net.named_data.jndn.util.Common.computePbkdf2WithHmacSha1(new Blob(password,
						false).getImmutableArray(), salt, nIterations,
						DES_EDE3_KEY_LENGTH);
			} catch (Exception ex) {
				// We don't expect this to happen.
				throw new TpmPrivateKey.Error(
						"Error computing the derived key using PBKDF2 with HMAC SHA1: "
								+ ex);
			}
	
			// Use the derived key to get the encrypted pkcs8Encoding.
			byte[] encryptedEncoding;
			byte[] initialVector = new byte[8];
			net.named_data.jndn.util.Common.getRandom().nextBytes(initialVector);
			try {
				Cipher cipher = javax.crypto.Cipher.getInstance("DESede/CBC/PKCS5Padding");
				cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, new SecretKeySpec(derivedKey,
						"DESede"), new IvParameterSpec(initialVector));
				encryptedEncoding = cipher.doFinal(privateKey_.getEncoded());
			} catch (Exception ex_0) {
				throw new TpmPrivateKey.Error(
						"Error encrypting PKCS #8 key with DES-EDE3-CBC: " + ex_0);
			}
	
			try {
				// Encode the PBES2 parameters. See https://www.ietf.org/rfc/rfc2898.txt .
				net.named_data.jndn.encoding.der.DerNode.DerSequence  keyDerivationParameters = new net.named_data.jndn.encoding.der.DerNode.DerSequence ();
				keyDerivationParameters.addChild(new DerNode.DerOctetString(
						ILOG.J2CsMapping.NIO.ByteBuffer.wrap(salt)));
				keyDerivationParameters
						.addChild(new DerNode.DerInteger(nIterations));
				net.named_data.jndn.encoding.der.DerNode.DerSequence  keyDerivationAlgorithmIdentifier = new net.named_data.jndn.encoding.der.DerNode.DerSequence ();
				keyDerivationAlgorithmIdentifier.addChild(new DerNode.DerOid(
						PBKDF2_OID));
				keyDerivationAlgorithmIdentifier.addChild(keyDerivationParameters);
	
				net.named_data.jndn.encoding.der.DerNode.DerSequence  encryptionSchemeAlgorithmIdentifier = new net.named_data.jndn.encoding.der.DerNode.DerSequence ();
				encryptionSchemeAlgorithmIdentifier.addChild(new DerNode.DerOid(
						DES_EDE3_CBC_OID));
				encryptionSchemeAlgorithmIdentifier
						.addChild(new DerNode.DerOctetString(ILOG.J2CsMapping.NIO.ByteBuffer
								.wrap(initialVector)));
	
				net.named_data.jndn.encoding.der.DerNode.DerSequence  encryptedKeyParameters = new net.named_data.jndn.encoding.der.DerNode.DerSequence ();
				encryptedKeyParameters.addChild(keyDerivationAlgorithmIdentifier);
				encryptedKeyParameters
						.addChild(encryptionSchemeAlgorithmIdentifier);
				net.named_data.jndn.encoding.der.DerNode.DerSequence  encryptedKeyAlgorithmIdentifier = new net.named_data.jndn.encoding.der.DerNode.DerSequence ();
				encryptedKeyAlgorithmIdentifier.addChild(new DerNode.DerOid(
						PBES2_OID));
				encryptedKeyAlgorithmIdentifier.addChild(encryptedKeyParameters);
	
				// Encode the PKCS #8 EncryptedPrivateKeyInfo.
				// See https://tools.ietf.org/html/rfc5208.
				net.named_data.jndn.encoding.der.DerNode.DerSequence  encryptedKey = new net.named_data.jndn.encoding.der.DerNode.DerSequence ();
				encryptedKey.addChild(encryptedKeyAlgorithmIdentifier);
				encryptedKey.addChild(new DerNode.DerOctetString(ILOG.J2CsMapping.NIO.ByteBuffer
						.wrap(encryptedEncoding)));
	
				return encryptedKey.encode();
			} catch (DerEncodingException ex_1) {
				throw new TpmPrivateKey.Error(
						"Error encoding the encryped PKCS #8 private key: " + ex_1);
			}
		}
	
		/// <summary>
		/// Generate a key pair according to keyParams and return a new TpmPrivateKey
		/// with the private key. You can get the public key with derivePublicKey.
		/// </summary>
		///
		/// <param name="keyParams">The parameters of the key.</param>
		/// <returns>A new TpmPrivateKey.</returns>
		/// <exception cref="System.ArgumentException">if the key type is not supported.</exception>
		/// <exception cref="TpmPrivateKey.Error">for an invalid key size, or an error generating.</exception>
		public static TpmPrivateKey generatePrivateKey(KeyParams keyParams) {
			String keyAlgorithm;
			int keySize;
			if (keyParams.getKeyType() == net.named_data.jndn.security.KeyType.RSA) {
				keyAlgorithm = "RSA";
				keySize = ((RsaKeyParams) keyParams).getKeySize();
			} else if (keyParams.getKeyType() == net.named_data.jndn.security.KeyType.EC) {
				keyAlgorithm = "EC";
				keySize = ((EcKeyParams) keyParams).getKeySize();
			} else
				throw new ArgumentException(
						"Cannot generate a key pair of type "
								+ keyParams.getKeyType());
	
			KeyPairGenerator generator = null;
			try {
				generator = System.KeyPairGenerator.getInstance(keyAlgorithm);
			} catch (Exception e) {
				throw new TpmPrivateKey.Error(
						"TpmPrivateKey: Could not create the key generator: "
								+ e.Message);
			}
	
			generator.initialize(keySize);
			KeyPair pair = generator.generateKeyPair();
	
			TpmPrivateKey result = new TpmPrivateKey();
			result.keyType_ = keyParams.getKeyType();
			result.privateKey_ = pair.getPrivate();
	
			return result;
		}
	
		/// <summary>
		/// Encode the private key to a PKCS #8 private key. We do this explicitly here
		/// to avoid linking to extra OpenSSL libraries.
		/// </summary>
		///
		/// <param name="privateKeyDer">The input private key DER.</param>
		/// <param name="oid">The OID of the privateKey.</param>
		/// <param name="parameters">The DerNode of the parameters for the OID.</param>
		/// <returns>The PKCS #8 private key DER.</returns>
		private static Blob encodePkcs8PrivateKey(ByteBuffer privateKeyDer,
				OID oid, DerNode parameters) {
			try {
				net.named_data.jndn.encoding.der.DerNode.DerSequence  algorithmIdentifier = new net.named_data.jndn.encoding.der.DerNode.DerSequence ();
				algorithmIdentifier.addChild(new DerNode.DerOid(oid));
				algorithmIdentifier.addChild(parameters);
	
				net.named_data.jndn.encoding.der.DerNode.DerSequence  result = new net.named_data.jndn.encoding.der.DerNode.DerSequence ();
				result.addChild(new DerNode.DerInteger(0));
				result.addChild(algorithmIdentifier);
				result.addChild(new DerNode.DerOctetString(privateKeyDer));
	
				return result.encode();
			} catch (DerEncodingException ex) {
				throw new TpmPrivateKey.Error(
						"Error encoding PKCS #8 private key: " + ex);
			}
		}
	
		private const String RSA_ENCRYPTION_OID = "1.2.840.113549.1.1.1";
		private const String EC_ENCRYPTION_OID = "1.2.840.10045.2.1";
		private const String PBES2_OID = "1.2.840.113549.1.5.13";
		private const String PBKDF2_OID = "1.2.840.113549.1.5.12";
		private const String DES_EDE3_CBC_OID = "1.2.840.113549.3.7";
		private const int DES_EDE3_KEY_LENGTH = 24;
	
		private KeyType keyType_;
		private System.PrivateKey privateKey_;
	}
}
