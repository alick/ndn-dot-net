// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security.tpm {
	
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.spec;
	using javax.crypto;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.encoding.der;
	using net.named_data.jndn.encrypt.algo;
	using net.named_data.jndn.security;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// A TpmPrivateKey holds an in-memory private key and provides cryptographic
	/// operations such as for signing by the in-memory TPM.
	/// </summary>
	///
	public class TpmPrivateKey {
		/// <summary>
		/// A TpmPrivateKey.Error extends Exception and represents an error in private
		/// key processing.
		/// Note that even though this is called "Error" to be consistent with the
		/// other libraries, it extends the Java Exception class, not Error.
		/// </summary>
		///
		[Serializable]
		public class Error : Exception {
			public Error(String message) : base(message) {
			}
		}
	
		/// <summary>
		/// Create an uninitialized TpmPrivateKey. You must call a load method to
		/// initialize it, such as loadPkcs1.
		/// </summary>
		///
		public TpmPrivateKey() {
			this.keyType_ =  default(KeyType)/* was: null */;
		}
	
		/// <summary>
		/// Load the unencrypted private key from a buffer with the PKCS #1 encoding.
		/// This replaces any existing private key in this object.
		/// </summary>
		///
		/// <param name="encoding">The byte buffer with the private key encoding.</param>
		/// <param name="keyType"></param>
		/// <exception cref="TpmPrivateKey.Error">for errors decoding the key.</exception>
		public void loadPkcs1(ByteBuffer encoding, KeyType keyType) {
			if (keyType == null) {
				// Try to determine the key type.
				try {
					DerNode parsedNode = net.named_data.jndn.encoding.der.DerNode.parse(encoding);
					IList children = parsedNode.getChildren();
	
					// An RsaPrivateKey has integer version 0 and 8 integers.
					if (children.Count == 9
							&& children[0]   is  DerNode.DerInteger
							&& ((int) ((DerNode.DerInteger) children[0])
									.toVal()) == 0
							&& children[1]   is  DerNode.DerInteger
							&& children[2]   is  DerNode.DerInteger
							&& children[3]   is  DerNode.DerInteger
							&& children[4]   is  DerNode.DerInteger
							&& children[5]   is  DerNode.DerInteger
							&& children[6]   is  DerNode.DerInteger
							&& children[7]   is  DerNode.DerInteger
							&& children[8]   is  DerNode.DerInteger)
						keyType = net.named_data.jndn.security.KeyType.RSA;
					else
						// Assume it is an EC key. Try decoding it below.
						keyType = net.named_data.jndn.security.KeyType.ECDSA;
				} catch (DerDecodingException ex) {
					// Assume it is an EC key. Try decoding it below.
					keyType = net.named_data.jndn.security.KeyType.ECDSA;
				}
			}
	
			// Java can't decode a PKCS #1 private key, so make a PKCS #8 private key
			// and decode that.
			Blob pkcs8;
			if (keyType == net.named_data.jndn.security.KeyType.ECDSA) {
				throw new TpmPrivateKey.Error ("TODO: loadPkcs1 for EC is not implemented");
			} else if (keyType == net.named_data.jndn.security.KeyType.RSA)
				pkcs8 = encodePkcs8PrivateKey(encoding,
						new OID(RSA_ENCRYPTION_OID), new DerNode.DerNull());
			else
				throw new TpmPrivateKey.Error ("loadPkcs1: Unrecognized keyType: " + keyType);
	
			loadPkcs8(pkcs8.buf(), keyType);
		}
	
		/// <summary>
		/// Load the unencrypted private key from a buffer with the PKCS #1 encoding.
		/// This replaces any existing private key in this object. This partially
		/// decodes the private key to determine the key type.
		/// </summary>
		///
		/// <param name="encoding">The byte buffer with the private key encoding.</param>
		/// <exception cref="TpmPrivateKey.Error">for errors decoding the key.</exception>
		public void loadPkcs1(ByteBuffer encoding) {
			loadPkcs1(encoding,  default(KeyType)/* was: null */);
		}
	
		/// <summary>
		/// Load the unencrypted private key from a buffer with the PKCS #8 encoding.
		/// This replaces any existing private key in this object.
		/// </summary>
		///
		/// <param name="encoding">The byte buffer with the private key encoding.</param>
		/// <param name="keyType"></param>
		/// <exception cref="TpmPrivateKey.Error">for errors decoding the key.</exception>
		public void loadPkcs8(ByteBuffer encoding, KeyType keyType) {
			if (keyType == null) {
				// Decode the PKCS #8 DER to find the algorithm OID.
				String oidString = null;
				try {
					DerNode parsedNode = net.named_data.jndn.encoding.der.DerNode.parse(encoding, 0);
					IList pkcs8Children = parsedNode.getChildren();
					IList algorithmIdChildren = net.named_data.jndn.encoding.der.DerNode
							.getSequence(pkcs8Children, 1).getChildren();
					oidString = ""
							+ ((DerNode.DerOid) algorithmIdChildren[0]).toVal();
				} catch (DerDecodingException ex) {
					throw new TpmPrivateKey.Error ("Cannot decode the PKCS #8 private key: " + ex);
				}
	
				if (oidString.equals(EC_ENCRYPTION_OID))
					keyType = net.named_data.jndn.security.KeyType.ECDSA;
				else if (oidString.equals(RSA_ENCRYPTION_OID))
					keyType = net.named_data.jndn.security.KeyType.RSA;
				else
					throw new TpmPrivateKey.Error ("loadPkcs8: Unrecognized private key OID: "
							+ oidString);
			}
	
			// Use a Blob to get the byte array.
			PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(new Blob(encoding,
					false).getImmutableArray());
			if (keyType == net.named_data.jndn.security.KeyType.ECDSA) {
				try {
					KeyFactory kf = System.KeyFactory.getInstance("EC");
					privateKey_ = kf.generatePrivate(spec);
					keyType_ = net.named_data.jndn.security.KeyType.ECDSA;
				} catch (InvalidKeySpecException ex_0) {
					// Don't expect this to happen.
					throw new TpmPrivateKey.Error ("loadPkcs8: EC is not supported: " + ex_0);
				} catch (Exception ex_1) {
					// Don't expect this to happen.
					throw new TpmPrivateKey.Error (
							"loadPkcs8: PKCS8EncodedKeySpec is not supported for EC: "
									+ ex_1);
				}
			} else if (keyType == net.named_data.jndn.security.KeyType.RSA) {
				try {
					KeyFactory kf_2 = System.KeyFactory.getInstance("RSA");
					privateKey_ = kf_2.generatePrivate(spec);
					keyType_ = net.named_data.jndn.security.KeyType.RSA;
				} catch (InvalidKeySpecException ex_3) {
					// Don't expect this to happen.
					throw new TpmPrivateKey.Error ("loadPkcs8: RSA is not supported: " + ex_3);
				} catch (Exception ex_4) {
					// Don't expect this to happen.
					throw new TpmPrivateKey.Error (
							"loadPkcs8: PKCS8EncodedKeySpec is not supported for RSA: "
									+ ex_4);
				}
			} else
				throw new TpmPrivateKey.Error ("loadPkcs8: Unrecognized keyType: " + keyType);
		}
	
		/// <summary>
		/// Load the unencrypted private key from a buffer with the PKCS #8 encoding.
		/// This replaces any existing private key in this object. This partially
		/// decodes the private key to determine the key type.
		/// </summary>
		///
		/// <param name="encoding">The byte buffer with the private key encoding.</param>
		/// <exception cref="TpmPrivateKey.Error">for errors decoding the key.</exception>
		public void loadPkcs8(ByteBuffer encoding) {
			loadPkcs8(encoding,  default(KeyType)/* was: null */);
		}
	
		/// <summary>
		/// Get the encoded public key for this private key.
		/// </summary>
		///
		/// <returns>The public key encoding Blob.</returns>
		/// <exception cref="TpmPrivateKey.Error">if no private key is loaded, or errorconverting to a public key.</exception>
		public Blob derivePublicKey() {
			if (keyType_ == net.named_data.jndn.security.KeyType.ECDSA) {
				throw new TpmPrivateKey.Error ("TODO: derivePublicKey for EC is not implemented");
			} else if (keyType_ == net.named_data.jndn.security.KeyType.RSA) {
				// Decode the PKCS #1 RSAPrivateKey. (We don't use RSAPrivateCrtKey because
				// the Android library doesn't have an easy way to decode into it.)
				IList rsaPrivateKeyChildren;
				try {
					DerNode parsedNode = net.named_data.jndn.encoding.der.DerNode.parse(toPkcs1().buf(), 0);
					rsaPrivateKeyChildren = parsedNode.getChildren();
				} catch (DerDecodingException ex) {
					throw new TpmPrivateKey.Error ("Error parsing RSA PKCS #1 key: " + ex);
				}
				Blob modulus = ((DerNode) rsaPrivateKeyChildren[1])
						.getPayload();
				Blob publicExponent = ((DerNode) rsaPrivateKeyChildren[2])
						.getPayload();
	
				try {
					System.SecurityPublicKey publicKey = System.KeyFactory.getInstance(
							"RSA").generatePublic(
							new RSAPublicKeySpec((modulus
									.getImmutableArray()), (
									publicExponent.getImmutableArray())));
					return new Blob(publicKey.getEncoded(), false);
				} catch (Exception ex_0) {
					throw new TpmPrivateKey.Error ("Error making RSA public key: " + ex_0);
				}
			} else
				throw new TpmPrivateKey.Error ("derivePublicKey: The private key is not loaded");
		}
	
		/// <summary>
		/// Decrypt the cipherText using this private key according the encryption
		/// algorithmType. Only RSA encryption is supported for now.
		/// </summary>
		///
		/// <param name="cipherText">The cipher text byte buffer.</param>
		/// <param name="algorithmType">This decrypts according to algorithmType.</param>
		/// <returns>The decrypted data.</returns>
		/// <exception cref="TpmPrivateKey.Error">if the private key is not loaded, ifdecryption is not supported for this key type, or for error decrypting.</exception>
		public Blob decrypt(ByteBuffer cipherText,
				EncryptAlgorithmType algorithmType) {
			if (keyType_ == null)
				throw new TpmPrivateKey.Error(
						"decrypt: The private key is not loaded");
	
			String transformation;
			if (algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaPkcs)
				transformation = "RSA/ECB/PKCS1Padding";
			else if (algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaOaep)
				transformation = "RSA/ECB/OAEPWithSHA-1AndMGF1Padding";
			else
				throw new TpmPrivateKey.Error ("unsupported padding scheme");
	
			try {
				Cipher cipher = javax.crypto.Cipher.getInstance(transformation);
				cipher.init(javax.crypto.Cipher.DECRYPT_MODE, privateKey_);
				// Use Blob to get the byte array.
				byte[] cipherByteArray = new Blob(cipherText, false)
						.getImmutableArray();
				return new Blob(cipher.doFinal(cipherByteArray), false);
			} catch (Exception ex) {
				throw new TpmPrivateKey.Error ("Error decrypting with private key: "
						+ ex.Message);
			}
		}
	
		/// <summary>
		/// Call the main decrypt where algorithmType is RsaOaep.
		/// </summary>
		///
		public Blob decrypt(ByteBuffer cipherText) {
			return decrypt(cipherText, net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaOaep);
		}
	
		/// <summary>
		/// Sign the data with this private key, returning a signature Blob.
		/// </summary>
		///
		/// <param name="data">The input byte buffer.</param>
		/// <param name="digestAlgorithm">the digest algorithm.</param>
		/// <returns>The signature Blob, or an isNull Blob if this private key is not
		/// initialized.</returns>
		/// <exception cref="TpmPrivateKey.Error">for unrecognized digestAlgorithm or an errorin signing.</exception>
		public Blob sign(ByteBuffer data, DigestAlgorithm digestAlgorithm) {
			if (digestAlgorithm != net.named_data.jndn.security.DigestAlgorithm.SHA256)
				throw new TpmPrivateKey.Error ("TpmPrivateKey.sign: Unsupported digest algorithm");
	
			System.SecuritySignature signature = null;
			if (keyType_ == net.named_data.jndn.security.KeyType.ECDSA) {
				try {
					signature = System.SecuritySignature
							.getInstance("SHA256withECDSA");
				} catch (Exception e) {
					// Don't expect this to happen.
					throw new TpmPrivateKey.Error ("SHA256withECDSA algorithm is not supported");
				}
			} else if (keyType_ == net.named_data.jndn.security.KeyType.RSA) {
				try {
					signature = System.SecuritySignature
							.getInstance("SHA256withRSA");
				} catch (Exception e_0) {
					// Don't expect this to happen.
					throw new TpmPrivateKey.Error ("SHA256withRSA algorithm is not supported");
				}
			} else
				return new Blob();
	
			try {
				signature.initSign(privateKey_);
			} catch (InvalidKeyException exception) {
				throw new TpmPrivateKey.Error ("InvalidKeyException: " + exception.Message);
			}
			try {
				signature.update(data);
				return new Blob(signature.sign(), false);
			} catch (SignatureException exception_1) {
				throw new TpmPrivateKey.Error ("SignatureException: " + exception_1.Message);
			}
		}
	
		/// <summary>
		/// Get the encoded unencrypted private key in PKCS #1.
		/// </summary>
		///
		/// <returns>The private key encoding Blob.</returns>
		/// <exception cref="TpmPrivateKey.Error">if no private key is loaded, or error encoding.</exception>
		public Blob toPkcs1() {
			if (keyType_ == null)
				throw new TpmPrivateKey.Error ("toPkcs1: The private key is not loaded");
	
			// Decode the PKCS #8 private key.
			DerNode parsedNode;
			try {
				parsedNode = net.named_data.jndn.encoding.der.DerNode.parse(toPkcs8().buf(), 0);
				IList pkcs8Children = parsedNode.getChildren();
				return ((DerNode) pkcs8Children[2]).getPayload();
			} catch (DerDecodingException ex) {
				throw new TpmPrivateKey.Error ("Error decoding PKCS #8 private key: " + ex);
			}
		}
	
		/// <summary>
		/// Get the encoded unencrypted private key in PKCS #8.
		/// </summary>
		///
		/// <returns>The private key encoding Blob.</returns>
		/// <exception cref="TpmPrivateKey.Error">if no private key is loaded, or error encoding.</exception>
		public Blob toPkcs8() {
			if (keyType_ == null)
				throw new TpmPrivateKey.Error(
						"toPkcs8: The private key is not loaded");
	
			return new Blob(privateKey_.getEncoded());
		}
	
		/// <summary>
		/// Generate a key pair according to keyParams and return a new TpmPrivateKey
		/// with the private key. You can get the public key with derivePublicKey.
		/// </summary>
		///
		/// <param name="keyParams">The parameters of the key.</param>
		/// <returns>A new TpmPrivateKey.</returns>
		/// <exception cref="System.ArgumentException">if the key type is not supported.</exception>
		/// <exception cref="TpmPrivateKey.Error">for an invalid key size, or an error generating.</exception>
		public static TpmPrivateKey generatePrivateKey(KeyParams keyParams) {
			String keyAlgorithm;
			int keySize;
			if (keyParams.getKeyType() == net.named_data.jndn.security.KeyType.RSA) {
				keyAlgorithm = "RSA";
				keySize = ((RsaKeyParams) keyParams).getKeySize();
			} else if (keyParams.getKeyType() == net.named_data.jndn.security.KeyType.ECDSA) {
				keyAlgorithm = "EC";
				keySize = ((EcdsaKeyParams) keyParams).getKeySize();
			} else
				throw new ArgumentException(
						"Cannot generate a key pair of type "
								+ keyParams.getKeyType());
	
			KeyPairGenerator generator = null;
			try {
				generator = System.KeyPairGenerator.getInstance(keyAlgorithm);
			} catch (Exception e) {
				throw new TpmPrivateKey.Error (
						"TpmPrivateKey: Could not create the key generator: "
								+ e.Message);
			}
	
			generator.initialize(keySize);
			KeyPair pair = generator.generateKeyPair();
	
			TpmPrivateKey result = new TpmPrivateKey();
			result.keyType_ = keyParams.getKeyType();
			result.privateKey_ = pair.getPrivate();
	
			return result;
		}
	
		/// <summary>
		/// Encode the private key to a PKCS #8 private key. We do this explicitly here
		/// to avoid linking to extra OpenSSL libraries.
		/// </summary>
		///
		/// <param name="privateKeyDer">The input private key DER.</param>
		/// <param name="oid">The OID of the privateKey.</param>
		/// <param name="parameters">The DerNode of the parameters for the OID.</param>
		/// <returns>The PKCS #8 private key DER.</returns>
		private static Blob encodePkcs8PrivateKey(ByteBuffer privateKeyDer,
				OID oid, DerNode parameters) {
			try {
				net.named_data.jndn.encoding.der.DerNode.DerSequence  algorithmIdentifier = new net.named_data.jndn.encoding.der.DerNode.DerSequence ();
				algorithmIdentifier.addChild(new DerNode.DerOid(oid));
				algorithmIdentifier.addChild(parameters);
	
				net.named_data.jndn.encoding.der.DerNode.DerSequence  result = new net.named_data.jndn.encoding.der.DerNode.DerSequence ();
				result.addChild(new DerNode.DerInteger(0));
				result.addChild(algorithmIdentifier);
				result.addChild(new DerNode.DerOctetString(privateKeyDer));
	
				return result.encode();
			} catch (DerEncodingException ex) {
				throw new TpmPrivateKey.Error ("Error encoding PKCS #8 private key: " + ex);
			}
		}
	
		static private String RSA_ENCRYPTION_OID = "1.2.840.113549.1.1.1";
		static private String EC_ENCRYPTION_OID = "1.2.840.10045.2.1";
	
		private KeyType keyType_;
		private System.PrivateKey privateKey_;
	}
}
