// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017-2018 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security.tpm {
	
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.security;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// TpmBackEndMemory extends TpmBackEnd to implement a TPM back-end using
	/// in-memory storage.
	/// </summary>
	///
	public class TpmBackEndMemory : TpmBackEnd {
		public TpmBackEndMemory() {
			this.keys_ = new Hashtable<Name, TpmPrivateKey>();
		}
	
		public static String getScheme() {
			return "tpm-memory";
		}
	
		/// <summary>
		/// Check if the key with name keyName exists in the TPM.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <returns>True if the key exists.</returns>
		protected internal override bool doHasKey(Name keyName) {
			return keys_.Contains(keyName);
		}
	
		/// <summary>
		/// Get the handle of the key with name keyName.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <returns>The handle of the key, or null if the key does not exist.</returns>
		protected internal override TpmKeyHandle doGetKeyHandle(Name keyName) {
			TpmPrivateKey key = ILOG.J2CsMapping.Collections.Collections.Get(keys_,keyName);
			if (key == null)
				return null;
	
			return new TpmKeyHandleMemory(key);
		}
	
		/// <summary>
		/// Create a key for identityName according to params. The created key is
		/// named as: /{identityName}/[keyId]/KEY . The key name is set in the returned
		/// TpmKeyHandle.
		/// </summary>
		///
		/// <param name="identityName">The name if the identity.</param>
		/// <param name="params">The KeyParams for creating the key.</param>
		/// <returns>The handle of the created key.</returns>
		/// <exception cref="TpmBackEnd.Error">if the key cannot be created.</exception>
		protected internal override TpmKeyHandle doCreateKey(Name identityName, KeyParams paras) {
			TpmPrivateKey key;
			try {
				key = net.named_data.jndn.security.tpm.TpmPrivateKey.generatePrivateKey(paras);
			} catch (TpmPrivateKey.Error ex) {
				throw new TpmBackEnd.Error ("Error in TpmPrivateKey.generatePrivateKey: " + ex);
			}
			TpmKeyHandle keyHandle = new TpmKeyHandleMemory(key);
	
			net.named_data.jndn.security.tpm.TpmBackEnd.setKeyName(keyHandle, identityName, paras);
	
			ILOG.J2CsMapping.Collections.Collections.Put(keys_,keyHandle.getKeyName(),key);
			return keyHandle;
		}
	
		/// <summary>
		/// Delete the key with name keyName. If the key doesn't exist, do nothing.
		/// </summary>
		///
		/// <param name="keyName">The name of the key to delete.</param>
		/// <exception cref="TpmBackEnd.Error">if the deletion fails.</exception>
		protected internal override void doDeleteKey(Name keyName) {
			ILOG.J2CsMapping.Collections.Collections.Remove(keys_,keyName);
		}
	
		/// <summary>
		/// Get the encoded private key with name keyName in PKCS #8 format, possibly
		/// password-encrypted.
		/// </summary>
		///
		/// <param name="keyName">The name of the key in the TPM.</param>
		/// <param name="password">If the password is null, return an unencrypted PKCS #8 PrivateKeyInfo.</param>
		/// <returns>The encoded private key.</returns>
		/// <exception cref="TpmBackEnd.Error">if the key does not exist or if the key cannot beexported, e.g., insufficient privileges.</exception>
		protected internal override Blob doExportKey(Name keyName, ByteBuffer password) {
			if (password != null)
				throw new TpmBackEnd.Error (
						"Private key password-encryption is not implemented");
			else {
				if (!hasKey(keyName))
					throw new TpmBackEnd.Error ("exportKey: The key does not exist");
	
				try {
					return ILOG.J2CsMapping.Collections.Collections.Get(keys_,keyName).toPkcs8();
				} catch (TpmPrivateKey.Error ex) {
					throw new TpmBackEnd.Error ("Error in toPkcs8: " + ex);
				}
			}
		}
	
		/// <summary>
		/// Import an encoded private key with name keyName in PKCS #8 format, possibly
		/// passwprd-encrypted.
		/// </summary>
		///
		/// <param name="keyName">The name of the key to use in the TPM.</param>
		/// <param name="pkcs8">unencrypted PKCS #8 PrivateKeyInfo.</param>
		/// <param name="password">If the password is null, import an unencrypted PKCS #8 PrivateKeyInfo.</param>
		/// <exception cref="TpmBackEnd.Error">for an error importing the key.</exception>
		protected internal override void doImportKey(Name keyName, ByteBuffer pkcs8,
				ByteBuffer password) {
			try {
				if (password != null)
					throw new TpmBackEnd.Error (
							"Private key password-encryption is not implemented");
				else {
					TpmPrivateKey key = new TpmPrivateKey();
					key.loadPkcs8(pkcs8);
					// Copy the Name.
					ILOG.J2CsMapping.Collections.Collections.Put(keys_,new Name(keyName),key);
				}
			} catch (TpmPrivateKey.Error ex) {
				throw new TpmBackEnd.Error ("Cannot import private key: " + ex);
			}
		}
	
		private readonly Hashtable<Name, TpmPrivateKey> keys_;
	}
}
