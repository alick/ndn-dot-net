// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017-2018 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security.pib {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.security.v2;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// PibMemory extends PibImpl and is used by the Pib class as an in-memory
	/// implementation of a PIB. All the contents in the PIB are stored in memory and
	/// have the same lifetime as the PibMemory instance.
	/// </summary>
	///
	public class PibMemory : PibImpl {
		public PibMemory() {
			this.tpmLocator_ = "";
			this.defaultIdentityName_ = null;
			this.identityNames_ = new HashedSet<Name>();
			this.defaultKeyNames_ = new Hashtable<Name, Name>();
			this.keys_ = new Hashtable<Name, Blob>();
			this.defaultCertificateNames_ = new Hashtable<Name, Name>();
			this.certificates_ = new Hashtable<Name, CertificateV2>();
		}
	
		public static String getScheme() {
			return "pib-memory";
		}
	
		// TpmLocator management.
	
		/// <summary>
		/// Set the corresponding TPM information to tpmLocator. This method does not
		/// reset the contents of the PIB.
		/// </summary>
		///
		/// <param name="tpmLocator">The TPM locator string.</param>
		public override void setTpmLocator(String tpmLocator) {
			tpmLocator_ = tpmLocator;
		}
	
		/// <summary>
		/// Get the TPM Locator.
		/// </summary>
		///
		/// <returns>The TPM locator string.</returns>
		public override String getTpmLocator() {
			return tpmLocator_;
		}
	
		// Identity management.
	
		/// <summary>
		/// Check for the existence of an identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>True if the identity exists, otherwise false.</returns>
		public override bool hasIdentity(Name identityName) {
			return ILOG.J2CsMapping.Collections.Collections.Contains(identityName,identityNames_);
		}
	
		/// <summary>
		/// Add the identity. If the identity already exists, do nothing. If no default
		/// identity has been set, set the added identity as the default.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity to add. This copies the name.</param>
		public override void addIdentity(Name identityName) {
			Name identityNameCopy = new Name(identityName);
			ILOG.J2CsMapping.Collections.Collections.Add(identityNames_,identityNameCopy);
	
			if (defaultIdentityName_ == null)
				defaultIdentityName_ = identityNameCopy;
		}
	
		/// <summary>
		/// Remove the identity and its related keys and certificates. If the default
		/// identity is being removed, no default identity will be selected.  If the
		/// identity does not exist, do nothing.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity to remove.</param>
		public override void removeIdentity(Name identityName) {
			ILOG.J2CsMapping.Collections.Collections.Remove(identityNames_,identityName);
			if (defaultIdentityName_ != null
					&& identityName.equals(defaultIdentityName_))
				defaultIdentityName_ = null;
	
			/* foreach */
			foreach (Name keyName  in  getKeysOfIdentity(identityName))
				removeKey(keyName);
		}
	
		/// <summary>
		/// Erase all certificates, keys, and identities.
		/// </summary>
		///
		public override void clearIdentities() {
			defaultIdentityName_ = null;
			ILOG.J2CsMapping.Collections.Collections.Clear(identityNames_);
			defaultKeyNames_.clear();
			keys_.clear();
			defaultCertificateNames_.clear();
			certificates_.clear();
		}
	
		/// <summary>
		/// Get the names of all the identities.
		/// </summary>
		///
		/// <returns>The set of identity names. The Name objects are fresh copies.</returns>
		public override HashedSet<Name> getIdentities() {
			// Copy the Name objects.
			HashedSet<Name> result = new HashedSet<Name>();
			/* foreach */
			foreach (Name name  in  identityNames_)
				ILOG.J2CsMapping.Collections.Collections.Add(result,new Name(name));
	
			return result;
		}
	
		/// <summary>
		/// Set the identity with the identityName as the default identity. If the
		/// identity with identityName does not exist, then it will be created.
		/// </summary>
		///
		/// <param name="identityName">The name for the default identity. This copies the name.</param>
		public override void setDefaultIdentity(Name identityName) {
			addIdentity(identityName);
			// Copy the name.
			defaultIdentityName_ = new Name(identityName);
		}
	
		/// <summary>
		/// Get the default identity.
		/// </summary>
		///
		/// <returns>The name of the default identity, as a fresh copy.</returns>
		/// <exception cref="Pib.Error">for no default identity.</exception>
		public override Name getDefaultIdentity() {
			if (defaultIdentityName_ != null)
				// Copy the name.
				return new Name(defaultIdentityName_);
	
			throw new Pib.Error("No default identity");
		}
	
		// Key management.
	
		/// <summary>
		/// Check for the existence of a key with keyName.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <returns>True if the key exists, otherwise false. Return false if the
		/// identity does not exist.</returns>
		public override bool hasKey(Name keyName) {
			return keys_.Contains(keyName);
		}
	
		/// <summary>
		/// Add the key. If a key with the same name already exists, overwrite the key.
		/// If the identity does not exist, it will be created. If no default key for
		/// the identity has been set, then set the added key as the default for the
		/// identity.  If no default identity has been set, identity becomes the
		/// default.
		/// </summary>
		///
		/// <param name="identityName"></param>
		/// <param name="keyName">The name of the key. This copies the name.</param>
		/// <param name="key">The public key bits. This copies the array.</param>
		public override void addKey(Name identityName, Name keyName, ByteBuffer key) {
			addIdentity(identityName);
	
			Name keyNameCopy = new Name(keyName);
			ILOG.J2CsMapping.Collections.Collections.Put(keys_,keyNameCopy,new Blob(key, true));
	
			if (!defaultKeyNames_.Contains(identityName))
				// Copy the identityName.
				ILOG.J2CsMapping.Collections.Collections.Put(defaultKeyNames_,new Name(identityName),keyNameCopy);
		}
	
		/// <summary>
		/// Remove the key with keyName and its related certificates. If the key does
		/// not exist, do nothing.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		public override void removeKey(Name keyName) {
			Name identityName = net.named_data.jndn.security.pib.PibKey.extractIdentityFromKeyName(keyName);
	
			ILOG.J2CsMapping.Collections.Collections.Remove(keys_,keyName);
			ILOG.J2CsMapping.Collections.Collections.Remove(defaultKeyNames_,identityName);
	
			/* foreach */
			foreach (Name certificateName  in  getCertificatesOfKey(keyName))
				removeCertificate(certificateName);
		}
	
		/// <summary>
		/// Get the key bits of a key with name keyName.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <returns>The key bits.</returns>
		/// <exception cref="Pib.Error">if the key does not exist.</exception>
		public override Blob getKeyBits(Name keyName) {
			if (!hasKey(keyName))
				throw new Pib.Error("Key `" + keyName.toUri() + "` not found");
	
			Blob key = ILOG.J2CsMapping.Collections.Collections.Get(keys_,keyName);
			if (key == null)
				// We don't expect this since we just checked hasKey.
				throw new Pib.Error("keyName not found");
			return key;
		}
	
		/// <summary>
		/// Get all the key names of the identity with the name identityName. The
		/// returned key names can be used to create a KeyContainer. With a key name
		/// and a backend implementation, one can create a Key front end instance.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The set of key names. The Name objects are fresh copies. If the
		/// identity does not exist, return an empty set.</returns>
		public override HashedSet<Name> getKeysOfIdentity(Name identityName) {
			HashedSet<Name> ids = new HashedSet<Name>();
			/* foreach */
			foreach (Name keyName  in  new ILOG.J2CsMapping.Collections.ListSet(keys_.Keys)) {
				if (identityName.equals(net.named_data.jndn.security.pib.PibKey.extractIdentityFromKeyName(keyName)))
					// Copy the name.
					ILOG.J2CsMapping.Collections.Collections.Add(ids,new Name(keyName));
			}
	
			return ids;
		}
	
		/// <summary>
		/// Set the key with keyName as the default key for the identity with name
		/// identityName.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity. This copies the name.</param>
		/// <param name="keyName">The name of the key. This copies the name.</param>
		/// <exception cref="Pib.Error">if the key does not exist.</exception>
		public override void setDefaultKeyOfIdentity(Name identityName, Name keyName) {
			if (!hasKey(keyName))
				throw new Pib.Error("Key `" + keyName.toUri() + "` not found");
	
			// Copy the Names.
			ILOG.J2CsMapping.Collections.Collections.Put(defaultKeyNames_,new Name(identityName),new Name(keyName));
		}
	
		/// <summary>
		/// Get the name of the default key for the identity with name identityName.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The name of the default key, as a fresh copy.</returns>
		/// <exception cref="Pib.Error">if there is no default key or if the identity does notexist.</exception>
		public override Name getDefaultKeyOfIdentity(Name identityName) {
			Name defaultKey = ILOG.J2CsMapping.Collections.Collections.Get(defaultKeyNames_,identityName);
			if (defaultKey == null)
				throw new Pib.Error("No default key for identity `"
						+ identityName.toUri() + "`");
	
			// Copy the name.
			return new Name(defaultKey);
		}
	
		// Certificate management.
	
		/// <summary>
		/// Check for the existence of a certificate with name certificateName.
		/// </summary>
		///
		/// <param name="certificateName">The name of the certificate.</param>
		/// <returns>True if the certificate exists, otherwise false.</returns>
		public override bool hasCertificate(Name certificateName) {
			return certificates_.Contains(certificateName);
		}
	
		/// <summary>
		/// Add the certificate. If a certificate with the same name (without implicit
		/// digest) already exists, then overwrite the certificate. If the key or
		/// identity does not exist, they will be created. If no default certificate
		/// for the key has been set, then set the added certificate as the default for
		/// the key. If no default key was set for the identity, it will be set as the
		/// default key for the identity. If no default identity was selected, the
		/// certificate's identity becomes the default.
		/// </summary>
		///
		/// <param name="certificate">The certificate to add. This copies the object.</param>
		public override void addCertificate(CertificateV2 certificate) {
			Name certificateNameCopy = new Name(certificate.getName());
			// getKeyName already makes a new Name.
			Name keyNameCopy = certificate.getKeyName();
			Name identity = certificate.getIdentity();
	
			addKey(identity, keyNameCopy, certificate.getContent().buf());
	
			try {
				ILOG.J2CsMapping.Collections.Collections.Put(certificates_,certificateNameCopy,new CertificateV2(
									certificate));
			} catch (CertificateV2.Error ex) {
				// We don't expect an error in the copy constructor.
				throw new PibImpl.Error(ex.Message);
			}
			if (!defaultCertificateNames_.Contains(keyNameCopy))
				ILOG.J2CsMapping.Collections.Collections.Put(defaultCertificateNames_,keyNameCopy,certificateNameCopy);
		}
	
		/// <summary>
		/// Remove the certificate with name certificateName. If the certificate does
		/// not exist, do nothing.
		/// </summary>
		///
		/// <param name="certificateName">The name of the certificate.</param>
		public override void removeCertificate(Name certificateName) {
			ILOG.J2CsMapping.Collections.Collections.Remove(certificates_,certificateName);
			Name keyName = net.named_data.jndn.security.v2.CertificateV2
					.extractKeyNameFromCertName(certificateName);
			Name defaultCertificateName = ILOG.J2CsMapping.Collections.Collections.Get(defaultCertificateNames_,keyName);
			if (defaultCertificateName != null
					&& defaultCertificateName.equals(certificateName))
				ILOG.J2CsMapping.Collections.Collections.Remove(defaultCertificateNames_,keyName);
		}
	
		/// <summary>
		/// Get the certificate with name certificateName.
		/// </summary>
		///
		/// <param name="certificateName">The name of the certificate.</param>
		/// <returns>A copy of the certificate.</returns>
		/// <exception cref="Pib.Error">if the certificate does not exist.</exception>
		public override CertificateV2 getCertificate(Name certificateName) {
			if (!hasCertificate(certificateName))
				throw new Pib.Error("Certificate `" + certificateName.toUri()
						+ "` does not exist");
	
			try {
				return new CertificateV2(ILOG.J2CsMapping.Collections.Collections.Get(certificates_,certificateName));
			} catch (CertificateV2.Error ex) {
				// We don't expect an error in the copy constructor.
				throw new PibImpl.Error(ex.Message);
			}
		}
	
		/// <summary>
		/// Get a list of certificate names of the key with id keyName. The returned
		/// certificate names can be used to create a PibCertificateContainer. With a
		/// certificate name and a backend implementation, one can obtain the
		/// certificate.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <returns>The set of certificate names. The Name objects are fresh copies. If
		/// the key does not exist, return an empty set.</returns>
		public override HashedSet<Name> getCertificatesOfKey(Name keyName) {
			HashedSet<Name> certificateNames = new HashedSet<Name>();
			/* foreach */
			foreach (Name certificateName  in  new ILOG.J2CsMapping.Collections.ListSet(certificates_.Keys)) {
				if (net.named_data.jndn.security.v2.CertificateV2.extractKeyNameFromCertName(
						ILOG.J2CsMapping.Collections.Collections.Get(certificates_,certificateName).getName()).equals(
						keyName))
					// Copy the Name.
					ILOG.J2CsMapping.Collections.Collections.Add(certificateNames,new Name(certificateName));
			}
	
			return certificateNames;
		}
	
		/// <summary>
		/// Set the cert with name certificateName as the default for the key with
		/// keyName.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <param name="certificateName">The name of the certificate. This copies the name.</param>
		/// <exception cref="Pib.Error">if the certificate with name certificateName does notexist.</exception>
		public override void setDefaultCertificateOfKey(Name keyName, Name certificateName) {
			if (!hasCertificate(certificateName))
				throw new Pib.Error("Certificate `" + certificateName.toUri()
						+ "` does not exist");
	
			// Copy the Names.
			ILOG.J2CsMapping.Collections.Collections.Put(defaultCertificateNames_,new Name(keyName),new Name(
							certificateName));
		}
	
		/// <summary>
		/// Get the default certificate for the key with eyName.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <returns>A copy of the default certificate.</returns>
		/// <exception cref="Pib.Error">if the default certificate does not exist.</exception>
		public override CertificateV2 getDefaultCertificateOfKey(Name keyName) {
			Name certificateName = ILOG.J2CsMapping.Collections.Collections.Get(defaultCertificateNames_,keyName);
			if (certificateName == null)
				throw new Pib.Error("No default certificate for key `"
						+ keyName.toUri() + "`");
	
			CertificateV2 certificate = ILOG.J2CsMapping.Collections.Collections.Get(certificates_,certificateName);
			if (certificate == null)
				// We don't expect this since we just checked defaultCertificateNames_.
				throw new Pib.Error("certificate not found");
			try {
				return new CertificateV2(certificate);
			} catch (CertificateV2.Error ex) {
				// We don't expect an error in the copy constructor.
				throw new PibImpl.Error(ex.Message);
			}
		}
	
		private String tpmLocator_;
	
		private Name defaultIdentityName_;
	
		private readonly HashedSet<Name> identityNames_;
	
		// identity => default key Name.
		private readonly Hashtable<Name, Name> defaultKeyNames_;
	
		// keyName => keyBits.
		private readonly Hashtable<Name, Blob> keys_;
	
		// keyName => default certificate Name.
		private readonly Hashtable<Name, Name> defaultCertificateNames_;
	
		// certificate Name => certificate.
		private readonly Hashtable<Name, CertificateV2> certificates_;
	}
}
