// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security.pib {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using java.awt;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.security.v2;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// AndroidSqlite3Pib extends PibImpl and is used by the Pib class as an
	/// implementation of a PIB using the android.database.sqlite API. All the
	/// contents in the PIB are stored in an SQLite3 database file. This provides
	/// more persistent storage than PibMemory.
	/// </summary>
	///
	public class AndroidSqlite3Pib : PibSqlite3Base {
		/// <summary>
		/// Create a new AndroidSqlite3Pib to work with an SQLite3 file. This assumes
		/// that the database directory does not contain a PIB database of an older
		/// version.
		/// </summary>
		///
		/// <param name="databaseDirectoryPath">context.getFilesDir() .</param>
		/// <param name="databaseFilename"></param>
		/// <exception cref="PibImpl.Error">if initialization fails.</exception>
		public AndroidSqlite3Pib(String databaseDirectoryPath,
				String databaseFilename) {
			construct(databaseDirectoryPath, databaseFilename);
		}
	
		/// <summary>
		/// Create a new AndroidSqlite3Pib to work with an SQLite3 file. This assumes
		/// that the database directory does not contain a PIB database of an older
		/// version. Use "pib.db" for the databaseFilename in the databaseDirectoryPath.
		/// </summary>
		///
		/// <param name="databaseDirectoryPath">context.getFilesDir() .</param>
		/// <exception cref="PibImpl.Error">if initialization fails.</exception>
		public AndroidSqlite3Pib(String databaseDirectoryPath) {
			construct(databaseDirectoryPath, "pib.db");
		}
	
		private void construct(String databaseDirectoryPath, String databaseFilename) {
			System.IO.Directory.CreateDirectory(new FileInfo(databaseDirectoryPath).FullName);
	
			FileInfo databaseFilePath = new FileInfo(databaseDirectoryPath+databaseFilename);
			database_ = SQLiteDatabase.OpenDatabase(
					databaseFilePath.FullName, null,
					SQLiteDatabase.OPEN_READWRITE
							| SQLiteDatabase.CREATE_IF_NECESSARY);
	
			// Initialize the PIB tables.
			database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.INITIALIZATION1);
			database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.INITIALIZATION2);
			database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.INITIALIZATION3);
			database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.INITIALIZATION4);
			database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.INITIALIZATION5);
			database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.INITIALIZATION6);
			database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.INITIALIZATION7);
		}
	
		public static String getScheme() {
			return "pib-sqlite3";
		}
	
		// TpmLocator management.
	
		/// <summary>
		/// Set the corresponding TPM information to tpmLocator. This method does not
		/// reset the contents of the PIB.
		/// </summary>
		///
		/// <param name="tpmLocator">The TPM locator string.</param>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override void setTpmLocator(String tpmLocator) {
			if (getTpmLocator().equals("")) {
				// The tpmLocator does not exist. Insert it directly.
				ContentValues values = new ContentValues();
				values.Put("tpm_locator", tpmLocator);
				if (database_.Insert("tpmInfo", null, values) < 0)
					throw new PibImpl.Error("AndroidSqlite3Pib: SQLite error");
			} else {
				// Update the existing tpmLocator.
				ContentValues values = new ContentValues();
				values.Put("tpm_locator", tpmLocator);
				database_.Update("tpmInfo", values, null, null);
			}
		}
	
		/// <summary>
		/// Get the TPM Locator.
		/// </summary>
		///
		/// <returns>The TPM locator string.</returns>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override String getTpmLocator() {
			Cursor cursor = database_.RawQuery(net.named_data.jndn.security.pib.PibSqlite3Base.SELECT_getTpmLocator, null);
	
			try {
				if (cursor.MoveToNext())
					return cursor.GetString(0);
				else
					return "";
			} finally {
				cursor.Close();
			}
		}
	
		// Identity management.
	
		/// <summary>
		/// Check for the existence of an identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>True if the identity exists, otherwise false.</returns>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override bool hasIdentity(Name identityName) {
			// Use a statement because it allows binding a blob for the query.
			SQLiteStatement statement = database_
					.CompileStatement(net.named_data.jndn.security.pib.PibSqlite3Base.SELECT_hasIdentity);
			try {
				statement
						.BindBlob(1, identityName.wireEncode().getImmutableArray());
				try {
					statement.SimpleQueryForLong();
					return true;
				} catch (SQLiteDoneException ex) {
					// No match.
					return false;
				}
			} finally {
				statement.Close();
			}
		}
	
		/// <summary>
		/// Add the identity. If the identity already exists, do nothing. If no default
		/// identity has been set, set the added identity as the default.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity to add. This copies the name.</param>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override void addIdentity(Name identityName) {
			if (!hasIdentity(identityName)) {
				ContentValues values = new ContentValues();
				values.Put("identity", identityName.wireEncode()
						.getImmutableArray());
				if (database_.Insert("identities", null, values) < 0)
					throw new PibImpl.Error("AndroidSqlite3Pib: SQLite error");
			}
	
			if (!hasDefaultIdentity())
				setDefaultIdentity(identityName);
		}
	
		/// <summary>
		/// Remove the identity and its related keys and certificates. If the default
		/// identity is being removed, no default identity will be selected.  If the
		/// identity does not exist, do nothing.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity to remove.</param>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override void removeIdentity(Name identityName) {
			byte[] identityBytes = identityName.wireEncode().getImmutableArray();
	
			// We don't use triggers, so manually delete from keys and certificates.
			// First get the key ids.
			ArrayList<Int32> keyIds = new ArrayList<Int32>();
	
			// Use a hex literal instead of the ending '?' since rawQuery doesn't allow
			// binding a blob.
			Cursor cursor = database_.RawQuery(
					net.named_data.jndn.security.pib.PibSqlite3Base.SELECT_removeIdentity.Substring(0,(net.named_data.jndn.security.pib.PibSqlite3Base.SELECT_removeIdentity.Length - 1)-(0))
							+ "x'" + identityName.wireEncode().toHex() + "'", null);
	
			try {
				while (cursor.MoveToNext())
					ILOG.J2CsMapping.Collections.Collections.Add(keyIds,cursor.GetInt(0));
			} finally {
				cursor.Close();
			}
	
			/* foreach */
			foreach (int keyId  in  keyIds)
				database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.DELETE_removeIdentity_certificates,
						new Object[] { keyId });
	
			/* foreach */
			foreach (int keyId  in  keyIds)
				database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.DELETE_removeIdentity_keys,
						new Object[] { keyId });
	
			// Now, delete from identities.
			database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.DELETE_removeIdentity_identity,
					new Object[] { identityBytes });
		}
	
		/// <summary>
		/// Erase all certificates, keys, and identities.
		/// </summary>
		///
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override void clearIdentities() {
			// We don't use triggers, so manually delete from keys and certificates.
			database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.DELETE_clearIdentities_certificates, new Object[0]);
			database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.DELETE_clearIdentities_keys, new Object[0]);
	
			// Now, delete from identities.
			database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.DELETE_clearIdentities_identities, new Object[0]);
		}
	
		/// <summary>
		/// Get the names of all the identities.
		/// </summary>
		///
		/// <returns>The set of identity names. The Name objects are fresh copies.</returns>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override HashedSet<Name> getIdentities() {
			HashedSet<Name> identityNames = new HashedSet<Name>();
	
			Cursor cursor = database_.RawQuery(net.named_data.jndn.security.pib.PibSqlite3Base.SELECT_getIdentities, null);
	
			try {
				while (cursor.MoveToNext()) {
					Name name = new Name();
					try {
						name.wireDecode(new Blob(cursor.GetBlob(0)));
					} catch (EncodingException ex) {
						throw new PibImpl.Error("PibSqlite3: Error decoding name: "
								+ ex);
					}
					ILOG.J2CsMapping.Collections.Collections.Add(identityNames,name);
				}
			} finally {
				cursor.Close();
			}
	
			return identityNames;
		}
	
		/// <summary>
		/// Set the identity with the identityName as the default identity. If the
		/// identity with identityName does not exist, then it will be created.
		/// </summary>
		///
		/// <param name="identityName">The name for the default identity. This copies the name.</param>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override void setDefaultIdentity(Name identityName) {
			byte[] identityBytes = identityName.wireEncode().getImmutableArray();
	
			if (!hasIdentity(identityName)) {
				ContentValues values = new ContentValues();
				values.Put("identity", identityBytes);
				if (database_.Insert("identities", null, values) < 0)
					throw new PibImpl.Error("AndroidSqlite3Pib: SQLite error");
			}
	
			// We don't use a trigger, so manually reset the previous default identity.
			database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.UPDATE_setDefaultIdentity_reset, new Object[0]);
	
			// Now set the current default identity.
			// Use a statement because it allows binding a blob for the where clause.
			SQLiteStatement statement = database_
					.CompileStatement(net.named_data.jndn.security.pib.PibSqlite3Base.UPDATE_setDefaultIdentity_set);
			try {
				statement.BindBlob(1, identityBytes);
				if (statement.ExecuteUpdateDelete() <= 0)
					throw new PibImpl.Error("AndroidSqlite3Pib: SQLite error");
			} finally {
				statement.Close();
			}
		}
	
		/// <summary>
		/// Get the default identity.
		/// </summary>
		///
		/// <returns>The name of the default identity, as a fresh copy.</returns>
		/// <exception cref="Pib.Error">for no default identity.</exception>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override Name getDefaultIdentity() {
			Cursor cursor = database_.RawQuery(net.named_data.jndn.security.pib.PibSqlite3Base.SELECT_getDefaultIdentity, null);
	
			Name name = new Name();
			try {
				if (cursor.MoveToNext()) {
					try {
						name.wireDecode(new Blob(cursor.GetBlob(0)));
					} catch (EncodingException ex) {
						throw new PibImpl.Error("PibSqlite3: Error decoding name: "
								+ ex);
					}
				} else
					throw new Pib.Error("No default identity");
			} finally {
				cursor.Close();
			}
	
			return name;
		}
	
		// Key management.
	
		/// <summary>
		/// Check for the existence of a key with keyName.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <returns>True if the key exists, otherwise false. Return false if the
		/// identity does not exist.</returns>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override bool hasKey(Name keyName) {
			// Use a statement because it allows binding a blob for the query.
			SQLiteStatement statement = database_.CompileStatement(net.named_data.jndn.security.pib.PibSqlite3Base.SELECT_hasKey);
			try {
				statement.BindBlob(1, keyName.wireEncode().getImmutableArray());
				try {
					statement.SimpleQueryForLong();
					return true;
				} catch (SQLiteDoneException ex) {
					// No match.
					return false;
				}
			} finally {
				statement.Close();
			}
		}
	
		/// <summary>
		/// Add the key. If a key with the same name already exists, overwrite the key.
		/// If the identity does not exist, it will be created. If no default key for
		/// the identity has been set, then set the added key as the default for the
		/// identity.  If no default identity has been set, identity becomes the
		/// default.
		/// </summary>
		///
		/// <param name="identityName"></param>
		/// <param name="keyName">The name of the key. This copies the name.</param>
		/// <param name="key">The public key bits. This copies the array.</param>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override void addKey(Name identityName, Name keyName, ByteBuffer key) {
			// Ensure the identity exists.
			addIdentity(identityName);
	
			if (!hasKey(keyName)) {
				// Use a statement because it allows binding a blob for the where clause.
				SQLiteStatement statement = database_
						.CompileStatement(net.named_data.jndn.security.pib.PibSqlite3Base.INSERT_addKey);
				try {
					statement.BindBlob(1, identityName.wireEncode()
							.getImmutableArray());
					statement.BindBlob(2, keyName.wireEncode().getImmutableArray());
					statement.BindBlob(3, new Blob(key, false).getImmutableArray());
					if (statement.ExecuteUpdateDelete() <= 0)
						throw new PibImpl.Error("AndroidSqlite3Pib: SQLite error");
				} finally {
					statement.Close();
				}
			} else {
				// Use a statement because it allows binding a blob for the where clause.
				SQLiteStatement statement = database_
						.CompileStatement(net.named_data.jndn.security.pib.PibSqlite3Base.UPDATE_addKey);
				try {
					statement.BindBlob(1, new Blob(key, false).getImmutableArray());
					statement.BindBlob(2, keyName.wireEncode().getImmutableArray());
					if (statement.ExecuteUpdateDelete() <= 0)
						throw new PibImpl.Error("AndroidSqlite3Pib: SQLite error");
				} finally {
					statement.Close();
				}
			}
	
			if (!hasDefaultKeyOfIdentity(identityName)) {
				try {
					setDefaultKeyOfIdentity(identityName, keyName);
				} catch (Pib.Error ex) {
					throw new PibImpl.Error(
							"PibSqlite3: Error setting the default key: " + ex);
				}
			}
		}
	
		/// <summary>
		/// Remove the key with keyName and its related certificates. If the key does
		/// not exist, do nothing.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override void removeKey(Name keyName) {
			byte[] keyNameBytes = keyName.wireEncode().getImmutableArray();
	
			// We don't use triggers, so manually delete from certificates.
			database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.DELETE_removeKey_certificates,
					new Object[] { keyNameBytes });
	
			// Now, delete from keys.
			database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.DELETE_removeKey_keys, new Object[] { keyNameBytes });
		}
	
		/// <summary>
		/// Get the key bits of a key with name keyName.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <returns>The key bits.</returns>
		/// <exception cref="Pib.Error">if the key does not exist.</exception>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override Blob getKeyBits(Name keyName) {
			// First use a statement to get the key ID because the statement allows
			// binding a blob for the query.
			long keyId;
			SQLiteStatement statement = database_
					.CompileStatement("SELECT keys.id " + net.named_data.jndn.security.pib.PibSqlite3Base.FROM_WHERE_getKeyBits);
			try {
				statement.BindBlob(1, keyName.wireEncode().getImmutableArray());
				try {
					keyId = statement.SimpleQueryForLong();
				} catch (SQLiteDoneException ex) {
					throw new Pib.Error("Key `" + keyName.toUri()
							+ "` does not exist");
				}
			} finally {
				statement.Close();
			}
	
			// Now use the keyId to get the key.
			Cursor cursor = database_.RawQuery(
					"SELECT key_bits FROM keys WHERE id=?",
					new String[] { keyId.ToString() });
			try {
				if (cursor.MoveToNext())
					return new Blob(cursor.GetBlob(0));
				else
					// We don't expect this since we got the keyId.
					throw new Pib.Error("Key `" + keyName.toUri()
							+ "` does not exist");
			} finally {
				cursor.Close();
			}
		}
	
		/// <summary>
		/// Get all the key names of the identity with the name identityName. The
		/// returned key names can be used to create a KeyContainer. With a key name
		/// and a backend implementation, one can create a Key front end instance.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The set of key names. The Name objects are fresh copies. If the
		/// identity does not exist, return an empty set.</returns>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override HashedSet<Name> getKeysOfIdentity(Name identityName) {
			HashedSet<Name> keyNames = new HashedSet<Name>();
	
			// Use a hex literal instead of the ending '?' since rawQuery doesn't allow
			// binding a blob.
			Cursor cursor = database_.RawQuery(
					net.named_data.jndn.security.pib.PibSqlite3Base.SELECT_getKeysOfIdentity.Substring(0,(net.named_data.jndn.security.pib.PibSqlite3Base.SELECT_getKeysOfIdentity.Length - 1)-(0))
							+ "x'" + identityName.wireEncode().toHex() + "'", null);
	
			try {
				while (cursor.MoveToNext()) {
					Name name = new Name();
					try {
						name.wireDecode(new Blob(cursor.GetBlob(0)));
					} catch (EncodingException ex) {
						throw new PibImpl.Error("PibSqlite3: Error decoding name: "
								+ ex);
					}
					ILOG.J2CsMapping.Collections.Collections.Add(keyNames,name);
				}
			} finally {
				cursor.Close();
			}
	
			return keyNames;
		}
	
		/// <summary>
		/// Set the key with keyName as the default key for the identity with name
		/// identityName.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity. This copies the name.</param>
		/// <param name="keyName">The name of the key. This copies the name.</param>
		/// <exception cref="Pib.Error">if the key does not exist.</exception>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override void setDefaultKeyOfIdentity(Name identityName, Name keyName) {
			if (!hasKey(keyName))
				throw new Pib.Error("Key `" + keyName.toUri() + "` does not exist");
	
			// We don't use a trigger, so manually reset the previous default key.
			database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.UPDATE_setDefaultKeyOfIdentity_reset, new Object[0]);
	
			// Now set the current default identity.
			// Use a statement because it allows binding a blob for the where clause.
			SQLiteStatement statement = database_
					.CompileStatement(net.named_data.jndn.security.pib.PibSqlite3Base.UPDATE_setDefaultKeyOfIdentity_set);
			try {
				statement.BindBlob(1, keyName.wireEncode().getImmutableArray());
				if (statement.ExecuteUpdateDelete() <= 0)
					throw new PibImpl.Error("AndroidSqlite3Pib: SQLite error");
			} finally {
				statement.Close();
			}
		}
	
		/// <summary>
		/// Get the name of the default key for the identity with name identityName.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The name of the default key, as a fresh copy.</returns>
		/// <exception cref="Pib.Error">if there is no default key or if the identity does notexist.</exception>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override Name getDefaultKeyOfIdentity(Name identityName) {
			if (!hasIdentity(identityName))
				throw new Pib.Error("Identity `" + identityName.toUri()
						+ "` does not exist");
	
			// First use a statement to get the key ID because the statement allows
			// binding a blob for the query.
			long keyId;
			SQLiteStatement statement = database_
					.CompileStatement("SELECT keys.id "
							+ net.named_data.jndn.security.pib.PibSqlite3Base.FROM_WHERE_getDefaultKeyOfIdentity);
			try {
				statement
						.BindBlob(1, identityName.wireEncode().getImmutableArray());
				try {
					keyId = statement.SimpleQueryForLong();
				} catch (SQLiteDoneException ex) {
					throw new Pib.Error("No default key for identity `"
							+ identityName.toUri() + "`");
				}
			} finally {
				statement.Close();
			}
	
			// Now use the keyId to get the key name.
			Cursor cursor = database_.RawQuery(
					"SELECT key_name FROM keys WHERE id=?",
					new String[] { keyId.ToString() });
			try {
				if (cursor.MoveToNext()) {
					Name name = new Name();
					try {
						name.wireDecode(new Blob(cursor.GetBlob(0)));
					} catch (EncodingException ex) {
						throw new PibImpl.Error("PibSqlite3: Error decoding name: "
								+ ex);
					}
					return name;
				} else
					// We don't expect this since we got the keyId.
					throw new Pib.Error("No default key for identity `"
							+ identityName.toUri() + "`");
			} finally {
				cursor.Close();
			}
		}
	
		// Certificate management.
	
		/// <summary>
		/// Check for the existence of a certificate with name certificateName.
		/// </summary>
		///
		/// <param name="certificateName">The name of the certificate.</param>
		/// <returns>True if the certificate exists, otherwise false.</returns>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override bool hasCertificate(Name certificateName) {
			// Use a statement because it allows binding a blob for the query.
			SQLiteStatement statement = database_
					.CompileStatement(net.named_data.jndn.security.pib.PibSqlite3Base.SELECT_hasCertificate);
			try {
				statement.BindBlob(1, certificateName.wireEncode()
						.getImmutableArray());
				try {
					statement.SimpleQueryForLong();
					return true;
				} catch (SQLiteDoneException ex) {
					// No match.
					return false;
				}
			} finally {
				statement.Close();
			}
		}
	
		/// <summary>
		/// Add the certificate. If a certificate with the same name (without implicit
		/// digest) already exists, then overwrite the certificate. If the key or
		/// identity does not exist, they will be created. If no default certificate
		/// for the key has been set, then set the added certificate as the default for
		/// the key. If no default key was set for the identity, it will be set as the
		/// default key for the identity. If no default identity was selected, the
		/// certificate's identity becomes the default.
		/// </summary>
		///
		/// <param name="certificate">The certificate to add. This copies the object.</param>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override void addCertificate(CertificateV2 certificate) {
			// Ensure the key exists.
			Blob content = certificate.getContent();
			addKey(certificate.getIdentity(), certificate.getKeyName(),
					content.buf());
	
			if (!hasCertificate(certificate.getName())) {
				// Use a statement because it allows binding a blob for the where clause.
				SQLiteStatement statement = database_
						.CompileStatement(net.named_data.jndn.security.pib.PibSqlite3Base.INSERT_addCertificate);
				try {
					statement.BindBlob(1, certificate.getKeyName().wireEncode()
							.getImmutableArray());
					statement.BindBlob(2, certificate.getName().wireEncode()
							.getImmutableArray());
					statement.BindBlob(3, certificate.wireEncode()
							.getImmutableArray());
					if (statement.ExecuteUpdateDelete() <= 0)
						throw new PibImpl.Error("AndroidSqlite3Pib: SQLite error");
				} finally {
					statement.Close();
				}
			} else {
				// Use a statement because it allows binding a blob for the where clause.
				SQLiteStatement statement = database_
						.CompileStatement(net.named_data.jndn.security.pib.PibSqlite3Base.UPDATE_addCertificate);
				try {
					statement.BindBlob(1, certificate.wireEncode()
							.getImmutableArray());
					statement.BindBlob(2, certificate.getName().wireEncode()
							.getImmutableArray());
					if (statement.ExecuteUpdateDelete() <= 0)
						throw new PibImpl.Error("AndroidSqlite3Pib: SQLite error");
				} finally {
					statement.Close();
				}
			}
	
			if (!hasDefaultCertificateOfKey(certificate.getKeyName())) {
				try {
					setDefaultCertificateOfKey(certificate.getKeyName(),
							certificate.getName());
				} catch (Pib.Error ex) {
					throw new PibImpl.Error(
							"PibSqlite3: Error setting the default certificate: "
									+ ex);
				}
			}
		}
	
		/// <summary>
		/// Remove the certificate with name certificateName. If the certificate does
		/// not exist, do nothing.
		/// </summary>
		///
		/// <param name="certificateName">The name of the certificate.</param>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override void removeCertificate(Name certificateName) {
			database_
					.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.DELETE_removeCertificate,
							new Object[] { certificateName.wireEncode()
									.getImmutableArray() });
		}
	
		/// <summary>
		/// Get the certificate with name certificateName.
		/// </summary>
		///
		/// <param name="certificateName">The name of the certificate.</param>
		/// <returns>A copy of the certificate.</returns>
		/// <exception cref="Pib.Error">if the certificate does not exist.</exception>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override CertificateV2 getCertificate(Name certificateName) {
			// First use a statement to get the certificate ID because the statement
			// allows binding a blob for the query.
			long certificateId;
			SQLiteStatement statement = database_
					.CompileStatement("SELECT certificates.id FROM certificates WHERE certificate_name=?");
			try {
				statement.BindBlob(1, certificateName.wireEncode()
						.getImmutableArray());
				try {
					certificateId = statement.SimpleQueryForLong();
				} catch (SQLiteDoneException ex) {
					throw new Pib.Error("Certificate `" + certificateName.toUri()
							+ "` does not exit");
				}
			} finally {
				statement.Close();
			}
	
			// Now use the certificateId to get the certicicate.
			Cursor cursor = database_.RawQuery(
					"SELECT certificate_data FROM certificates WHERE id=?",
					new String[] { certificateId.ToString() });
			try {
				if (cursor.MoveToNext()) {
					CertificateV2 certificate = new CertificateV2();
					try {
						certificate.wireDecode(new Blob(cursor.GetBlob(0)));
					} catch (EncodingException ex) {
						throw new PibImpl.Error(
								"PibSqlite3: Error decoding certificate: " + ex);
					}
					return certificate;
				} else
					// We don't expect this since we got the certificateId.
					throw new Pib.Error("Certificate `" + certificateName.toUri()
							+ "` does not exit");
			} finally {
				cursor.Close();
			}
		}
	
		/// <summary>
		/// Get a list of certificate names of the key with id keyName. The returned
		/// certificate names can be used to create a CertificateContainer. With a
		/// certificate name and a backend implementation, one can obtain the
		/// certificate.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <returns>The set of certificate names. The Name objects are fresh copies. If
		/// the key does not exist, return an empty set.</returns>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override HashedSet<Name> getCertificatesOfKey(Name keyName) {
			HashedSet<Name> certNames = new HashedSet<Name>();
	
			// Use a hex literal instead of the ending '?' since rawQuery doesn't allow
			// binding a blob.
			Cursor cursor = database_.RawQuery(
					net.named_data.jndn.security.pib.PibSqlite3Base.SELECT_getCertificatesOfKey.Substring(0,(net.named_data.jndn.security.pib.PibSqlite3Base.SELECT_getCertificatesOfKey.Length - 1)-(0))
							+ "x'"
							+ keyName.wireEncode().toHex() + "'", null);
	
			try {
				while (cursor.MoveToNext()) {
					Name name = new Name();
					try {
						name.wireDecode(new Blob(cursor.GetBlob(0)));
					} catch (EncodingException ex) {
						throw new PibImpl.Error("PibSqlite3: Error decoding name: "
								+ ex);
					}
					ILOG.J2CsMapping.Collections.Collections.Add(certNames,name);
				}
			} finally {
				cursor.Close();
			}
	
			return certNames;
		}
	
		/// <summary>
		/// Set the cert with name certificateName as the default for the key with
		/// keyName.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <param name="certificateName">The name of the certificate. This copies the name.</param>
		/// <exception cref="Pib.Error">if the certificate with name certificateName does notexist.</exception>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override void setDefaultCertificateOfKey(Name keyName, Name certificateName) {
			if (!hasCertificate(certificateName))
				throw new Pib.Error("Certificate `" + certificateName.toUri()
						+ "` does not exist");
	
			// We don't use a trigger, so manually reset the previous default certificate.
			database_.ExecSQL(net.named_data.jndn.security.pib.PibSqlite3Base.UPDATE_setDefaultCertificateOfKey_reset,
					new Object[0]);
	
			// Now set the current default identity.
			// Use a statement because it allows binding a blob for the where clause.
			SQLiteStatement statement = database_
					.CompileStatement(net.named_data.jndn.security.pib.PibSqlite3Base.UPDATE_setDefaultCertificateOfKey_set);
			try {
				statement.BindBlob(1, certificateName.wireEncode()
						.getImmutableArray());
				if (statement.ExecuteUpdateDelete() <= 0)
					throw new PibImpl.Error("AndroidSqlite3Pib: SQLite error");
			} finally {
				statement.Close();
			}
		}
	
		/// <summary>
		/// Get the default certificate for the key with eyName.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <returns>A copy of the default certificate.</returns>
		/// <exception cref="Pib.Error">if the default certificate does not exist.</exception>
		/// <exception cref="PibImpl.Error">for a non-semantic (database access) error.</exception>
		public override CertificateV2 getDefaultCertificateOfKey(Name keyName) {
			// First use a statement to get the certificate ID because the statement allows
			// binding a blob for the query.
			long certificateId;
			SQLiteStatement statement = database_
					.CompileStatement("SELECT certificates.id "
							+ net.named_data.jndn.security.pib.PibSqlite3Base.FROM_WHERE_getDefaultCertificateOfKey);
			try {
				statement.BindBlob(1, keyName.wireEncode().getImmutableArray());
				try {
					certificateId = statement.SimpleQueryForLong();
				} catch (SQLiteDoneException ex) {
					throw new Pib.Error("No default certificate for key `"
							+ keyName.toUri() + "`");
				}
			} finally {
				statement.Close();
			}
	
			// Now use the certificateId to get the key name.
			Cursor cursor = database_.RawQuery(
					"SELECT certificate_data FROM certificates WHERE id=?",
					new String[] { certificateId.ToString() });
			try {
				if (cursor.MoveToNext()) {
					CertificateV2 certificate = new CertificateV2();
					try {
						certificate.wireDecode(new Blob(cursor.GetBlob(0)));
					} catch (EncodingException ex) {
						throw new PibImpl.Error(
								"PibSqlite3: Error decoding certificate: " + ex);
					}
					return certificate;
				} else
					// We don't expect this since we got the certificateId.
					throw new Pib.Error("No default certificate for key `"
							+ keyName.toUri() + "`");
			} finally {
				cursor.Close();
			}
		}
	
		private bool hasDefaultIdentity() {
			// Use a statement because it allows binding a blob for the query.
			SQLiteStatement statement = database_
					.CompileStatement(net.named_data.jndn.security.pib.PibSqlite3Base.SELECT_hasDefaultIdentity);
			try {
				try {
					statement.SimpleQueryForLong();
					return true;
				} catch (SQLiteDoneException ex) {
					// No match.
					return false;
				}
			} finally {
				statement.Close();
			}
		}
	
		private bool hasDefaultKeyOfIdentity(Name identityName) {
			// Use a statement because it allows binding a blob for the query.
			SQLiteStatement statement = database_
					.CompileStatement(net.named_data.jndn.security.pib.PibSqlite3Base.SELECT_hasDefaultKeyOfIdentity);
			try {
				statement
						.BindBlob(1, identityName.wireEncode().getImmutableArray());
				try {
					statement.SimpleQueryForLong();
					return true;
				} catch (SQLiteDoneException ex) {
					// No match.
					return false;
				}
			} finally {
				statement.Close();
			}
		}
	
		private bool hasDefaultCertificateOfKey(Name keyName) {
			// Use a statement because it allows binding a blob for the query.
			SQLiteStatement statement = database_
					.CompileStatement(net.named_data.jndn.security.pib.PibSqlite3Base.SELECT_hasDefaultCertificateOfKey);
			try {
				statement.BindBlob(1, keyName.wireEncode().getImmutableArray());
				try {
					statement.SimpleQueryForLong();
					return true;
				} catch (SQLiteDoneException ex) {
					// No match.
					return false;
				}
			} finally {
				statement.Close();
			}
		}
	
		private SQLiteDatabase database_;
	}
}
