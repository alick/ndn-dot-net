// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017-2018 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security.v2.validator_config {
	
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.security;
	using net.named_data.jndn.security.v2;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// A ConfigRule represents a rule configuration section, used by ConfigValidator.
	/// </summary>
	///
	public class ConfigRule {
		/// <summary>
		/// Create a ConfigRule with empty filters and checkers.
		/// </summary>
		///
		/// <param name="id">The rule ID from the configuration section.</param>
		/// <param name="isForInterest"></param>
		public ConfigRule(String id, bool isForInterest) {
			this.filters_ = new ArrayList<ConfigFilter>();
			this.checkers_ = new ArrayList<ConfigChecker>();
			id_ = id;
			isForInterest_ = isForInterest;
		}
	
		/// <summary>
		/// Get the rule ID.
		/// </summary>
		///
		/// <returns>The rule ID.</returns>
		public String getId() {
			return id_;
		}
	
		/// <summary>
		/// Get the isForInterest flag.
		/// </summary>
		///
		/// <returns>True if the rule is for an Interest packet, false if it is for a
		/// Data packet.</returns>
		public bool getIsForInterest() {
			return isForInterest_;
		}
	
		/// <summary>
		/// Add the ConfigFilter to the list of filters.
		/// </summary>
		///
		/// <param name="filter">The ConfigFilter.</param>
		public void addFilter(ConfigFilter filter) {
			ILOG.J2CsMapping.Collections.Collections.Add(filters_,filter);
		}
	
		/// <summary>
		/// Add the ConfigChecker to the list of checkers.
		/// </summary>
		///
		/// <param name="checker">The ConfigChecker.</param>
		public void addChecker(ConfigChecker checker) {
			ILOG.J2CsMapping.Collections.Collections.Add(checkers_,checker);
		}
	
		/// <summary>
		/// Check if the packet name matches the rule's filter.
		/// If no filters were added, the rule matches everything.
		/// </summary>
		///
		/// <param name="isForInterest"></param>
		/// <param name="packetName"></param>
		/// <returns>True if at least one filter matches the packet name, false if none
		/// of the filters match the packet name.</returns>
		/// <exception cref="ValidatorConfigError">if the supplied isForInterest doesn't match theone for which the rule is designed.</exception>
		public bool match(bool isForInterest, Name packetName) {
			logger_.log(ILOG.J2CsMapping.Util.Logging.Level.FINE, "Trying to match {0}", packetName.toUri());
	
			if (isForInterest != isForInterest_)
				throw new ValidatorConfigError("Invalid packet type supplied ( "
						+ ((isForInterest) ? "interest" : "data") + " != "
						+ ((isForInterest_) ? "interest" : "data") + ")");
	
			if (filters_.Count == 0)
				return true;
	
			bool result = false;
			for (int i = 0; i < filters_.Count; ++i) {
				result = (result || filters_[i]
						.match(isForInterest, packetName));
				if (result)
					break;
			}
	
			return result;
		}
	
		/// <summary>
		/// Check if the packet satisfies the rule's condition.
		/// </summary>
		///
		/// <param name="isForInterest"></param>
		/// <param name="packetName"></param>
		/// <param name="keyLocatorName">The KeyLocator's name.</param>
		/// <param name="state">This calls state.fail() if the packet is invalid.</param>
		/// <returns>True if further signature verification is needed, or false if the
		/// packet is immediately determined to be invalid in which case this calls
		/// state.fail() with the proper code and message.</returns>
		/// <exception cref="ValidatorConfigError">if the supplied isForInterest doesn't match theone for which the rule is designed.</exception>
		public bool check(bool isForInterest, Name packetName,
				Name keyLocatorName, ValidationState state) {
			logger_.log(ILOG.J2CsMapping.Util.Logging.Level.FINE, "Trying to check {0} with keyLocator {1}",
					new Object[] { packetName.toUri(), keyLocatorName.toUri() });
	
			if (isForInterest != isForInterest_)
				throw new ValidatorConfigError("Invalid packet type supplied ( "
						+ ((isForInterest) ? "interest" : "data") + " != "
						+ ((isForInterest_) ? "interest" : "data") + ")");
	
			bool hasPendingResult = false;
			for (int i = 0; i < checkers_.Count; ++i) {
				bool result = checkers_[i].check(isForInterest, packetName,
						keyLocatorName, state);
				if (!result)
					return result;
				hasPendingResult = true;
			}
	
			return hasPendingResult;
		}
	
		/// <summary>
		/// Create a rule from configuration section.
		/// </summary>
		///
		/// <param name="configSection"></param>
		/// <returns>A new ConfigRule created from the configuration</returns>
		public static ConfigRule create(BoostInfoTree configSection) {
			// Get rule.id .
			String ruleId = configSection.getFirstValue("id");
			if (ruleId == null)
				throw new ValidatorConfigError("Expecting <rule.id>");
	
			// Get rule.for .
			String usage = configSection.getFirstValue("for");
			if (usage == null)
				throw new ValidatorConfigError("Expecting <rule.for> in rule: "
						+ ruleId);
	
			bool isForInterest;
			if (usage.Equals("data",StringComparison.InvariantCultureIgnoreCase))
				isForInterest = false;
			else if (usage.Equals("interest",StringComparison.InvariantCultureIgnoreCase))
				isForInterest = true;
			else
				throw new ValidatorConfigError("Unrecognized <rule.for>: " + usage
						+ " in rule: " + ruleId);
	
			ConfigRule rule = new ConfigRule(ruleId, isForInterest);
	
			// Get rule.filter(s)
			ArrayList<BoostInfoTree> filterList = configSection.get("filter");
			for (int i = 0; i < filterList.Count; ++i)
				rule.addFilter(net.named_data.jndn.security.v2.validator_config.ConfigFilter.create(filterList[i]));
	
			// Get rule.checker(s)
			ArrayList<BoostInfoTree> checkerList = configSection.get("checker");
			for (int i_0 = 0; i_0 < checkerList.Count; ++i_0)
				rule.addChecker(net.named_data.jndn.security.v2.validator_config.ConfigChecker.create(checkerList[i_0]));
	
			// Check other stuff.
			if (checkerList.Count == 0)
				throw new ValidatorConfigError(
						"No <rule.checker> is specified in rule: " + ruleId);
	
			return rule;
		}
	
		private readonly String id_;
		private readonly bool isForInterest_;
		private readonly ArrayList<ConfigFilter> filters_;
		private readonly ArrayList<ConfigChecker> checkers_;
		private static readonly Logger logger_ = ILOG.J2CsMapping.Util.Logging.Logger.getLogger(typeof(ConfigRule).FullName);
	}
}
