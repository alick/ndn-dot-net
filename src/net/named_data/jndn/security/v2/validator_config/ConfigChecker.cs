// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security.v2.validator_config {
	
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.security;
	using net.named_data.jndn.security.v2;
	using net.named_data.jndn.util;
	using net.named_data.jndn.util.regex;
	
	/// <summary>
	/// A ConfigChecker is an abstract base class for ConfigNameRelationChecker, etc.
	/// used by ValidatorConfig to check if a packet name and KeyLocator satisfy the
	/// conditions in a configuration section.
	/// </summary>
	///
	public abstract class ConfigChecker {
		/// <summary>
		/// Check if the packet name ane KeyLocator name satisfy this checker's
		/// conditions.
		/// </summary>
		///
		/// <param name="isForInterest"></param>
		/// <param name="packetName"></param>
		/// <param name="keyLocatorName">The KeyLocator's name.</param>
		/// <param name="state">This calls state.fail() if the packet is invalid.</param>
		/// <returns>True if further signature verification is needed, or false if the
		/// packet is immediately determined to be invalid in which case this calls
		/// state.fail() with the proper code and message.</returns>
		public bool check(bool isForInterest, Name packetName,
				Name keyLocatorName, ValidationState state) {
			if (isForInterest) {
				int signedInterestMinSize = 2;
	
				if (packetName.size() < signedInterestMinSize)
					return false;
	
				return checkNames(packetName.getPrefix(-signedInterestMinSize),
						keyLocatorName, state);
			} else
				return checkNames(packetName, keyLocatorName, state);
		}
	
		/// <summary>
		/// Create a checker from the configuration section.
		/// </summary>
		///
		/// <param name="configSection"></param>
		/// <returns>A new checker created from the configuration section.</returns>
		public static ConfigChecker create(BoostInfoTree configSection) {
			// Get checker.type.
			String checkerType = configSection.getFirstValue("type");
			if (checkerType == null)
				throw new ValidatorConfigError("Expected <checker.type>");
	
			if (checkerType.Equals("customized",StringComparison.InvariantCultureIgnoreCase))
				return createCustomizedChecker(configSection);
			else if (checkerType.Equals("hierarchical",StringComparison.InvariantCultureIgnoreCase))
				return createHierarchicalChecker(configSection);
			else
				throw new ValidatorConfigError("Unsupported checker type: "
						+ checkerType);
		}
	
		/// <summary>
		/// Check if the packet name ane KeyLocator name satisfy this checker's
		/// conditions.
		/// </summary>
		///
		/// <param name="packetName"></param>
		/// <param name="keyLocatorName">The KeyLocator's name.</param>
		/// <param name="state">This calls state.fail() if the packet is invalid.</param>
		/// <returns>True if further signature verification is needed, or false if the
		/// packet is immediately determined to be invalid in which case this calls
		/// state.fail() with the proper code and message.</returns>
		protected abstract internal bool checkNames(Name packetName, Name keyLocatorName,
				ValidationState state);
	
		private static ConfigChecker createCustomizedChecker(
				BoostInfoTree configSection) {
			// Ignore sig-type.
			// Get checker.key-locator .
			ArrayList<BoostInfoTree> keyLocatorSection = configSection
					.get("key-locator");
			if (keyLocatorSection.Count != 1)
				throw new ValidatorConfigError("Expected one <checker.key-locator>");
	
			return createKeyLocatorChecker(keyLocatorSection[0]);
		}
	
		private static ConfigChecker createHierarchicalChecker(
				BoostInfoTree configSection) {
			try {
				// Ignore sig-type.
				return new ConfigHyperRelationChecker("^(<>*)$", "\\1",
						"^(<>*)<KEY><>$", "\\1",
						net.named_data.jndn.security.v2.validator_config.ConfigNameRelation.Relation.IS_PREFIX_OF);
			} catch (NdnRegexMatcherBase.Error ex) {
				throw new ValidatorConfigError(
						"Error creating ConfigHyperRelationChecker: " + ex);
			}
		}
	
		private static ConfigChecker createKeyLocatorChecker(
				BoostInfoTree configSection) {
			// Get checker.key-locator.type .
			String keyLocatorType = configSection.getFirstValue("type");
			if (keyLocatorType == null)
				throw new ValidatorConfigError(
						"Expected <checker.key-locator.type>");
	
			if (keyLocatorType.Equals("name",StringComparison.InvariantCultureIgnoreCase))
				return createKeyLocatorNameChecker(configSection);
			else
				throw new ValidatorConfigError(
						"Unsupported checker.key-locator.type: " + keyLocatorType);
		}
	
		private static ConfigChecker createKeyLocatorNameChecker(
				BoostInfoTree configSection) {
			String nameUri = configSection.getFirstValue("name");
			if (nameUri != null) {
				Name name = new Name(nameUri);
	
				String relationValue = configSection.getFirstValue("relation");
				if (relationValue == null)
					throw new ValidatorConfigError(
							"Expected <checker.key-locator.relation>");
	
				ConfigNameRelation.Relation relation = net.named_data.jndn.security.v2.validator_config.ConfigNameRelation
						.getNameRelationFromString(relationValue);
				return new ConfigNameRelationChecker(name, relation);
			}
	
			String regexString = configSection.getFirstValue("regex");
			if (regexString != null) {
				try {
					return new ConfigRegexChecker(regexString);
				} catch (Exception e) {
					throw new ValidatorConfigError(
							"Invalid checker.key-locator.regex: " + regexString);
				}
			}
	
			ArrayList<BoostInfoTree> hyperRelationList = configSection
					.get("hyper-relation");
			if (hyperRelationList.Count == 1) {
				BoostInfoTree hyperRelation = hyperRelationList[0];
	
				// Get k-regex.
				String keyRegex = hyperRelation.getFirstValue("k-regex");
				if (keyRegex == null)
					throw new ValidatorConfigError(
							"Expected <checker.key-locator.hyper-relation.k-regex>");
	
				// Get k-expand.
				String keyExpansion = hyperRelation.getFirstValue("k-expand");
				if (keyExpansion == null)
					throw new ValidatorConfigError(
							"Expected <checker.key-locator.hyper-relation.k-expand");
	
				// Get h-relation.
				String hyperRelationString = hyperRelation
						.getFirstValue("h-relation");
				if (hyperRelationString == null)
					throw new ValidatorConfigError(
							"Expected <checker.key-locator.hyper-relation.h-relation>");
	
				// Get p-regex.
				String packetNameRegex = hyperRelation.getFirstValue("p-regex");
				if (packetNameRegex == null)
					throw new ValidatorConfigError(
							"Expected <checker.key-locator.hyper-relation.p-regex>");
	
				// Get p-expand.
				String packetNameExpansion = hyperRelation
						.getFirstValue("p-expand");
				if (packetNameExpansion == null)
					throw new ValidatorConfigError(
							"Expected <checker.key-locator.hyper-relation.p-expand>");
	
				ConfigNameRelation.Relation relation_0 = net.named_data.jndn.security.v2.validator_config.ConfigNameRelation
						.getNameRelationFromString(hyperRelationString);
	
				try {
					return new ConfigHyperRelationChecker(packetNameRegex,
							packetNameExpansion, keyRegex, keyExpansion, relation_0);
				} catch (Exception e_1) {
					throw new ValidatorConfigError(
							"Invalid regex for key-locator.hyper-relation");
				}
			}
	
			throw new ValidatorConfigError("Unsupported checker.key-locator");
		}
	}
}
