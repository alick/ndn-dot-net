// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security.v2 {
	
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	
	/// <summary>
	/// CertificateFetcherFromNetwork extends CertificateFetcher to fetch missing
	/// certificates from the network.
	/// </summary>
	///
	public class CertificateFetcherFromNetwork : CertificateFetcher {
		public sealed class Anonymous_C2 : OnData {
			private readonly ValidationState state;
			private readonly CertificateFetcher.ValidationContinuation  continueValidation;
	
			public Anonymous_C2(ValidationState state_0,
					CertificateFetcher.ValidationContinuation  continueValidation_1) {
				this.state = state_0;
				this.continueValidation = continueValidation_1;
			}
	
			public void onData(Interest interest, Data data) {
				net.named_data.jndn.security.v2.CertificateFetcherFromNetwork.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.FINE,
						"Fetched certificate from network {0}", data
								.getName().toUri());
	
				CertificateV2 certificate;
				try {
					certificate = new CertificateV2(data);
				} catch (Exception ex) {
					state.fail(new ValidationError(
							net.named_data.jndn.security.v2.ValidationError.MALFORMED_CERTIFICATE,
							"Fetched a malformed certificate `"
									+ data.getName().toUri() + "` (" + ex
									+ ")"));
					return;
				}
	
				try {
					continueValidation.continueValidation(certificate,
							state);
				} catch (Exception ex_0) {
					state.fail(new ValidationError(
							net.named_data.jndn.security.v2.ValidationError.CANNOT_RETRIEVE_CERTIFICATE,
							"Error in continueValidation: " + ex_0));
				}
			}
		}
		public sealed class Anonymous_C1 : OnTimeout {
				private readonly CertificateFetcherFromNetwork outer_CertificateFetcherFromNetwork;
				private readonly ValidationState state;
				private readonly CertificateFetcher.ValidationContinuation  continueValidation;
				private readonly CertificateRequest certificateRequest;
		
				public Anonymous_C1(
						CertificateFetcherFromNetwork paramouter_CertificateFetcherFromNetwork,
						ValidationState state_0,
						CertificateFetcher.ValidationContinuation  continueValidation_1,
						CertificateRequest certificateRequest_2) {
					this.state = state_0;
					this.continueValidation = continueValidation_1;
					this.certificateRequest = certificateRequest_2;
					this.outer_CertificateFetcherFromNetwork = paramouter_CertificateFetcherFromNetwork;
				}
		
				public void onTimeout(Interest interest) {
					net.named_data.jndn.security.v2.CertificateFetcherFromNetwork.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.FINE,
							"Timeout while fetching certificate {0}, retrying",
							certificateRequest.interest_.getName().toUri());
		
					--certificateRequest.nRetriesLeft_;
					if (certificateRequest.nRetriesLeft_ >= 0) {
						try {
							outer_CertificateFetcherFromNetwork.fetch(certificateRequest, state, continueValidation);
						} catch (Exception ex) {
							state.fail(new ValidationError(
									net.named_data.jndn.security.v2.ValidationError.CANNOT_RETRIEVE_CERTIFICATE,
									"Error in fetch: " + ex));
						}
					} else
						state.fail(new ValidationError(
								net.named_data.jndn.security.v2.ValidationError.CANNOT_RETRIEVE_CERTIFICATE,
								"Cannot fetch certificate after all retries `"
										+ certificateRequest.interest_
												.getName().toUri() + "`"));
				}
			}
		public sealed class Anonymous_C0 : OnNetworkNack {
				private readonly CertificateFetcherFromNetwork outer_CertificateFetcherFromNetwork;
				private readonly ValidationState state;
				private readonly CertificateFetcher.ValidationContinuation  continueValidation;
				private readonly CertificateRequest certificateRequest;
		
				public Anonymous_C0(
						CertificateFetcherFromNetwork paramouter_CertificateFetcherFromNetwork,
						ValidationState state_0,
						CertificateFetcher.ValidationContinuation  continueValidation_1,
						CertificateRequest certificateRequest_2) {
					this.state = state_0;
					this.continueValidation = continueValidation_1;
					this.certificateRequest = certificateRequest_2;
					this.outer_CertificateFetcherFromNetwork = paramouter_CertificateFetcherFromNetwork;
				}
		
				public void onNetworkNack(Interest interest,
						NetworkNack networkNack) {
					net.named_data.jndn.security.v2.CertificateFetcherFromNetwork.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.FINE,
							"NACK ({0}) while fetching certificate {1}",
							new Object[] {
									networkNack.getReason(),
									certificateRequest.interest_.getName()
											.toUri() });
		
					--certificateRequest.nRetriesLeft_;
					if (certificateRequest.nRetriesLeft_ >= 0) {
						try {
							outer_CertificateFetcherFromNetwork.fetch(certificateRequest, state, continueValidation);
						} catch (Exception ex) {
							state.fail(new ValidationError(
									net.named_data.jndn.security.v2.ValidationError.CANNOT_RETRIEVE_CERTIFICATE,
									"Error in fetch: " + ex));
						}
					} else
						state.fail(new ValidationError(
								net.named_data.jndn.security.v2.ValidationError.CANNOT_RETRIEVE_CERTIFICATE,
								"Cannot fetch certificate after all retries `"
										+ certificateRequest.interest_
												.getName().toUri() + "`"));
				}
			}
		/// <summary>
		/// Create a CertificateFetcherFromNetwork to fetch certificates using the Face.
		/// </summary>
		///
		/// <param name="face">The face for calling expressInterest.</param>
		public CertificateFetcherFromNetwork(Face face) {
			face_ = face;
		}
	
		/// <summary>
		/// Implement doFetch to use face_.expressInterest to fetch a certificate.
		/// </summary>
		///
		/// <param name="certificateRequest_0"></param>
		/// <param name="state_1">The validation state.</param>
		/// <param name="continueValidation_2">is the fetched certificate and state is the ValidationState.</param>
		protected internal override void doFetch(CertificateRequest certificateRequest_0,
				ValidationState state_1,
				CertificateFetcher.ValidationContinuation  continueValidation_2) {
			try {
				face_.expressInterest(certificateRequest_0.interest_, new CertificateFetcherFromNetwork.Anonymous_C2 (state_1, continueValidation_2), new CertificateFetcherFromNetwork.Anonymous_C1 (this, state_1, continueValidation_2,
						certificateRequest_0), new CertificateFetcherFromNetwork.Anonymous_C0 (this, state_1, continueValidation_2,
						certificateRequest_0));
			} catch (IOException ex) {
				state_1.fail(new ValidationError(
						net.named_data.jndn.security.v2.ValidationError.CANNOT_RETRIEVE_CERTIFICATE,
						"Error in expressInterest: ex"));
			}
		}
	
		private readonly Face face_;
		static internal readonly Logger logger_ = ILOG.J2CsMapping.Util.Logging.Logger
				.getLogger(typeof(CertificateFetcherFromNetwork).FullName);
	}
}
