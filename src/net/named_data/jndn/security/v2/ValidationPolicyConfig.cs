// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security.v2 {
	
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.security;
	using net.named_data.jndn.security.v2.validator_config;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// ValidationPolicyConfig implements a validator which can be set up via a
	/// configuration file. For command Interest validation, this policy must be
	/// combined with ValidationPolicyCommandInterest in order to guard against
	/// replay attacks.
	/// </summary>
	///
	/// @note This policy does not support inner policies (a sole policy or a
	/// terminal inner policy).
	/// See https://named-data.net/doc/ndn-cxx/current/tutorials/security-validator-config.html
	public class ValidationPolicyConfig : ValidationPolicy {
		/// <summary>
		/// Create a default ValidationPolicyConfig.
		/// </summary>
		///
		public ValidationPolicyConfig() {
			this.dataRules_ = new ArrayList<ConfigRule>();
			this.interestRules_ = new ArrayList<ConfigRule>();
			shouldBypass_ = false;
			isConfigured_ = false;
		}
	
		/// <summary>
		/// Load the configuration from the given config file. This replaces any
		/// existing configuration.
		/// </summary>
		///
		/// <param name="filePath">The The path of the config file.</param>
		public void load(String filePath) {
			BoostInfoParser parser = new BoostInfoParser();
			parser.read(filePath);
			load(parser.getRoot(), filePath);
		}
	
		/// <summary>
		/// Load the configuration from the given input string. This replaces any
		/// existing configuration.
		/// </summary>
		///
		/// <param name="input"></param>
		/// <param name="inputName">Used for log messages, etc.</param>
		public void load(String input, String inputName) {
			BoostInfoParser parser = new BoostInfoParser();
			parser.read(input, inputName);
			load(parser.getRoot(), inputName);
		}
	
		/// <summary>
		/// Load the configuration from the given configSection. This replaces any
		/// existing configuration.
		/// </summary>
		///
		/// <param name="configSection"></param>
		/// <param name="inputName">Used for log messages, etc.</param>
		public void load(BoostInfoTree configSection, String inputName) {
			if (isConfigured_) {
				// Reset the previous configuration.
				shouldBypass_ = false;
				ILOG.J2CsMapping.Collections.Collections.Clear(dataRules_);
				ILOG.J2CsMapping.Collections.Collections.Clear(interestRules_);
	
				validator_.resetAnchors();
				validator_.resetVerifiedCertificates();
			}
			isConfigured_ = true;
	
			ArrayList<BoostInfoTree> validatorList = configSection.get("validator");
			if (validatorList.Count != 1)
				throw new ValidatorConfigError(
						"ValidationPolicyConfig: Expected one validator section");
			BoostInfoTree validatorSection = validatorList[0];
	
			// Get the rules.
			ArrayList<BoostInfoTree> ruleList = validatorSection.get("rule");
			for (int i = 0; i < ruleList.Count; ++i) {
				ConfigRule rule = net.named_data.jndn.security.v2.validator_config.ConfigRule.create(ruleList[i]);
				if (rule.getIsForInterest())
					ILOG.J2CsMapping.Collections.Collections.Add(interestRules_,rule);
				else
					ILOG.J2CsMapping.Collections.Collections.Add(dataRules_,rule);
			}
	
			// Get the trust anchors.
			ArrayList<BoostInfoTree> trustAnchorList = validatorSection
					.get("trust-anchor");
			for (int i_0 = 0; i_0 < trustAnchorList.Count; ++i_0)
				processConfigTrustAnchor(trustAnchorList[i_0], inputName);
		}
	
		public override void checkPolicy(Data data, ValidationState state,
				ValidationPolicy.ValidationContinuation  continueValidation) {
			if (hasInnerPolicy())
				throw new ValidatorConfigError(
						"ValidationPolicyConfig must be a terminal inner policy");
	
			if (shouldBypass_) {
				continueValidation.continueValidation(null, state);
				return;
			}
	
			Name keyLocatorName = net.named_data.jndn.security.v2.ValidationPolicy.getKeyLocatorName(data, state);
			if (state.isOutcomeFailed())
				// Already called state.fail() .
				return;
	
			for (int i = 0; i < dataRules_.Count; ++i) {
				ConfigRule rule = dataRules_[i];
	
				if (rule.match(false, data.getName())) {
					if (rule.check(false, data.getName(), keyLocatorName, state)) {
						continueValidation
								.continueValidation(new CertificateRequest(
										new Interest(keyLocatorName)), state);
						return;
					} else
						// rule.check failed and already called state.fail() .
						return;
				}
			}
	
			state.fail(new ValidationError(net.named_data.jndn.security.v2.ValidationError.POLICY_ERROR,
					"No rule matched for data `" + data.getName().toUri() + "`"));
		}
	
		public override void checkPolicy(Interest interest, ValidationState state,
				ValidationPolicy.ValidationContinuation  continueValidation) {
			if (hasInnerPolicy())
				throw new ValidatorConfigError(
						"ValidationPolicyConfig must be a terminal inner policy");
	
			if (shouldBypass_) {
				continueValidation.continueValidation(null, state);
				return;
			}
	
			Name keyLocatorName = net.named_data.jndn.security.v2.ValidationPolicy.getKeyLocatorName(interest, state);
			if (state.isOutcomeFailed())
				// Already called state.fail() .
				return;
	
			for (int i = 0; i < interestRules_.Count; ++i) {
				ConfigRule rule = interestRules_[i];
	
				if (rule.match(true, interest.getName())) {
					if (rule.check(true, interest.getName(), keyLocatorName, state)) {
						continueValidation
								.continueValidation(new CertificateRequest(
										new Interest(keyLocatorName)), state);
						return;
					} else
						// rule.check failed and already called state.fail() .
						return;
				}
			}
	
			state.fail(new ValidationError(net.named_data.jndn.security.v2.ValidationError.POLICY_ERROR,
					"No rule matched for interest `" + interest.getName().toUri()
							+ "`"));
		}
	
		/// <summary>
		/// Process the trust-anchor configuration section and call
		/// validator_.loadAnchor as needed.
		/// </summary>
		///
		/// <param name="configSection"></param>
		/// <param name="inputName">Used for log messages, etc.</param>
		private void processConfigTrustAnchor(BoostInfoTree configSection,
				String inputName) {
			String anchorType = configSection.getFirstValue("type");
			if (anchorType == null)
				throw new ValidatorConfigError("Expected <trust-anchor.type>");
	
			if (anchorType.Equals("file",StringComparison.InvariantCultureIgnoreCase)) {
				// Get trust-anchor.file .
				String fileName = configSection.getFirstValue("file-name");
				if (fileName == null)
					throw new ValidatorConfigError(
							"Expected <trust-anchor.file-name>");
	
				double refreshPeriod = getRefreshPeriod(configSection);
				try {
					validator_.loadAnchor(fileName, fileName, refreshPeriod, false);
				} catch (TrustAnchorContainer.Error ex) {
					throw new ValidatorConfigError("Error in loadAnchor: " + ex);
				}
	
				return;
			} else if (anchorType.Equals("base64",StringComparison.InvariantCultureIgnoreCase)) {
				// Get trust-anchor.base64-string .
				String base64String = configSection.getFirstValue("base64-string");
				if (base64String == null)
					throw new ValidatorConfigError(
							"Expected <trust-anchor.base64-string>");
	
				byte[] encoding = net.named_data.jndn.util.Common.base64Decode(base64String);
				CertificateV2 certificate = new CertificateV2();
				try {
					certificate.wireDecode(new Blob(encoding));
				} catch (Exception ex_0) {
					throw new ValidatorConfigError(
							"Cannot decode certificate from base64-string: " + ex_0);
				}
				try {
					validator_.loadAnchor("", certificate);
				} catch (TrustAnchorContainer.Error ex_1) {
					throw new ValidatorConfigError("Error in loadAnchor: " + ex_1);
				}
	
				return;
			} else if (anchorType.Equals("dir",StringComparison.InvariantCultureIgnoreCase)) {
				// Get trust-anchor.dir .
				String dirString = configSection.getFirstValue("dir");
				if (dirString == null)
					throw new ValidatorConfigError("Expected <trust-anchor.dir>");
	
				double refreshPeriod_2 = getRefreshPeriod(configSection);
				try {
					validator_
							.loadAnchor(dirString, dirString, refreshPeriod_2, true);
				} catch (TrustAnchorContainer.Error ex_3) {
					throw new ValidatorConfigError("Error in loadAnchor: " + ex_3);
				}
	
				return;
			} else if (anchorType.Equals("any",StringComparison.InvariantCultureIgnoreCase))
				shouldBypass_ = true;
			else
				throw new ValidatorConfigError("Unsupported trust-anchor.type");
		}
	
		/// <summary>
		/// Get the "refresh" value. If the value is 9, return a period of one hour.
		/// </summary>
		///
		/// <param name="configSection"></param>
		/// <returns>The refresh period in milliseconds. However if there is no
		/// "refresh" value, return a large number (effectively no refresh).</returns>
		private static double getRefreshPeriod(BoostInfoTree configSection) {
			String refreshString = configSection.getFirstValue("refresh");
			if (refreshString == null)
				// Return a large value (effectively no refresh).
				return 1e14d;
	
			double refreshSeconds = 0;
			Pattern regex1 = ILOG.J2CsMapping.Text.Pattern.Compile("(\\d+)([hms])");
			Matcher refreshMatch = regex1.Matcher(refreshString);
			if (refreshMatch.Find()) {
				refreshSeconds = Int32.Parse(refreshMatch.Group(1));
				if (!refreshMatch.Group(2).equals("s")) {
					refreshSeconds *= 60;
					if (!refreshMatch.Group(2).equals("m"))
						refreshSeconds *= 60;
				}
			}
	
			if (refreshSeconds == 0.0d)
				// Use an hour instead of 0.
				return 3600 * 1000.0d;
			else
				// Convert from seconds to milliseconds.
				return refreshSeconds * 1000.0d;
		}
	
		/// <summary>
		/// shouldBypass_ is set to true when 'any' is specified as a trust anchor,
		/// causing all packets to bypass validation.
		/// </summary>
		///
		private bool shouldBypass_;
		private bool isConfigured_;
		private readonly ArrayList<ConfigRule> dataRules_;
		private readonly ArrayList<ConfigRule> interestRules_;
	}
}
