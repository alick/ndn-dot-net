// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017-2018 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security.v2 {
	
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn.security;
	
	/// <summary>
	/// CertificateFetcher is an abstract base class which provides an interface used
	/// by the validator to fetch missing certificates.
	/// </summary>
	///
	public abstract class CertificateFetcher {
		public CertificateFetcher() {
			this.certificateStorage_ = null;
		}
		public sealed class Anonymous_C0 : CertificateFetcher.ValidationContinuation {
				private readonly CertificateFetcher outer_CertificateFetcher;
				private readonly CertificateFetcher.ValidationContinuation  outerContinueValidation;
		
				public Anonymous_C0(CertificateFetcher paramouter_CertificateFetcher,
						CertificateFetcher.ValidationContinuation  outerContinueValidation_0) {
					this.outerContinueValidation = outerContinueValidation_0;
					this.outer_CertificateFetcher = paramouter_CertificateFetcher;
				}
		
				public void continueValidation(CertificateV2 certificate,
						ValidationState state) {
					outer_CertificateFetcher.certificateStorage_.cacheUnverifiedCertificate(certificate);
					outerContinueValidation.continueValidation(certificate, state);
				}
			}
		public interface ValidationContinuation {
			void continueValidation(CertificateV2 certificate, ValidationState state);
		}
	
		/// <summary>
		/// Assign the certificate storage used to check for known certificates and to
		/// cache unverified ones.
		/// </summary>
		///
		/// <param name="certificateStorage"></param>
		public void setCertificateStorage(CertificateStorage certificateStorage) {
			certificateStorage_ = certificateStorage;
		}
	
		/// <summary>
		/// Asynchronously fetch certificate a certificate. setCertificateStorage must
		/// have been called first.
		/// If the requested certificate exists in the storage, then this method will
		/// immediately call continueValidation with the certificate. If certificate is
		/// not available, then the implementation-specific doFetch will be called to
		/// asynchronously fetch the certificate. The successfully-retrieved
		/// certificate will be automatically added to the unverified cache of the
		/// certificate storage.
		/// When the requested certificate is retrieved, continueValidation is called.
		/// Otherwise, the fetcher implementation calls state.failed() with the
		/// appropriate error code and diagnostic message.
		/// </summary>
		///
		/// <param name="certificateRequest"></param>
		/// <param name="state">The validation state.</param>
		/// <param name="continueValidation">is the fetched certificate and state is the ValidationState.</param>
		public void fetch(CertificateRequest certificateRequest,
				ValidationState state, CertificateFetcher.ValidationContinuation  continueValidation) {
			if (certificateStorage_ == null)
				throw new Exception(
						"CertificateFetcher.fetch: You must first call setCertificateStorage");
	
			CertificateV2 certificate = certificateStorage_
					.getUnverifiedCertificateCache().find(
							certificateRequest.interest_);
			if (certificate != null) {
				logger_.log(ILOG.J2CsMapping.Util.Logging.Level.FINE,
						"Found certificate in **un**verified key cache {0}",
						certificate.getName().toUri());
				continueValidation.continueValidation(certificate, state);
				return;
			}
	
			// Rename continueValidation to avoid a loop.
			CertificateFetcher.ValidationContinuation  outerContinueValidation_0 = continueValidation;
			// Fetch asynchronously.
			doFetch(certificateRequest, state, new CertificateFetcher.Anonymous_C0 (this, outerContinueValidation_0));
		}
	
		/// <summary>
		/// An implementation to fetch a certificate asynchronously. The subclass must
		/// implement this method.
		/// </summary>
		///
		/// <param name="certificateRequest"></param>
		/// <param name="state">The validation state.</param>
		/// <param name="continueValidation">is the fetched certificate and state is the ValidationState.</param>
		protected abstract internal void doFetch(CertificateRequest certificateRequest,
				ValidationState state, CertificateFetcher.ValidationContinuation  continueValidation);
	
		protected internal CertificateStorage certificateStorage_;
		private static readonly Logger logger_ = ILOG.J2CsMapping.Util.Logging.Logger
				.getLogger(typeof(CertificateFetcher).FullName);
	}
}
