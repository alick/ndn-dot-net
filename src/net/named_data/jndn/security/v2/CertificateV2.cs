// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017-2018 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security.v2 {
	
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.security;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// CertificateV2 represents a certificate following the certificate format
	/// naming convention.
	/// Overview of the NDN certificate format:
	/// CertificateV2 ::= DATA-TLV TLV-LENGTH
	/// Name      (= /{NameSpace}/KEY/[KeyId]/[IssuerId]/[Version])
	/// MetaInfo  (.ContentType = KEY)
	/// Content   (= X509PublicKeyContent)
	/// SignatureInfo (= CertificateV2SignatureInfo)
	/// SignatureValue
	/// X509PublicKeyContent ::= CONTENT-TLV TLV-LENGTH
	/// BYTE+ (= public key bits in PKCS#8 format)
	/// CertificateV2SignatureInfo ::= SIGNATURE-INFO-TYPE TLV-LENGTH
	/// SignatureType
	/// KeyLocator
	/// ValidityPeriod
	/// ... optional critical or non-critical extension blocks ...
	/// An example of NDN certificate name:
	/// /edu/ucla/cs/yingdi/KEY/%03%CD...%F1/%9F%D3...%B7/%FD%d2...%8E
	/// \_________________/    \___________/ \___________/\___________/
	/// Certificate Namespace      Key Id       Issuer Id     Version
	/// (Identity)
	/// \__________________________________/
	/// Key Name
	/// Notes:
	/// - `Key Id` is an opaque name component to identify the instance of the public
	/// key for the certificate namespace. The value of `Key ID` is controlled by
	/// the namespace owner. The library includes helpers for generating key IDs
	/// using an 8-byte random number, SHA-256 digest of the public key, timestamp,
	/// and the specified numerical identifiers.
	/// - `Issuer Id` is sn opaque name component to identify the issuer of the
	/// certificate. The value is controlled by the issuer. The library includes
	/// helpers to set issuer the ID to an 8-byte random number, SHA-256 digest of
	/// the issuer's public key, and the specified numerical identifiers.
	/// - `Key Name` is a logical name of the key used for management purposes. the
	/// Key Name includes the certificate namespace, keyword `KEY`, and `KeyId`
	/// components.
	/// See https://github.com/named-data/ndn-cxx/blob/master/docs/specs/certificate-format.rst
	/// </summary>
	///
	public class CertificateV2 : Data {
		/// <summary>
		/// A CertificateV2.Error extends Exception and represents errors for not
		/// complying with the certificate format.
		/// </summary>
		///
		[Serializable]
		public class Error : Exception {
			public Error(String message) : base(message) {
			}
		}
	
		/// <summary>
		/// Create a CertificateV2 with content type KEY and default or unspecified
		/// values.
		/// </summary>
		///
		public CertificateV2() {
			getMetaInfo().setType(net.named_data.jndn.ContentType.KEY);
		}
	
		/// <summary>
		/// Create a CertificateV2 from the content in the Data packet.
		/// </summary>
		///
		/// <param name="data">The data packet with the content to copy.</param>
		/// <exception cref="CertificateV2.Error">If data does not follow the certificate format.</exception>
		public CertificateV2(Data data) : base(data) {
			checkFormat();
		}
	
		private void checkFormat() {
			if (!isValidName(getName()))
				throw new CertificateV2.Error (
						"The Data Name does not follow the certificate naming convention");
	
			if (getMetaInfo().getType() != net.named_data.jndn.ContentType.KEY)
				throw new CertificateV2.Error ("The Data ContentType is not KEY");
	
			if (getMetaInfo().getFreshnessPeriod() < 0.0d)
				throw new CertificateV2.Error ("The Data FreshnessPeriod is not set");
	
			if (getContent().size() == 0)
				throw new CertificateV2.Error ("The Data Content is empty");
		}
	
		/// <summary>
		/// Get key name from the certificate name.
		/// </summary>
		///
		/// <returns>The key name as a new Name.</returns>
		public Name getKeyName() {
			return getName().getPrefix(KEY_ID_OFFSET + 1);
		}
	
		/// <summary>
		/// Get the identity name from the certificate name.
		/// </summary>
		///
		/// <returns>The identity name as a new Name.</returns>
		public Name getIdentity() {
			return getName().getPrefix(KEY_COMPONENT_OFFSET);
		}
	
		/// <summary>
		/// Get the key ID component from the certificate name.
		/// </summary>
		///
		/// <returns>The key ID name component.</returns>
		public Name.Component getKeyId() {
			return getName().get(KEY_ID_OFFSET);
		}
	
		/// <summary>
		/// Get the issuer ID component from the certificate name.
		/// </summary>
		///
		/// <returns>The issuer ID component.</returns>
		public Name.Component getIssuerId() {
			return getName().get(ISSUER_ID_OFFSET);
		}
	
		/// <summary>
		/// Get the public key DER encoding.
		/// </summary>
		///
		/// <returns>The DER encoding Blob.</returns>
		/// <exception cref="CertificateV2.Error">If the public key is not set.</exception>
		public Blob getPublicKey() {
			if (getContent().size() == 0)
				throw new CertificateV2.Error (
						"The public key is not set (the Data content is empty)");
	
			return getContent();
		}
	
		/// <summary>
		/// Get the certificate validity period from the SignatureInfo.
		/// </summary>
		///
		/// <returns>The ValidityPeriod object.</returns>
		/// <exception cref="System.ArgumentException">If the SignatureInfo doesn't have aValidityPeriod.</exception>
		public ValidityPeriod getValidityPeriod() {
			if (!net.named_data.jndn.security.ValidityPeriod.canGetFromSignature(getSignature()))
				throw new ArgumentException(
						"The SignatureInfo does not have a ValidityPeriod");
	
			return net.named_data.jndn.security.ValidityPeriod.getFromSignature(getSignature());
		}
	
		/// <summary>
		/// Check if the time falls within the validity period.
		/// </summary>
		///
		/// <param name="time">The time to check as milliseconds since Jan 1, 1970 UTC.</param>
		/// <returns>True if the beginning of the validity period is less than or equal
		/// to time and time is less than or equal to the end of the validity period.</returns>
		/// <exception cref="System.ArgumentException">If the SignatureInfo doesn't have aValidityPeriod.</exception>
		public bool isValid(double time) {
			return getValidityPeriod().isValid(time);
		}
	
		/// <summary>
		/// Check if the current time falls within the validity period.
		/// </summary>
		///
		/// <returns>True if the beginning of the validity period is less than or equal
		/// to the current time and the current time is less than or equal to the end
		/// of the validity period.</returns>
		/// <exception cref="System.ArgumentException">If the SignatureInfo doesn't have aValidityPeriod.</exception>
		public bool isValid() {
			return getValidityPeriod().isValid();
		}
	
		// TODO: getExtension
	
		/// <summary>
		/// Write a string representation of this certificate to result.
		/// </summary>
		///
		/// <param name="result">The StringBuffer to write to.</param>
		public void printCertificate(StringBuilder result) {
			result.append("Certificate name:\n");
			result.append("  ").append(getName().toUri()).append("\n");
			result.append("Validity:\n");
			result.append("  NotBefore: ")
					.append(net.named_data.jndn.encrypt.Schedule
							.toIsoString(getValidityPeriod().getNotBefore()))
					.append("\n");
			result.append("  NotAfter: ")
					.append(net.named_data.jndn.encrypt.Schedule.toIsoString(getValidityPeriod().getNotAfter()))
					.append("\n");
	
			// TODO: Print the extension.
	
			result.append("Public key bits:\n");
			try {
				result.append(net.named_data.jndn.util.Common.base64Encode(getPublicKey()
						.getImmutableArray(), true));
			} catch (CertificateV2.Error  ex) {
				// No public key.
			}
	
			result.append("Signature Information:\n");
			result.append("  Signature Type: ");
			if (getSignature()  is  Sha256WithEcdsaSignature)
				result.append("SignatureSha256WithEcdsa\n");
			else if (getSignature()  is  Sha256WithRsaSignature)
				result.append("SignatureSha256WithRsa\n");
			else
				result.append("<unknown>\n");
	
			if (net.named_data.jndn.KeyLocator.canGetFromSignature(getSignature())) {
				result.append("  Key Locator: ");
				KeyLocator keyLocator = net.named_data.jndn.KeyLocator.getFromSignature(getSignature());
				if (keyLocator.getType() == net.named_data.jndn.KeyLocatorType.KEYNAME) {
					if (keyLocator.getKeyName().equals(getKeyName()))
						result.append("Self-Signed ");
	
					result.append("Name=").append(keyLocator.getKeyName().toUri())
							.append("\n");
				} else
					result.append("<no KeyLocator key name>\n");
			}
		}
	
		/// <summary>
		/// Override to call the base class wireDecode then check the certificate
		/// format.
		/// </summary>
		///
		/// <param name="input">The input byte array to be decoded as an immutable Blob.</param>
		/// <param name="wireFormat">A WireFormat object used to decode the input.</param>
		public override void wireDecode(Blob input, WireFormat wireFormat) {
			base.wireDecode(input,wireFormat);
			try {
				checkFormat();
			} catch (CertificateV2.Error  ex) {
				throw new EncodingException(ex.Message);
			}
		}
	
		/// <summary>
		/// Use printCertificate to return a string representation of this certificate.
		/// </summary>
		///
		/// <returns>The string representation of this certificate.</returns>
		public override String ToString() {
			StringBuilder result = new StringBuilder();
			printCertificate(result);
			return result.toString();
		}
	
		/// <summary>
		/// Check if certificateName follows the naming convention for a certificate.
		/// </summary>
		///
		/// <param name="certificateName">The name of the certificate.</param>
		/// <returns>True if certificateName follows the naming convention.</returns>
		public static bool isValidName(Name certificateName) {
			// /{NameSpace}/KEY/[KeyId]/[IssuerId]/[Version]
			return (certificateName.size() >= MIN_CERT_NAME_LENGTH && certificateName
					.get(KEY_COMPONENT_OFFSET).equals(KEY_COMPONENT));
		}
	
		/// <summary>
		/// Extract the identity namespace from certificateName.
		/// </summary>
		///
		/// <param name="certificateName">The name of the certificate.</param>
		/// <returns>The identity namespace as a new Name.</returns>
		public static Name extractIdentityFromCertName(Name certificateName) {
			if (!isValidName(certificateName))
				throw new ArgumentException("Certificate name `"
						+ certificateName.toUri()
						+ "` does not follow the naming conventions");
	
			return certificateName.getPrefix(KEY_COMPONENT_OFFSET);
		}
	
		/// <summary>
		/// Extract key name from certificateName.
		/// </summary>
		///
		/// <param name="certificateName">The name of the certificate.</param>
		/// <returns>The key name as a new Name.</returns>
		public static Name extractKeyNameFromCertName(Name certificateName) {
			if (!isValidName(certificateName)) {
				throw new ArgumentException("Certificate name `"
						+ certificateName.toUri()
						+ "` does not follow the naming conventions");
			}
	
			// Trim everything after the key ID.
			return certificateName.getPrefix(KEY_ID_OFFSET + 1);
		}
	
		public const int VERSION_OFFSET = -1;
		public const int ISSUER_ID_OFFSET = -2;
		public const int KEY_ID_OFFSET = -3;
		public const int KEY_COMPONENT_OFFSET = -4;
		public const int MIN_CERT_NAME_LENGTH = 4;
		public const int MIN_KEY_NAME_LENGTH = 2;
		public static readonly Name.Component KEY_COMPONENT = new Name.Component("KEY");
	}
}
