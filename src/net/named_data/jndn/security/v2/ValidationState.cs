// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017-2019 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security.v2 {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// ValidationState is an abstract base class for DataValidationState and
	/// InterestValidationState.
	/// One instance of the validation state is kept for the validation of the whole
	/// certificate chain.
	/// The state collects the certificate chain that adheres to the selected
	/// validation policy to validate data or interest packets. Certificate, data,
	/// and interest packet signatures are verified only after the validator
	/// determines that the chain terminates with a trusted certificate (a trusted
	/// anchor or a previously validated certificate). This model allows filtering
	/// out invalid certificate chains without incurring (costly) cryptographic
	/// signature verification overhead and mitigates some forms of denial-of-service
	/// attacks.
	/// A validation policy and/or key fetcher may add custom information associated
	/// with the validation state using tags.
	/// </summary>
	///
	public abstract class ValidationState {
		public ValidationState() {
			this.certificateChain_ = new ArrayList<CertificateV2>();
			this.seenCertificateNames_ = new HashedSet<Name>();
			this.hasOutcome_ = false;
		}
	
		/// <summary>
		/// Check if validation failed or success has been called.
		/// </summary>
		///
		/// <returns>True if validation failed or success has been called.</returns>
		public bool hasOutcome() {
			return hasOutcome_;
		}
	
		/// <summary>
		/// Check if validation failed has been called.
		/// </summary>
		///
		/// <returns>True if validation failed has been called, false if no validation
		/// callbacks have been called or validation success was called.</returns>
		public bool isOutcomeFailed() {
			return hasOutcome_ && outcome_ == false;
		}
	
		/// <summary>
		/// Check if validation success has been called.
		/// </summary>
		///
		/// <returns>True if validation success has been called, false if no validation
		/// callbacks have been called or validation failed was called.</returns>
		public bool isOutcomeSuccess() {
			return hasOutcome_ && outcome_ == true;
		}
	
		/// <summary>
		/// Call the failure callback.
		/// </summary>
		///
		public abstract void fail(ValidationError error);
	
		/// <summary>
		/// Get the depth of the certificate chain.
		/// </summary>
		///
		/// <returns>The depth of the certificate chain.</returns>
		public int getDepth() {
			return certificateChain_.Count;
		}
	
		/// <summary>
		/// Check if certificateName has been previously seen, and record the supplied
		/// name.
		/// </summary>
		///
		/// <param name="certificateName">The certificate name, which is copied.</param>
		/// <returns>True if certificateName has been previously seen.</returns>
		public bool hasSeenCertificateName(Name certificateName) {
			if (ILOG.J2CsMapping.Collections.Collections.Contains(certificateName,seenCertificateNames_))
				return true;
			else {
				// Copy the Name.
				ILOG.J2CsMapping.Collections.Collections.Add(seenCertificateNames_,new Name(certificateName));
				return false;
			}
		}
	
		/// <summary>
		/// Add the certificate to the top of the certificate chain.
		/// If the certificate chain is empty, then the certificate should be the
		/// signer of the original packet. If the certificate chain is not empty, then
		/// the certificate should be the signer of the front of the certificate chain.
		/// </summary>
		///
		/// @note This function does not verify the signature bits.
		/// <param name="certificate">The certificate to add, which is copied.</param>
		public void addCertificate(CertificateV2 certificate) {
			certificateChain_.Insert(0, new CertificateV2(certificate));
		}
	
		/// <summary>
		/// Set the outcome to the given value, and set hasOutcome_ true.
		/// </summary>
		///
		/// <param name="outcome">The outcome.</param>
		/// <exception cref="System.ArgumentException">If this ValidationState already has anoutcome.</exception>
		protected internal void setOutcome(bool outcome) {
			if (hasOutcome_)
				throw new ArgumentException(
						"The ValidationState already has an outcome");
	
			hasOutcome_ = true;
			outcome_ = outcome;
		}
	
		/// <summary>
		/// Verify the signature of the original packet. This is only called by the
		/// Validator class.
		/// </summary>
		///
		/// <param name="trustedCertificate">The certificate that signs the original packet.</param>
		public abstract void verifyOriginalPacket_(CertificateV2 trustedCertificate);
	
		/// <summary>
		/// Call the success callback of the original packet without signature
		/// validation. This is only called by the Validator class.
		/// </summary>
		///
		public abstract void bypassValidation_();
	
		/// <summary>
		/// Verify signatures of certificates in the certificate chain. On return, the
		/// certificate chain contains a list of certificates successfully verified by
		/// trustedCertificate.
		/// When the certificate chain cannot be verified, this method will call
		/// fail() with the INVALID_SIGNATURE error code and the appropriate message.
		/// This is only called by the Validator class.
		/// </summary>
		///
		/// <returns>The certificate to validate the original data packet, either the
		/// last entry in the certificate chain or trustedCertificate if the
		/// certificate chain is empty. However, return null if the signature of at
		/// least one certificate in the chain is invalid, in which case all unverified
		/// certificates have been removed from the certificate chain.</returns>
		public CertificateV2 verifyCertificateChain_(
				CertificateV2 trustedCertificate) {
			CertificateV2 validatedCertificate = trustedCertificate;
			for (int i = 0; i < certificateChain_.Count; ++i) {
				CertificateV2 certificateToValidate = certificateChain_[i];
	
				if (!net.named_data.jndn.security.VerificationHelpers.verifyDataSignature(certificateToValidate,
						validatedCertificate)) {
					fail(new ValidationError(net.named_data.jndn.security.v2.ValidationError.INVALID_SIGNATURE,
							"Invalid signature of certificate `"
									+ certificateToValidate.getName().toUri() + "`"));
					// Remove this and remaining certificates in the chain.
					while (certificateChain_.Count > i)
						ILOG.J2CsMapping.Collections.Collections.RemoveAt(certificateChain_,i);
	
					return null;
				} else {
					logger_.log(ILOG.J2CsMapping.Util.Logging.Level.FINE, "OK signature for certificate `{0}`",
							certificateToValidate.getName().toUri());
					validatedCertificate = certificateToValidate;
				}
			}
	
			return validatedCertificate;
		}
	
		/// <summary>
		/// Get the internal certificateChain_. This is only called by the Validator
		/// class.
		/// </summary>
		///
		/// <returns>The internal certificateChain_.</returns>
		public ArrayList<CertificateV2> getCertificateChain_() {
			return certificateChain_;
		}
	
		/// <summary>
		/// Each certificate in the chain signs the next certificate. The last
		/// certificate signs the original packet.
		/// </summary>
		///
		private readonly ArrayList<CertificateV2> certificateChain_;
		private readonly HashedSet<Name> seenCertificateNames_;
		private bool hasOutcome_;
		private bool outcome_;
		private static readonly Logger logger_ = ILOG.J2CsMapping.Util.Logging.Logger
				.getLogger(typeof(ValidationState).FullName);
		// This is to force an import of net.named_data.jndn.util.
		private static Common dummyCommon_ = new Common();
	}
}
