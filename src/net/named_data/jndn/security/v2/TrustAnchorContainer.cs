// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017-2018 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security.v2 {
	
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// A TrustAnchorContainer represents a container for trust anchors.
	/// There are two kinds of anchors:
	/// static anchors that are permanent for the lifetime of the container, and
	/// dynamic anchors that are periodically updated.
	/// Trust anchors are organized in groups. Each group has a unique group id.
	/// The same anchor certificate (same name without considering the implicit
	/// digest) can be inserted into multiple groups, but no more than once into each.
	/// Dynamic groups are created using the appropriate TrustAnchorContainer.insert
	/// method. Once created, the dynamic anchor group cannot be updated.
	/// The returned pointer to Certificate from `find` methods is only guaranteed to
	/// be valid until the next invocation of `find` and may be invalidated
	/// afterwards.
	/// </summary>
	///
	public class TrustAnchorContainer {
		public TrustAnchorContainer() {
			this.groups_ = new Hashtable<String, TrustAnchorGroup>();
			this.anchors_ = new TrustAnchorContainer.AnchorContainer ();
		}
	
		/// <summary>
		/// Note that even though this is called "Error" to be consistent with the
		/// other libraries, it extends the Java Exception class, not Error.
		/// </summary>
		///
		[Serializable]
		public class Error : Exception {
			public Error(String message) : base(message) {
			}
		}
	
		/// <summary>
		/// Insert a static trust anchor. If the certificate (having the same name
		/// without considering implicit digest) already exists in the group with
		/// groupId, then do nothing.
		/// </summary>
		///
		/// <param name="groupId">The certificate group id.</param>
		/// <param name="certificate">The certificate to insert, which is copied.</param>
		/// <exception cref="TrustAnchorContainer.Error">If groupId is a dynamic anchor group .</exception>
		public void insert(String groupId, CertificateV2 certificate) {
			TrustAnchorGroup group = ILOG.J2CsMapping.Collections.Collections.Get(groups_,groupId);
			if (group == null) {
				group = new StaticTrustAnchorGroup(anchors_, groupId);
				ILOG.J2CsMapping.Collections.Collections.Put(groups_,groupId,group);
			}
	
			if (!(group  is  StaticTrustAnchorGroup))
				throw new TrustAnchorContainer.Error(
						"Cannot add a static anchor to the non-static anchor group "
								+ groupId);
	
			((StaticTrustAnchorGroup) group).add(certificate);
		}
	
		/// <summary>
		/// Insert dynamic trust anchors from the path.
		/// </summary>
		///
		/// <param name="groupId">The certificate group id, which must not be empty.</param>
		/// <param name="path">The path to load the trust anchors.</param>
		/// <param name="refreshPeriod">updated when find is called.</param>
		/// <param name="isDirectory"></param>
		/// <exception cref="System.ArgumentException">If refreshPeriod is not positive.</exception>
		/// <exception cref="TrustAnchorContainer.Error">a group with groupId already exists</exception>
		public void insert(String groupId, String path, double refreshPeriod,
				bool isDirectory) {
			if (groups_.Contains(groupId))
				throw new TrustAnchorContainer.Error(
						"Cannot create the dynamic group, because group " + groupId
								+ " already exists");
	
			ILOG.J2CsMapping.Collections.Collections.Put(groups_,groupId,new DynamicTrustAnchorGroup(anchors_, groupId,
							path, refreshPeriod, isDirectory));
		}
	
		/// <summary>
		/// Call the main insert where isDirectory is false.
		/// </summary>
		///
		public void insert(String groupId, String path, double refreshPeriod) {
			insert(groupId, path, refreshPeriod, false);
		}
	
		/// <summary>
		/// Remove all static and dynamic anchors.
		/// </summary>
		///
		public void clear() {
			groups_.clear();
			anchors_.clear();
		}
	
		/// <summary>
		/// Search for a certificate across all groups (longest prefix match).
		/// </summary>
		///
		/// <param name="keyName">The key name prefix for searching for the certificate.</param>
		/// <returns>The found certificate, or null if not found.</returns>
		public CertificateV2 find(Name keyName) {
			refresh();
	
			Name nameKey = (Name) anchors_.anchorsByName_.ceilingKey(keyName);
			if (nameKey == null)
				return null;
			CertificateV2 certificate = (CertificateV2) anchors_.anchorsByName_[nameKey];
			if (!keyName.isPrefixOf(certificate.getName()))
				return null;
			return certificate;
		}
	
		/// <summary>
		/// Find a certificate for the given interest.
		/// </summary>
		///
		/// <param name="interest">The input interest packet.</param>
		/// <returns>The found certificate, or null if not found.</returns>
		/// @note Interest with implicit digest is not supported.
		/// @note ChildSelector is not supported.
		public CertificateV2 find(Interest interest) {
			refresh();
	
			Name firstKey = (Name) anchors_.anchorsByName_.ceilingKey(interest
					.getName());
			if (firstKey == null)
				return null;
	
			/* foreach */
			foreach (Object key  in  anchors_.anchorsByName_.navigableKeySet().tailSet(
					firstKey)) {
				CertificateV2 certificate = (CertificateV2) anchors_.anchorsByName_[(Name) key];
				if (!interest.getName().isPrefixOf(certificate.getName()))
					break;
	
				try {
					if (interest.matchesData(certificate))
						return certificate;
				} catch (EncodingException ex) {
					// We don't expect this to happen.
					throw new Exception("Error in matchesData: " + ex);
				}
			}
	
			return null;
		}
	
		/// <summary>
		/// Get the trust anchor group for the groupId.
		/// </summary>
		///
		/// <param name="groupId">The group ID.</param>
		/// <returns>The trust anchor group.</returns>
		/// <exception cref="TrustAnchorContainer.Error">if the groupId does not exist.</exception>
		internal TrustAnchorGroup getGroup(String groupId) {
			TrustAnchorGroup group = ILOG.J2CsMapping.Collections.Collections.Get(groups_,groupId);
			if (group == null)
				throw new TrustAnchorContainer.Error("Trust anchor group "
						+ groupId + " does not exist");
	
			return group;
		}
	
		/// <summary>
		/// Get the number of trust anchors across all groups.
		/// </summary>
		///
		/// <returns>The number of trust anchors.</returns>
		public int size() {
			return anchors_.size();
		}
	
		private class AnchorContainer : CertificateContainerInterface {
			public AnchorContainer() {
				this.anchorsByName_ = new SortedList();
			}
	
			/// <summary>
			/// Add the certificate to the container.
			/// </summary>
			///
			/// <param name="certificate">The certificate to add, which is copied.</param>
			public override void add(CertificateV2 certificate) {
				CertificateV2 certificateCopy;
				try {
					certificateCopy = new CertificateV2(certificate);
				} catch (CertificateV2.Error ex) {
					// We don't expect this from the copy constructor.
					throw new Exception(
							"Error in CertificateV2 copy constructor: " + ex);
				}
				ILOG.J2CsMapping.Collections.Collections.Put(anchorsByName_,certificateCopy.getName(),certificateCopy);
			}
	
			/// <summary>
			/// Remove the certificate with the given name. If the name does not exist,
			/// do nothing.
			/// </summary>
			///
			/// <param name="certificateName">The name of the certificate.</param>
			public override void remove(Name certificateName) {
				ILOG.J2CsMapping.Collections.Collections.Remove(anchorsByName_,certificateName);
			}
	
			/// <summary>
			/// Clear all certificates.
			/// </summary>
			///
			internal void clear() {
				anchorsByName_.clear();
			}
	
			/// <summary>
			/// Get the number of certificates in the container.
			/// </summary>
			///
			/// <returns>The number of certificates.</returns>
			internal int size() {
				return anchorsByName_.Count;
			}
	
			public readonly SortedList anchorsByName_;
		} 
	
		private void refresh() {
			/* foreach */
			foreach (TrustAnchorGroup group  in  groups_.Values)
				group.refresh();
		}
	
		private readonly Hashtable<String, TrustAnchorGroup> groups_;
		private readonly TrustAnchorContainer.AnchorContainer  anchors_;
		// This is to force an import of net.named_data.jndn.util.
		private static Common dummyCommon_ = new Common();
	}
}
