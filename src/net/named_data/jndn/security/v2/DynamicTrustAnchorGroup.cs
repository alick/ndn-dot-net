// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017-2018 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security.v2 {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// The DynamicTrustAnchorGroup class extends TrustAnchorGroup to implement a
	/// dynamic trust anchor group.
	/// </summary>
	///
	public class DynamicTrustAnchorGroup : TrustAnchorGroup {
		/// <summary>
		/// Create a dynamic trust anchor group.
		/// This loads all the certificates from the path and will refresh certificates
		/// every refreshPeriod milliseconds.
		/// Note that refresh is not scheduled, but is performed upon each "find"
		/// operations.
		/// When isDirectory is false and the path doesn't point to a valid certificate
		/// (the file doesn't exist or the content is not a valid certificate), then
		/// the dynamic anchor group will be empty until the file gets created. If the
		/// file disappears or gets corrupted, the anchor group becomes empty.
		/// When isDirectory is true and the path doesn't point to a valid folder, the
		/// folder is empty, or it doesn't contain valid certificates, then the group
		/// will be empty until certificate files are placed in the folder. If the
		/// folder is removed, becomes empty, or no longer contains valid certificates,
		/// then the anchor group becomes empty.
		/// Upon refresh, the existing certificates are not changed.
		/// </summary>
		///
		/// <param name="certificateContainer"></param>
		/// <param name="id">The group id.</param>
		/// <param name="path">be loaded.</param>
		/// <param name="refreshPeriod"></param>
		/// <param name="isDirectory"></param>
		/// <exception cref="System.ArgumentException">If refreshPeriod is not positive.</exception>
		public DynamicTrustAnchorGroup(
				CertificateContainerInterface certificateContainer, String id,
				String path, double refreshPeriod, bool isDirectory) : base(certificateContainer, id) {
			isDirectory_ = isDirectory;
			path_ = path;
			refreshPeriod_ = refreshPeriod;
			expireTime_ = 0;
			if (refreshPeriod <= 0)
				throw new ArgumentException(
						"Refresh period for the dynamic group must be positive");
	
			logger_.log(ILOG.J2CsMapping.Util.Logging.Level.INFO, "Create a dynamic trust anchor group " + id
					+ " for file/dir " + path + " with refresh time "
					+ refreshPeriod);
			refresh();
		}
	
		/// <summary>
		/// Request a certificate refresh.
		/// </summary>
		///
		public override void refresh() {
			double now = net.named_data.jndn.util.Common.getNowMilliseconds();
			if (expireTime_ > now)
				return;
	
			expireTime_ = now + refreshPeriod_;
			logger_.log(ILOG.J2CsMapping.Util.Logging.Level.INFO, "Reloading the dynamic trust anchor group");
	
			// Save a copy of anchorNames_ .
			HashedSet<Name> oldAnchorNames = new HashedSet<Name>(anchorNames_);
	
			if (!isDirectory_)
				loadCertificate(path_, oldAnchorNames);
			else {
				FileInfo[] allFiles = new FileInfo(path_).listFiles();
				if (allFiles != null) {
					for (int i = 0; i < allFiles.Length; ++i)
						loadCertificate(allFiles[i].FullName,
								oldAnchorNames);
				}
			}
	
			/* foreach */
			// Remove old certificates.
			foreach (Name name  in  oldAnchorNames) {
				ILOG.J2CsMapping.Collections.Collections.Remove(anchorNames_,name);
				certificates_.remove(name);
			}
		}
	
		private void loadCertificate(String file, HashedSet<Name> oldAnchorNames) {
			CertificateV2 certificate = net.named_data.jndn.security.v2.TrustAnchorGroup.readCertificate(file);
			if (certificate != null) {
				if (!ILOG.J2CsMapping.Collections.Collections.Contains(certificate.getName(),anchorNames_)) {
					ILOG.J2CsMapping.Collections.Collections.Add(anchorNames_,certificate.getName());
					certificates_.add(certificate);
				} else
					ILOG.J2CsMapping.Collections.Collections.Remove(oldAnchorNames,certificate.getName());
			}
		}
	
		private readonly bool isDirectory_;
		private readonly String path_;
		private readonly double refreshPeriod_;
		private double expireTime_;
	
		private static readonly Logger logger_ = ILOG.J2CsMapping.Util.Logging.Logger
				.getLogger(typeof(DynamicTrustAnchorGroup).FullName);
		// This is to force an import of net.named_data.jndn.util.
		private static Common dummyCommon_ = new Common();
	}
}
