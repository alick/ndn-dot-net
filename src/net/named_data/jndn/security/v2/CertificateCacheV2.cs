// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2017 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security.v2 {
	
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// A CertificateCacheV2 holds other user's verified certificates in security v2
	/// format CertificateV2. A certificate is removed no later than its NotAfter
	/// time, or maxLifetime after it has been added to the cache.
	/// </summary>
	///
	public class CertificateCacheV2 {
		/// <summary>
		/// Create a CertificateCacheV2.
		/// </summary>
		///
		/// <param name="maxLifetimeMilliseconds"></param>
		public CertificateCacheV2(double maxLifetimeMilliseconds) {
			this.certificatesByName_ = new SortedList();
			maxLifetimeMilliseconds_ = maxLifetimeMilliseconds;
		}
	
		/// <summary>
		/// Create a CertificateCacheV2. Set the maximum time that certificates can
		/// live inside the cache to getDefaultLifetime().
		/// </summary>
		///
		public CertificateCacheV2() {
			this.certificatesByName_ = new SortedList();
			maxLifetimeMilliseconds_ = getDefaultLifetime();
		}
	
		/// <summary>
		/// Insert the certificate into the cache. The inserted certificate will be
		/// removed no later than its NotAfter time, or maxLifetimeMilliseconds given
		/// to the constructor.
		/// </summary>
		///
		/// <param name="certificate">The certificate object, which is copied.</param>
		public void insert(CertificateV2 certificate) {
			// TODO: Implement certificatesByTime_ to support refresh(). There can be
			// multiple certificate for the same removalTime, and adding the same
			// certificate again should update the removalTime.
	
			CertificateV2 certificateCopy = new CertificateV2(certificate);
			ILOG.J2CsMapping.Collections.Collections.Put(certificatesByName_,certificateCopy.getName(),certificateCopy);
		}
	
		/// <summary>
		/// Find the certificate by the given key name.
		/// </summary>
		///
		/// <param name="certificatePrefix"></param>
		/// <returns>The found certificate, or null if not found. You must not modify
		/// the returned object. If you need to modify it, then make a copy.</returns>
		public CertificateV2 find(Name certificatePrefix) {
			if (certificatePrefix.size() > 0
					&& certificatePrefix.get(-1).isImplicitSha256Digest())
				logger_.log(ILOG.J2CsMapping.Util.Logging.Level.FINE,
						"Certificate search using a name with an implicit digest is not yet supported");
	
			// TODO: refresh();
	
			Name entryKey = (Name) certificatesByName_
					.ceilingKey(certificatePrefix);
			if (entryKey == null)
				return null;
	
			CertificateV2 certificate = (CertificateV2) certificatesByName_[entryKey];
			if (!certificatePrefix.isPrefixOf(certificate.getName()))
				return null;
			return certificate;
		}
	
		/// <summary>
		/// Find the certificate by the given interest.
		/// </summary>
		///
		/// <param name="interest">The input interest object.</param>
		/// <returns>The found certificate which matches the interest, or null if not
		/// found. You must not modify the returned object. If you need to modify it,
		/// then make a copy.</returns>
		/// @note ChildSelector is not supported.
		public CertificateV2 find(Interest interest) {
			if (interest.getChildSelector() >= 0)
				logger_.log(
						ILOG.J2CsMapping.Util.Logging.Level.FINE,
						"Certificate search using a ChildSelector is not supported. Searching as if this selector not specified");
	
			if (interest.getName().size() > 0
					&& interest.getName().get(-1).isImplicitSha256Digest())
				logger_.log(ILOG.J2CsMapping.Util.Logging.Level.FINE,
						"Certificate search using a name with an implicit digest is not yet supported");
	
			// TODO: const_cast<CertificateCacheV2*>(this)->refresh();
	
			Name firstKey = (Name) certificatesByName_.ceilingKey(interest
					.getName());
			if (firstKey == null)
				return null;
	
			/* foreach */
			foreach (Object key  in  certificatesByName_.navigableKeySet().tailSet(
					firstKey)) {
				CertificateV2 certificate = (CertificateV2) certificatesByName_[(Name) key];
				if (!interest.getName().isPrefixOf(certificate.getName()))
					break;
	
				if (interest.matchesData(certificate))
					return certificate;
			}
	
			return null;
		}
	
		/// <summary>
		/// Remove the certificate whose name equals the given name. If no such
		/// certificate is in the cache, do nothing.
		/// </summary>
		///
		/// <param name="certificateName">The name of the certificate.</param>
		public void deleteCertificate(Name certificateName) {
			ILOG.J2CsMapping.Collections.Collections.Remove(certificatesByName_,certificateName);
			// TODO: Delete from certificatesByTime_.
		}
	
		/// <summary>
		/// Clear all certificates from the cache.
		/// </summary>
		///
		public void clear() {
			certificatesByName_.clear();
			// TODO: certificatesByTime_.clear();
		}
	
		/// <summary>
		/// Get the default maximum lifetime (1 hour).
		/// </summary>
		///
		/// <returns>The lifetime in milliseconds.</returns>
		public static double getDefaultLifetime() {
			return 3600.0d * 1000;
		}
	
		// Name => CertificateV2.
		private readonly SortedList certificatesByName_;
		internal double maxLifetimeMilliseconds_;
		private static readonly Logger logger_ = ILOG.J2CsMapping.Util.Logging.Logger
				.getLogger(typeof(CertificateCacheV2).FullName);
	
		// This is to force an import of net.named_data.jndn.util.
		private static Common dummyCommon_ = new Common();
	}
}
