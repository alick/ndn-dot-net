// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2014-2016 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security.identity {
	
	using ILOG.J2CsMapping.NIO;
	using ILOG.J2CsMapping.Util;
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.encoding.der;
	using net.named_data.jndn.security;
	using net.named_data.jndn.security.certificate;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// An IdentityManager is the interface of operations related to identity, keys,
	/// and certificates.
	/// </summary>
	///
	public class IdentityManager {
		/// <summary>
		/// Create a new IdentityManager to use the given identity and private key
		/// storage.
		/// </summary>
		///
		/// <param name="identityStorage">An object of a subclass of IdentityStorage.</param>
		/// <param name="privateKeyStorage">An object of a subclass of PrivateKeyStorage.</param>
		public IdentityManager(IdentityStorage identityStorage,
				PrivateKeyStorage privateKeyStorage) {
			identityStorage_ = identityStorage;
			privateKeyStorage_ = privateKeyStorage;
			// Don't call checkTpm() when using a custom PrivateKeyStorage.
		}
	
#if false
		/// <summary>
		/// Create a new IdentityManager to use the given IdentityStorage and
		/// the default PrivateKeyStorage for your system, which is
		/// OSXPrivateKeyStorage for OS X, otherwise FilePrivateKeyStorage.
		/// </summary>
		///
		/// <param name="identityStorage">An object of a subclass of IdentityStorage.</param>
		public IdentityManager(IdentityStorage identityStorage) {
			ConfigFile config;
			try {
				config = new ConfigFile();
			} catch (IOException ex) {
				throw new SecurityException("IOException " + ex.Message);
			}
	
			String[] canonicalTpmLocator = new String[] { null };
			identityStorage_ = identityStorage;
			privateKeyStorage_ = getDefaultPrivateKeyStorage(config,
					canonicalTpmLocator);
	
			checkTpm(canonicalTpmLocator[0]);
		}
	
		/// <summary>
		/// Create a new IdentityManager to use BasicIdentityStorage and
		/// the default PrivateKeyStorage for your system, which is
		/// OSXPrivateKeyStorage for OS X, otherwise FilePrivateKeyStorage.
		/// </summary>
		///
		public IdentityManager() {
			ConfigFile config;
			try {
				config = new ConfigFile();
			} catch (IOException ex) {
				throw new SecurityException("IOException " + ex.Message);
			}
	
			String[] canonicalTpmLocator = new String[] { null };
			identityStorage_ = getDefaultIdentityStorage(config);
			privateKeyStorage_ = getDefaultPrivateKeyStorage(config,
					canonicalTpmLocator);
	
			checkTpm(canonicalTpmLocator[0]);
		}
#endif
	
		/// <summary>
		/// Create an identity by creating a pair of Key-Signing-Key (KSK) for this
		/// identity and a self-signed certificate of the KSK. If a key pair or
		/// certificate for the identity already exists, use it.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="params">The key parameters if a key needs to be generated for the identity.</param>
		/// <returns>The name of the default certificate of the identity.</returns>
		/// <exception cref="System.Security.SecurityException">if the identity has already been created.</exception>
		public Name createIdentityAndCertificate(Name identityName,
				KeyParams paras) {
			identityStorage_.addIdentity(identityName);
	
			Name keyName = null;
			bool generateKey = true;
			try {
				keyName = identityStorage_
						.getDefaultKeyNameForIdentity(identityName);
				PublicKey key = new PublicKey(identityStorage_.getKey(keyName));
				if (key.getKeyType() == paras.getKeyType())
					// The key exists and has the same type, so don't need to generate one.
					generateKey = false;
			} catch (SecurityException ex) {
			}
	
			if (generateKey) {
				keyName = generateKeyPair(identityName, true, paras);
				identityStorage_.setDefaultKeyNameForIdentity(keyName);
			}
	
			Name certName = null;
			bool makeCert = true;
			try {
				certName = identityStorage_
						.getDefaultCertificateNameForKey(keyName);
				// The cert exists, so don't need to make it.
				makeCert = false;
			} catch (SecurityException ex_0) {
			}
	
			if (makeCert) {
				IdentityCertificate selfCert = selfSign(keyName);
				addCertificateAsIdentityDefault(selfCert);
				certName = selfCert.getName();
			}
	
			return certName;
		}
	
		/// <summary>
		/// Create an identity by creating a pair of Key-Signing-Key (KSK) for this
		/// identity and a self-signed certificate of the KSK.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="params">The key parameters if a key needs to be generated for the identity.</param>
		/// <returns>The key name of the auto-generated KSK of the identity.</returns>
		/// <exception cref="System.Security.SecurityException">if the identity has already been created.</exception>
		public Name createIdentity(Name identityName, KeyParams paras) {
			return net.named_data.jndn.security.certificate.IdentityCertificate
					.certificateNameToPublicKeyName(createIdentityAndCertificate(
							identityName, paras));
		}
	
		/// <summary>
		/// Delete the identity from the public and private key storage. If the
		/// identity to be deleted is the current default system default, this will not
		/// delete the identity and will return immediately.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		public void deleteIdentity(Name identityName) {
			try {
				if (identityStorage_.getDefaultIdentity().equals(identityName))
					// Don't delete the default identity!
					return;
			} catch (SecurityException ex) {
				// There is no default identity to check.
			}
	
			// Use ArrayList without generics so it works with older Java compilers.
			ArrayList keysToDelete = new ArrayList();
			identityStorage_.getAllKeyNamesOfIdentity(identityName, keysToDelete,
					true);
			identityStorage_.getAllKeyNamesOfIdentity(identityName, keysToDelete,
					false);
	
			identityStorage_.deleteIdentityInfo(identityName);
	
			for (int i = 0; i < keysToDelete.Count; ++i)
				privateKeyStorage_.deleteKeyPair((Name) keysToDelete[i]);
		}
	
		/// <summary>
		/// Set the default identity.  If the identityName does not exist, then clear
		/// the default identity so that getDefaultIdentity() throws an exception.
		/// </summary>
		///
		/// <param name="identityName">The default identity name.</param>
		public void setDefaultIdentity(Name identityName) {
			identityStorage_.setDefaultIdentity(identityName);
		}
	
		/// <summary>
		/// Get the default identity.
		/// </summary>
		///
		/// <returns>The name of default identity.</returns>
		/// <exception cref="System.Security.SecurityException">if the default identity is not set.</exception>
		public Name getDefaultIdentity() {
			return identityStorage_.getDefaultIdentity();
		}
	
		/// <summary>
		/// Get the certificate of the default identity.
		/// </summary>
		///
		/// <returns>The requested certificate. If not found, return null.</returns>
		public IdentityCertificate getDefaultCertificate() {
			return identityStorage_.getDefaultCertificate();
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <param name="keySize">The size of the key.</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPair(Name identityName, bool isKsk,
				int keySize) {
			Name keyName = generateKeyPair(identityName, isKsk, new RsaKeyParams(
					keySize));
	
			return keyName;
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity and default keySize
		/// 2048.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPair(Name identityName, bool isKsk) {
			return generateRSAKeyPair(identityName, isKsk, 2048);
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity for a
		/// Data-Signing-Key and default keySize 2048.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPair(Name identityName) {
			return generateRSAKeyPair(identityName, false, 2048);
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <param name="keySize">The size of the key.</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPair(Name identityName, bool isKsk,
				int keySize) {
			Name keyName = generateKeyPair(identityName, isKsk, new EcdsaKeyParams(
					keySize));
	
			return keyName;
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity and default keySize
		/// 256.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPair(Name identityName, bool isKsk) {
			return generateEcdsaKeyPair(identityName, isKsk, 256);
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity for a
		/// Data-Signing-Key and default keySize 256.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPair(Name identityName) {
			return generateEcdsaKeyPair(identityName, false, 256);
		}
	
		/// <summary>
		/// Set a key as the default key of an identity. The identity name is inferred
		/// from keyName.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <param name="identityNameCheck"></param>
		public void setDefaultKeyForIdentity(Name keyName,
				Name identityNameCheck) {
			identityStorage_.setDefaultKeyNameForIdentity(keyName,
					identityNameCheck);
		}
	
		/// <summary>
		/// Set a key as the default key of an identity. The identity name is inferred
		/// from keyName.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		public void setDefaultKeyForIdentity(Name keyName) {
			setDefaultKeyForIdentity(keyName, new Name());
		}
	
		/// <summary>
		/// Get the default key for an identity.
		/// </summary>
		///
		/// <param name="identityName"></param>
		/// <returns>The default key name.</returns>
		/// <exception cref="System.Security.SecurityException">if the default key name for the identity is not set.</exception>
		public Name getDefaultKeyNameForIdentity(Name identityName) {
			return identityStorage_.getDefaultKeyNameForIdentity(identityName);
		}
	
		/// <summary>
		/// Get the default key for an identity, inferred from the keyName.
		/// </summary>
		///
		/// <returns>The default key name.</returns>
		/// <exception cref="System.Security.SecurityException">if the default key name for the identity is not set.</exception>
		public Name getDefaultKeyNameForIdentity() {
			return getDefaultKeyNameForIdentity(new Name());
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity and set it as
		/// default key for the identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <param name="keySize">The size of the key.</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPairAsDefault(Name identityName,
				bool isKsk, int keySize) {
			Name keyName = generateKeyPair(identityName, isKsk, new RsaKeyParams(
					keySize));
	
			identityStorage_.setDefaultKeyNameForIdentity(keyName);
	
			return keyName;
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity and set it as
		/// default key for the identity, using the default keySize 2048.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPairAsDefault(Name identityName,
				bool isKsk) {
			return generateRSAKeyPairAsDefault(identityName, isKsk, 2048);
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity and set it as
		/// default key for the identity for a Data-Signing-Key and using the default
		/// keySize 2048.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPairAsDefault(Name identityName) {
			return generateRSAKeyPairAsDefault(identityName, false, 2048);
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity and set it as
		/// default key for the identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <param name="keySize">The size of the key.</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPairAsDefault(Name identityName,
				bool isKsk, int keySize) {
			Name keyName = generateKeyPair(identityName, isKsk, new EcdsaKeyParams(
					keySize));
	
			identityStorage_.setDefaultKeyNameForIdentity(keyName);
	
			return keyName;
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity and set it as
		/// default key for the identity, using the default keySize 256.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPairAsDefault(Name identityName,
				bool isKsk) {
			return generateEcdsaKeyPairAsDefault(identityName, isKsk, 256);
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity and set it as
		/// default key for the identity for a Data-Signing-Key and using the default
		/// keySize 256.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPairAsDefault(Name identityName) {
			return generateEcdsaKeyPairAsDefault(identityName, false, 256);
		}
	
		/// <summary>
		/// Get the public key with the specified name.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <returns>The public key.</returns>
		/// <exception cref="System.Security.SecurityException">if the keyName is not found.</exception>
		public PublicKey getPublicKey(Name keyName) {
			return new PublicKey(identityStorage_.getKey(keyName));
		}
	
		/// <summary>
		/// Create an identity certificate for a public key managed by this IdentityManager.
		/// </summary>
		///
		/// <param name="certificatePrefix">The name of public key to be signed.</param>
		/// <param name="signerCertificateName">The name of signing certificate.</param>
		/// <param name="notBefore"></param>
		/// <param name="notAfter"></param>
		/// <returns>The name of generated identity certificate.</returns>
		public Name createIdentityCertificate(Name certificatePrefix,
				Name signerCertificateName, double notBefore, double notAfter) {
			Name keyName = getKeyNameFromCertificatePrefix(certificatePrefix);
	
			Blob keyBlob = identityStorage_.getKey(keyName);
			PublicKey publicKey = new PublicKey(keyBlob);
	
			IdentityCertificate certificate = createIdentityCertificate(
					certificatePrefix, publicKey, signerCertificateName, notBefore,
					notAfter);
	
			identityStorage_.addCertificate(certificate);
	
			return certificate.getName();
		}
	
		/// <summary>
		/// Use the keyName to get the public key from the identity storage and
		/// prepare an unsigned identity certificate.
		/// </summary>
		///
		/// <param name="keyName">The key name, e.g., `/{identity_name}/ksk-123456`.</param>
		/// <param name="signingIdentity">The signing identity.</param>
		/// <param name="notBefore">See IdentityCertificate.</param>
		/// <param name="notAfter">See IdentityCertificate.</param>
		/// <param name="subjectDescription">on the keyName.</param>
		/// <param name="certPrefix">signingIdentity and the subject identity. If the signingIdentity is a prefix of the subject identity, `KEY` will be inserted after the signingIdentity, otherwise `KEY` is inserted after subject identity (i.e., before `ksk-...`).</param>
		/// <returns>The unsigned IdentityCertificate, or null the public is not in the
		/// identity storage or if the inputs are invalid.</returns>
		public IdentityCertificate prepareUnsignedIdentityCertificate(
				Name keyName, Name signingIdentity, double notBefore,
				double notAfter, IList subjectDescription, Name certPrefix) {
			PublicKey publicKey;
			try {
				publicKey = new PublicKey(identityStorage_.getKey(keyName));
			} catch (SecurityException e) {
				return null;
			}
	
			return prepareUnsignedIdentityCertificate(keyName, publicKey,
					signingIdentity, notBefore, notAfter, subjectDescription,
					certPrefix);
		}
	
		/// <summary>
		/// Use the keyName to get the public key from the identity storage and
		/// prepare an unsigned identity certificate. This infers the certificate name
		/// according to the relation between the signingIdentity and the subject
		/// identity. If the signingIdentity is a prefix of the subject identity, `KEY`
		/// will be inserted after the signingIdentity, otherwise `KEY` is inserted
		/// after subject identity (i.e., before `ksk-...`).
		/// </summary>
		///
		/// <param name="keyName">The key name, e.g., `/{identity_name}/ksk-123456`.</param>
		/// <param name="signingIdentity">The signing identity.</param>
		/// <param name="notBefore">See IdentityCertificate.</param>
		/// <param name="notAfter">See IdentityCertificate.</param>
		/// <param name="subjectDescription">on the keyName.</param>
		/// <returns>The unsigned IdentityCertificate, or null the public is not in the
		/// identity storage or if the inputs are invalid.</returns>
		public IdentityCertificate prepareUnsignedIdentityCertificate(
				Name keyName, Name signingIdentity, double notBefore,
				double notAfter, IList subjectDescription) {
			return prepareUnsignedIdentityCertificate(keyName, signingIdentity,
					notBefore, notAfter, subjectDescription, null);
		}
	
		/// <summary>
		/// Prepare an unsigned identity certificate.
		/// </summary>
		///
		/// <param name="keyName">The key name, e.g., `/{identity_name}/ksk-123456`.</param>
		/// <param name="publicKey">The public key to sign.</param>
		/// <param name="signingIdentity">The signing identity.</param>
		/// <param name="notBefore">See IdentityCertificate.</param>
		/// <param name="notAfter">See IdentityCertificate.</param>
		/// <param name="subjectDescription">on the keyName.</param>
		/// <param name="certPrefix">signingIdentity and the subject identity. If the signingIdentity is a prefix of the subject identity, `KEY` will be inserted after the signingIdentity, otherwise `KEY` is inserted after subject identity (i.e., before `ksk-...`).</param>
		/// <returns>The unsigned IdentityCertificate, or null if the inputs are invalid.</returns>
		public IdentityCertificate prepareUnsignedIdentityCertificate(
				Name keyName, PublicKey publicKey, Name signingIdentity,
				double notBefore, double notAfter, IList subjectDescription,
				Name certPrefix) {
			if (keyName.size() < 1)
				return null;
	
			String tempKeyIdPrefix = keyName.get(-1).toEscapedString();
			if (tempKeyIdPrefix.Length < 4)
				return null;
			String keyIdPrefix = tempKeyIdPrefix.Substring(0,(4)-(0));
			if (!keyIdPrefix.equals("ksk-") && !keyIdPrefix.equals("dsk-"))
				return null;
	
			IdentityCertificate certificate = new IdentityCertificate();
			Name certName = new Name();
	
			if (certPrefix == null) {
				// No certificate prefix hint, so infer the prefix.
				if (signingIdentity.match(keyName))
					certName.append(signingIdentity).append("KEY")
							.append(keyName.getSubName(signingIdentity.size()))
							.append("ID-CERT")
							.appendVersion((long) net.named_data.jndn.util.Common.getNowMilliseconds());
				else
					certName.append(keyName.getPrefix(-1)).append("KEY")
							.append(keyName.get(-1)).append("ID-CERT")
							.appendVersion((long) net.named_data.jndn.util.Common.getNowMilliseconds());
			} else {
				// A cert prefix hint is supplied, so determine the cert name.
				if (certPrefix.match(keyName) && !certPrefix.equals(keyName))
					certName.append(certPrefix).append("KEY")
							.append(keyName.getSubName(certPrefix.size()))
							.append("ID-CERT")
							.appendVersion((long) net.named_data.jndn.util.Common.getNowMilliseconds());
				else
					return null;
			}
	
			certificate.setName(certName);
			certificate.setNotBefore(notBefore);
			certificate.setNotAfter(notAfter);
			certificate.setPublicKeyInfo(publicKey);
	
			if (subjectDescription == null || (subjectDescription.Count==0))
				certificate
						.addSubjectDescription(new CertificateSubjectDescription(
								"2.5.4.41", keyName.getPrefix(-1).toUri()));
			else {
				for (int i = 0; i < subjectDescription.Count; ++i)
					certificate
							.addSubjectDescription((CertificateSubjectDescription) subjectDescription[i]);
			}
	
			try {
				certificate.encode();
			} catch (DerEncodingException ex) {
				throw new SecurityException("DerEncodingException: " + ex);
			} catch (DerDecodingException ex_0) {
				throw new SecurityException("DerDecodingException: " + ex_0);
			}
	
			return certificate;
		}
	
		/// <summary>
		/// Prepare an unsigned identity certificate. This infers the certificate name
		/// according to the relation between the signingIdentity and the subject
		/// identity. If the signingIdentity is a prefix of the subject identity, `KEY`
		/// will be inserted after the signingIdentity, otherwise `KEY` is inserted
		/// after subject identity (i.e., before `ksk-...`).
		/// </summary>
		///
		/// <param name="keyName">The key name, e.g., `/{identity_name}/ksk-123456`.</param>
		/// <param name="publicKey">The public key to sign.</param>
		/// <param name="signingIdentity">The signing identity.</param>
		/// <param name="notBefore">See IdentityCertificate.</param>
		/// <param name="notAfter">See IdentityCertificate.</param>
		/// <param name="subjectDescription">on the keyName.</param>
		/// <returns>The unsigned IdentityCertificate, or null if the inputs are invalid.</returns>
		public IdentityCertificate prepareUnsignedIdentityCertificate(
				Name keyName, PublicKey publicKey, Name signingIdentity,
				double notBefore, double notAfter, IList subjectDescription) {
			return prepareUnsignedIdentityCertificate(keyName, publicKey,
					signingIdentity, notBefore, notAfter, subjectDescription, null);
		}
	
		/// <summary>
		/// Create an identity certificate for a public key supplied by the caller.
		/// </summary>
		///
		/// <param name="certificatePrefix">The name of public key to be signed.</param>
		/// <param name="publicKey">The public key to be signed.</param>
		/// <param name="signerCertificateName">The name of signing certificate.</param>
		/// <param name="notBefore">The notBefore value in the validity field of the generated certificate.</param>
		/// <param name="notAfter">The notAfter vallue in validity field of the generated certificate.</param>
		/// <returns>The generated identity certificate.</returns>
		public IdentityCertificate createIdentityCertificate(
				Name certificatePrefix, PublicKey publicKey,
				Name signerCertificateName, double notBefore, double notAfter) {
			IdentityCertificate certificate = new IdentityCertificate();
			Name keyName = getKeyNameFromCertificatePrefix(certificatePrefix);
	
			Name certificateName = new Name(certificatePrefix);
			certificateName.append("ID-CERT").appendVersion(
					(long) net.named_data.jndn.util.Common.getNowMilliseconds());
	
			certificate.setName(certificateName);
			certificate.setNotBefore(notBefore);
			certificate.setNotAfter(notAfter);
			certificate.setPublicKeyInfo(publicKey);
			certificate.addSubjectDescription(new CertificateSubjectDescription(
					"2.5.4.41", keyName.toUri()));
			try {
				certificate.encode();
			} catch (DerEncodingException ex) {
				throw new SecurityException("DerDecodingException: " + ex);
			} catch (DerDecodingException ex_0) {
				throw new SecurityException("DerEncodingException: " + ex_0);
			}
	
			Sha256WithRsaSignature sha256Sig = new Sha256WithRsaSignature();
	
			KeyLocator keyLocator = new KeyLocator();
			keyLocator.setType(net.named_data.jndn.KeyLocatorType.KEYNAME);
			keyLocator.setKeyName(signerCertificateName);
	
			sha256Sig.setKeyLocator(keyLocator);
	
			certificate.setSignature(sha256Sig);
	
			SignedBlob unsignedData = certificate.wireEncode();
	
			IdentityCertificate signerCertificate;
			try {
				signerCertificate = getCertificate(signerCertificateName);
			} catch (DerDecodingException ex_1) {
				throw new SecurityException("DerDecodingException: " + ex_1);
			}
			Name signerkeyName = signerCertificate.getPublicKeyName();
	
			Blob sigBits = privateKeyStorage_.sign(unsignedData.signedBuf(),
					signerkeyName);
	
			sha256Sig.setSignature(sigBits);
	
			return certificate;
		}
	
		/// <summary>
		/// Add a certificate into the public key identity storage.
		/// </summary>
		///
		/// <param name="certificate"></param>
		public void addCertificate(IdentityCertificate certificate) {
			identityStorage_.addCertificate(certificate);
		}
	
		/// <summary>
		/// Set the certificate as the default for its corresponding key.
		/// </summary>
		///
		/// <param name="certificate">The certificate.</param>
		public void setDefaultCertificateForKey(
				IdentityCertificate certificate) {
			Name keyName = certificate.getPublicKeyName();
	
			if (!identityStorage_.doesKeyExist(keyName))
				throw new SecurityException(
						"No corresponding Key record for certificate!");
	
			identityStorage_.setDefaultCertificateNameForKey(keyName,
					certificate.getName());
		}
	
		/// <summary>
		/// Add a certificate into the public key identity storage and set the
		/// certificate as the default for its corresponding identity.
		/// </summary>
		///
		/// <param name="certificate"></param>
		public void addCertificateAsIdentityDefault(
				IdentityCertificate certificate) {
			identityStorage_.addCertificate(certificate);
	
			Name keyName = certificate.getPublicKeyName();
	
			setDefaultKeyForIdentity(keyName);
	
			setDefaultCertificateForKey(certificate);
		}
	
		/// <summary>
		/// Add a certificate into the public key identity storage and set the
		/// certificate as the default of its corresponding key.
		/// </summary>
		///
		/// <param name="certificate"></param>
		public void addCertificateAsDefault(IdentityCertificate certificate) {
			identityStorage_.addCertificate(certificate);
	
			setDefaultCertificateForKey(certificate);
		}
	
		/// <summary>
		/// Get a certificate with the specified name.
		/// </summary>
		///
		/// <param name="certificateName">The name of the requested certificate.</param>
		/// <returns>the requested certificate.</returns>
		public IdentityCertificate getCertificate(Name certificateName) {
			return identityStorage_.getCertificate(certificateName);
		}
	
		/// <summary>
		/// Get the default certificate name for the specified identity, which will be
		/// used when signing is performed based on identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the specified identity.</param>
		/// <returns>The requested certificate name.</returns>
		/// <exception cref="System.Security.SecurityException">if the default key name for the identity is notset or the default certificate name for the key name is not set.</exception>
		public Name getDefaultCertificateNameForIdentity(Name identityName) {
			return identityStorage_
					.getDefaultCertificateNameForIdentity(identityName);
		}
	
		/// <summary>
		/// Get the default certificate name of the default identity, which will be
		/// used when signing is based on identity and the identity is not specified.
		/// </summary>
		///
		/// <returns>The requested certificate name.</returns>
		/// <exception cref="System.Security.SecurityException">if the default identity is not set or the defaultkey name for the identity is not set or the default certificate name forthe key name is not set.</exception>
		public Name getDefaultCertificateName() {
			return identityStorage_
					.getDefaultCertificateNameForIdentity(getDefaultIdentity());
		}
	
		/// <summary>
		/// Append all the identity names to the nameList.
		/// </summary>
		///
		/// <param name="nameList">Append result names to nameList.</param>
		/// <param name="isDefault"></param>
		public void getAllIdentities(ArrayList nameList, bool isDefault) {
			identityStorage_.getAllIdentities(nameList, isDefault);
		}
	
		/// <summary>
		/// Append all the key names of a particular identity to the nameList.
		/// </summary>
		///
		/// <param name="identityName">The identity name to search for.</param>
		/// <param name="nameList">Append result names to nameList.</param>
		/// <param name="isDefault"></param>
		public void getAllKeyNamesOfIdentity(Name identityName,
				ArrayList nameList, bool isDefault) {
			identityStorage_.getAllKeyNamesOfIdentity(identityName, nameList,
					isDefault);
		}
	
		/// <summary>
		/// Append all the certificate names of a particular key name to the nameList.
		/// </summary>
		///
		/// <param name="keyName">The key name to search for.</param>
		/// <param name="nameList">Append result names to nameList.</param>
		/// <param name="isDefault"></param>
		public void getAllCertificateNamesOfKey(Name keyName, ArrayList nameList,
				bool isDefault) {
			identityStorage_.getAllCertificateNamesOfKey(keyName, nameList,
					isDefault);
		}
	
		/// <summary>
		/// Sign the byte array data based on the certificate name.
		/// </summary>
		///
		/// <param name="buffer">The byte buffer to be signed.</param>
		/// <param name="certificateName">The signing certificate name.</param>
		/// <returns>The generated signature.</returns>
		public Signature signByCertificate(ByteBuffer buffer,
				Name certificateName) {
			DigestAlgorithm[] digestAlgorithm = new DigestAlgorithm[1];
			Signature signature = makeSignatureByCertificate(certificateName,
					digestAlgorithm);
	
			signature.setSignature(privateKeyStorage_.sign(buffer,
					net.named_data.jndn.security.certificate.IdentityCertificate
							.certificateNameToPublicKeyName(certificateName),
					digestAlgorithm[0]));
	
			return signature;
		}
	
		/// <summary>
		/// Sign data packet based on the certificate name.
		/// Use the default WireFormat.getDefaultWireFormat().
		/// </summary>
		///
		/// <param name="data">The Data object to sign and update its signature.</param>
		/// <param name="certificateName"></param>
		public void signByCertificate(Data data, Name certificateName) {
			signByCertificate(data, certificateName,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Sign data packet based on the certificate name.
		/// </summary>
		///
		/// <param name="data">The Data object to sign and update its signature.</param>
		/// <param name="certificateName"></param>
		/// <param name="wireFormat">The WireFormat for calling encodeData.</param>
		public void signByCertificate(Data data, Name certificateName,
				WireFormat wireFormat) {
			DigestAlgorithm[] digestAlgorithm = new DigestAlgorithm[1];
			Signature signature = makeSignatureByCertificate(certificateName,
					digestAlgorithm);
	
			data.setSignature(signature);
			// Encode once to get the signed portion.
			SignedBlob encoding = data.wireEncode(wireFormat);
	
			data.getSignature()
					.setSignature(
							privateKeyStorage_.sign(
									encoding.signedBuf(),
									net.named_data.jndn.security.certificate.IdentityCertificate
											.certificateNameToPublicKeyName(certificateName),
									digestAlgorithm[0]));
	
			// Encode again to include the signature.
			data.wireEncode(wireFormat);
		}
	
		/// <summary>
		/// Append a SignatureInfo to the Interest name, sign the name components and
		/// append a final name component with the signature bits.
		/// </summary>
		///
		/// <param name="interest"></param>
		/// <param name="certificateName">The certificate name of the key to use for signing.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the input.</param>
		public void signInterestByCertificate(Interest interest,
				Name certificateName, WireFormat wireFormat) {
			DigestAlgorithm[] digestAlgorithm = new DigestAlgorithm[1];
			Signature signature = makeSignatureByCertificate(certificateName,
					digestAlgorithm);
	
			// Append the encoded SignatureInfo.
			interest.getName().append(wireFormat.encodeSignatureInfo(signature));
	
			// Append an empty signature so that the "signedPortion" is correct.
			interest.getName().append(new Name.Component());
			// Encode once to get the signed portion, and sign.
			SignedBlob encoding = interest.wireEncode(wireFormat);
			signature.setSignature(privateKeyStorage_.sign(encoding.signedBuf(),
					net.named_data.jndn.security.certificate.IdentityCertificate
							.certificateNameToPublicKeyName(certificateName),
					digestAlgorithm[0]));
	
			// Remove the empty signature and append the real one.
			interest.setName(interest.getName().getPrefix(-1)
					.append(wireFormat.encodeSignatureValue(signature)));
		}
	
		/// <summary>
		/// Wire encode the Data object, digest it and set its SignatureInfo to
		/// a DigestSha256.
		/// </summary>
		///
		/// <param name="data"></param>
		/// <param name="wireFormat">The WireFormat for calling encodeData.</param>
		public void signWithSha256(Data data, WireFormat wireFormat) {
			data.setSignature(new DigestSha256Signature());
	
			// Encode once to get the signed portion.
			SignedBlob encoding = data.wireEncode(wireFormat);
	
			// Digest and set the signature.
			byte[] signedPortionDigest = net.named_data.jndn.util.Common.digestSha256(encoding.signedBuf());
			data.getSignature().setSignature(new Blob(signedPortionDigest, false));
	
			// Encode again to include the signature.
			data.wireEncode(wireFormat);
		}
	
		/// <summary>
		/// Append a SignatureInfo for DigestSha256 to the Interest name, digest the
		/// name components and append a final name component with the signature bits
		/// (which is the digest).
		/// </summary>
		///
		/// <param name="interest"></param>
		/// <param name="wireFormat">A WireFormat object used to encode the input.</param>
		public void signInterestWithSha256(Interest interest,
				WireFormat wireFormat) {
			DigestSha256Signature signature = new DigestSha256Signature();
			// Append the encoded SignatureInfo.
			interest.getName().append(wireFormat.encodeSignatureInfo(signature));
	
			// Append an empty signature so that the "signedPortion" is correct.
			interest.getName().append(new Name.Component());
			// Encode once to get the signed portion.
			SignedBlob encoding = interest.wireEncode(wireFormat);
	
			// Digest and set the signature.
			byte[] signedPortionDigest = net.named_data.jndn.util.Common.digestSha256(encoding.signedBuf());
			signature.setSignature(new Blob(signedPortionDigest, false));
	
			// Remove the empty signature and append the real one.
			interest.setName(interest.getName().getPrefix(-1)
					.append(wireFormat.encodeSignatureValue(signature)));
		}
	
		/// <summary>
		/// Generate a self-signed certificate for a public key.
		/// </summary>
		///
		/// <param name="keyName">The name of the public key.</param>
		/// <returns>The generated certificate.</returns>
		public IdentityCertificate selfSign(Name keyName) {
			IdentityCertificate certificate = new IdentityCertificate();
	
			Blob keyBlob = identityStorage_.getKey(keyName);
			PublicKey publicKey = new PublicKey(keyBlob);
	
			Calendar calendar = ILOG.J2CsMapping.Util.Calendar.getInstance();
			double notBefore = (double) calendar.getTimeInMillis();
			calendar.add(ILOG.J2CsMapping.Util.Calendar.YEAR, 2);
			double notAfter = (double) calendar.getTimeInMillis();
	
			certificate.setNotBefore(notBefore);
			certificate.setNotAfter(notAfter);
	
			Name certificateName = keyName.getPrefix(-1).append("KEY")
					.append(keyName.get(-1)).append("ID-CERT")
					.appendVersion((long) certificate.getNotBefore());
			certificate.setName(certificateName);
	
			certificate.setPublicKeyInfo(publicKey);
			certificate.addSubjectDescription(new CertificateSubjectDescription(
					"2.5.4.41", keyName.toUri()));
			try {
				certificate.encode();
			} catch (DerEncodingException ex) {
				// We don't expect this to happen.
				ILOG.J2CsMapping.Util.Logging.Logger.getLogger(typeof(IdentityManager).FullName).log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
						null, ex);
				return null;
			} catch (DerDecodingException ex_0) {
				// We don't expect this to happen.
				ILOG.J2CsMapping.Util.Logging.Logger.getLogger(typeof(IdentityManager).FullName).log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
						null, ex_0);
				return null;
			}
	
			signByCertificate(certificate, certificate.getName());
	
			return certificate;
		}
	
		/// <summary>
		/// Generate a key pair for the specified identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the specified identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <param name="params">The parameters of the key.</param>
		/// <returns>The name of the generated key.</returns>
		private Name generateKeyPair(Name identityName, bool isKsk,
				KeyParams paras) {
			ILOG.J2CsMapping.Util.Logging.Logger.getLogger(this.GetType().FullName).log(ILOG.J2CsMapping.Util.Logging.Level.INFO,
					"Get new key ID");
			Name keyName = identityStorage_.getNewKeyName(identityName, isKsk);
	
			ILOG.J2CsMapping.Util.Logging.Logger.getLogger(this.GetType().FullName).log(ILOG.J2CsMapping.Util.Logging.Level.INFO,
					"Generate key pair in private storage");
			privateKeyStorage_.generateKeyPair(keyName, paras);
	
			ILOG.J2CsMapping.Util.Logging.Logger.getLogger(this.GetType().FullName).log(ILOG.J2CsMapping.Util.Logging.Level.INFO,
					"Create a key record in public storage");
			PublicKey pubKey = privateKeyStorage_.getPublicKey(keyName);
			identityStorage_.addKey(keyName, paras.getKeyType(),
					pubKey.getKeyDer());
	
			return keyName;
		}
	
		private static Name getKeyNameFromCertificatePrefix(Name certificatePrefix) {
			Name result = new Name();
	
			String keyString = "KEY";
			int i = 0;
			for (; i < certificatePrefix.size(); i++) {
				if (certificatePrefix.get(i).toEscapedString().equals(keyString))
					break;
			}
	
			if (i >= certificatePrefix.size())
				throw new SecurityException(
						"Identity Certificate Prefix does not have a KEY component");
	
			result.append(certificatePrefix.getSubName(0, i));
			result.append(certificatePrefix.getSubName(i + 1,
					certificatePrefix.size() - i - 1));
	
			return result;
		}
	
		/// <summary>
		/// Return a new Signature object based on the signature algorithm of the
		/// public key with keyName (derived from certificateName).
		/// </summary>
		///
		/// <param name="certificateName">The certificate name.</param>
		/// <param name="digestAlgorithm"></param>
		/// <returns>A new object of the correct subclass of Signature.</returns>
		private Signature makeSignatureByCertificate(Name certificateName,
				DigestAlgorithm[] digestAlgorithm) {
			Name keyName = net.named_data.jndn.security.certificate.IdentityCertificate
					.certificateNameToPublicKeyName(certificateName);
			PublicKey publicKey = privateKeyStorage_.getPublicKey(keyName);
			KeyType keyType = publicKey.getKeyType();
	
			if (keyType == net.named_data.jndn.security.KeyType.RSA) {
				Sha256WithRsaSignature signature = new Sha256WithRsaSignature();
				digestAlgorithm[0] = net.named_data.jndn.security.DigestAlgorithm.SHA256;
	
				signature.getKeyLocator().setType(net.named_data.jndn.KeyLocatorType.KEYNAME);
				signature.getKeyLocator().setKeyName(certificateName.getPrefix(-1));
	
				return signature;
			} else if (keyType == net.named_data.jndn.security.KeyType.ECDSA) {
				Sha256WithEcdsaSignature signature_0 = new Sha256WithEcdsaSignature();
				digestAlgorithm[0] = net.named_data.jndn.security.DigestAlgorithm.SHA256;
	
				signature_0.getKeyLocator().setType(net.named_data.jndn.KeyLocatorType.KEYNAME);
				signature_0.getKeyLocator().setKeyName(certificateName.getPrefix(-1));
	
				return signature_0;
			} else
				throw new SecurityException("Key type is not recognized");
		}
	
#if false
		/// <summary>
		/// Get the IdentityStorage from the pib value in the configuration file if
		/// supplied. Otherwise, get the default for this platform.
		/// </summary>
		///
		/// <param name="config">The configuration file to check.</param>
		/// <returns>A new IdentityStorage.</returns>
		private static IdentityStorage getDefaultIdentityStorage(ConfigFile config) {
			String pibLocator = config.get("pib", "");
	
			if (pibLocator.Length != 0) {
				// Don't support non-default locations for now.
				if (!pibLocator.equals("pib-sqlite3"))
					throw new SecurityException("Invalid config file pib value: "
							+ pibLocator);
			}
	
			return new BasicIdentityStorage();
		}
	
		/// <summary>
		/// Get the PrivateKeyStorage from the tpm value in the configuration file if
		/// supplied. Otherwise, get the default for this platform.
		/// </summary>
		///
		/// <param name="config">The configuration file to check.</param>
		/// <param name="canonicalTpmLocator"></param>
		/// <returns>A new PrivateKeyStorage.</returns>
		private static PrivateKeyStorage getDefaultPrivateKeyStorage(
				ConfigFile config, String[] canonicalTpmLocator) {
			String tpmLocator = config.get("tpm", "");
	
			if (tpmLocator.Length == 0) {
				// Use the system default.
				if (System.Environment.GetEnvironmentVariable("os.name").equals("Mac OS X")) {
					canonicalTpmLocator[0] = "tpm-osxkeychain:";
					throw new SecurityException(
							"OSXPrivateKeyStorage is not implemented yet. You must create an IdentityManager with a different PrivateKeyStorage.");
				} else {
					canonicalTpmLocator[0] = "tpm-file:";
					return new FilePrivateKeyStorage();
				}
			} else if (tpmLocator.equals("tpm-osxkeychain")) {
				canonicalTpmLocator[0] = "tpm-osxkeychain:";
				throw new SecurityException(
						"OSXPrivateKeyStorage is not implemented yet. You must create an IdentityManager with a different PrivateKeyStorage.");
			} else if (tpmLocator.equals("tpm-file")) {
				// Don't support non-default locations for now.
				canonicalTpmLocator[0] = "tpm-file:";
				return new FilePrivateKeyStorage();
			} else
				throw new SecurityException("Invalid config file tpm value: "
						+ tpmLocator);
		}
#endif
	
		/// <summary>
		/// Check that identityStorage_.getTpmLocator() (if defined) matches the
		/// canonicalTpmLocator.
		/// </summary>
		///
		/// <param name="canonicalTpmLocator"></param>
		/// <exception cref="System.Security.SecurityException">if the private key storage does not match.</exception>
		private void checkTpm(String canonicalTpmLocator) {
			String tpmLocator;
			try {
				tpmLocator = identityStorage_.getTpmLocator();
			} catch (SecurityException ex) {
				// The TPM locator is not set in PIB yet.
				return;
			}
	
			// Just check. If a PIB reset is required, expect ndn-cxx/NFD to do it.
			if (tpmLocator.Length != 0 && !tpmLocator.equals(canonicalTpmLocator))
				throw new SecurityException(
						"The TPM locator supplied does not match the TPM locator in the PIB: "
								+ tpmLocator + " != " + canonicalTpmLocator);
		}
	
		private readonly IdentityStorage identityStorage_;
		private readonly PrivateKeyStorage privateKeyStorage_;
	}
}
