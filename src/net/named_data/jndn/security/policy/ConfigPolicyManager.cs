// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2015-2018 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security.policy {
	
	using ILOG.J2CsMapping.Text;
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.encoding.der;
	using net.named_data.jndn.security;
	using net.named_data.jndn.security.certificate;
	using net.named_data.jndn.security.v2;
	using net.named_data.jndn.util;
	using net.named_data.jndn.util.regex;
	
	/// <summary>
	/// A ConfigPolicyManager manages trust according to a configuration file in the
	/// Validator Configuration File Format
	/// (http://redmine.named-data.net/projects/ndn-cxx/wiki/CommandValidatorConf)
	/// Once a rule is matched, the ConfigPolicyManager looks in the
	/// CertificateCache for the certificate matching the name in the KeyLocator
	/// and uses its public key to verify the data packet or signed interest. If the
	/// certificate can't be found, it is downloaded, verified and installed. A chain
	/// of certificates will be followed to a maximum depth.
	/// If the new certificate is accepted, it is used to complete the verification.
	/// The KeyLocators of data packets and signed interests MUST contain a name for
	/// verification to succeed.
	/// </summary>
	///
	public class ConfigPolicyManager : PolicyManager {
		/// <summary>
		/// Create a new ConfigPolicyManager which will act on the rules specified in
		/// the configuration and download unknown certificates when necessary.
		/// This creates a security v1 PolicyManager to verify certificates in format
		/// v1. To verify certificate format v2, use the ConfigPolicyManager with a
		/// CertificateCacheV2.
		/// </summary>
		///
		/// <param name="configFileName">separately call load().</param>
		/// <param name="certificateCache"></param>
		/// <param name="searchDepth"></param>
		/// <param name="graceInterval">public key and the validation time. If omitted, use a default value.</param>
		/// <param name="keyTimestampTtl">value.</param>
		/// <param name="maxTrackedKeys"></param>
		public ConfigPolicyManager(String configFileName,
				CertificateCache certificateCache, int searchDepth,
				double graceInterval, double keyTimestampTtl, int maxTrackedKeys) {
			this.certificateCache_ = new CertificateCache();
					this.certificateCacheV2_ = new CertificateCacheV2();
					this.maxDepth_ = 5;
					this.keyGraceInterval_ = 3000;
					this.keyTimestampTtl_ = 3600000;
					this.maxTrackedKeys_ = 1000;
					this.fixedCertificateCache_ = new Hashtable();
					this.keyTimestamps_ = new Hashtable();
					this.config_ = new BoostInfoParser();
					this.requiresVerification_ = true;
			isSecurityV1_ = true;
			certificateCache_ = certificateCache;
			maxDepth_ = searchDepth;
			keyGraceInterval_ = graceInterval;
			keyTimestampTtl_ = keyTimestampTtl;
			maxTrackedKeys_ = maxTrackedKeys;
	
			reset();
	
			if (configFileName != null && !configFileName.equals(""))
				load(configFileName);
		}
	
		public ConfigPolicyManager(String configFileName,
				CertificateCache certificateCache, int searchDepth,
				double graceInterval, double keyTimestampTtl) {
			this.certificateCache_ = new CertificateCache();
					this.certificateCacheV2_ = new CertificateCacheV2();
					this.maxDepth_ = 5;
					this.keyGraceInterval_ = 3000;
					this.keyTimestampTtl_ = 3600000;
					this.maxTrackedKeys_ = 1000;
					this.fixedCertificateCache_ = new Hashtable();
					this.keyTimestamps_ = new Hashtable();
					this.config_ = new BoostInfoParser();
					this.requiresVerification_ = true;
			isSecurityV1_ = true;
			certificateCache_ = certificateCache;
			maxDepth_ = searchDepth;
			keyGraceInterval_ = graceInterval;
			keyTimestampTtl_ = keyTimestampTtl;
	
			reset();
	
			if (configFileName != null && !configFileName.equals(""))
				load(configFileName);
		}
	
		public ConfigPolicyManager(String configFileName,
				CertificateCache certificateCache, int searchDepth,
				double graceInterval) {
			this.certificateCache_ = new CertificateCache();
					this.certificateCacheV2_ = new CertificateCacheV2();
					this.maxDepth_ = 5;
					this.keyGraceInterval_ = 3000;
					this.keyTimestampTtl_ = 3600000;
					this.maxTrackedKeys_ = 1000;
					this.fixedCertificateCache_ = new Hashtable();
					this.keyTimestamps_ = new Hashtable();
					this.config_ = new BoostInfoParser();
					this.requiresVerification_ = true;
			isSecurityV1_ = true;
			certificateCache_ = certificateCache;
			maxDepth_ = searchDepth;
			keyGraceInterval_ = graceInterval;
	
			reset();
	
			if (configFileName != null && !configFileName.equals(""))
				load(configFileName);
		}
	
		public ConfigPolicyManager(String configFileName,
				CertificateCache certificateCache, int searchDepth) {
			this.certificateCache_ = new CertificateCache();
					this.certificateCacheV2_ = new CertificateCacheV2();
					this.maxDepth_ = 5;
					this.keyGraceInterval_ = 3000;
					this.keyTimestampTtl_ = 3600000;
					this.maxTrackedKeys_ = 1000;
					this.fixedCertificateCache_ = new Hashtable();
					this.keyTimestamps_ = new Hashtable();
					this.config_ = new BoostInfoParser();
					this.requiresVerification_ = true;
			isSecurityV1_ = true;
			certificateCache_ = certificateCache;
			maxDepth_ = searchDepth;
	
			reset();
	
			if (configFileName != null && !configFileName.equals(""))
				load(configFileName);
		}
	
		public ConfigPolicyManager(String configFileName,
				CertificateCache certificateCache) {
			this.certificateCache_ = new CertificateCache();
					this.certificateCacheV2_ = new CertificateCacheV2();
					this.maxDepth_ = 5;
					this.keyGraceInterval_ = 3000;
					this.keyTimestampTtl_ = 3600000;
					this.maxTrackedKeys_ = 1000;
					this.fixedCertificateCache_ = new Hashtable();
					this.keyTimestamps_ = new Hashtable();
					this.config_ = new BoostInfoParser();
					this.requiresVerification_ = true;
			isSecurityV1_ = true;
			certificateCache_ = certificateCache;
	
			reset();
	
			if (configFileName != null && !configFileName.equals(""))
				load(configFileName);
		}
	
		/// <summary>
		/// This creates a security v1 PolicyManager to verify certificates in format
		/// v1. To verify certificate format v2, use the ConfigPolicyManager with a
		/// CertificateCacheV2.
		/// </summary>
		///
		public ConfigPolicyManager(String configFileName) {
			this.certificateCache_ = new CertificateCache();
					this.certificateCacheV2_ = new CertificateCacheV2();
					this.maxDepth_ = 5;
					this.keyGraceInterval_ = 3000;
					this.keyTimestampTtl_ = 3600000;
					this.maxTrackedKeys_ = 1000;
					this.fixedCertificateCache_ = new Hashtable();
					this.keyTimestamps_ = new Hashtable();
					this.config_ = new BoostInfoParser();
					this.requiresVerification_ = true;
			isSecurityV1_ = true;
	
			reset();
	
			if (configFileName != null && !configFileName.equals(""))
				load(configFileName);
		}
	
		/// <summary>
		/// Create a new ConfigPolicyManager which will act on the rules specified in
		/// the configuration and download unknown certificates when necessary. Use
		/// default parameter values. You must call load().
		/// This creates a security v1 PolicyManager to verify certificates in format
		/// v1. To verify certificate format v2, use the ConfigPolicyManager with a
		/// CertificateCacheV2.
		/// </summary>
		///
		public ConfigPolicyManager() {
			this.certificateCache_ = new CertificateCache();
			this.certificateCacheV2_ = new CertificateCacheV2();
			this.maxDepth_ = 5;
			this.keyGraceInterval_ = 3000;
			this.keyTimestampTtl_ = 3600000;
			this.maxTrackedKeys_ = 1000;
			this.fixedCertificateCache_ = new Hashtable();
			this.keyTimestamps_ = new Hashtable();
			this.config_ = new BoostInfoParser();
			this.requiresVerification_ = true;
			isSecurityV1_ = true;
	
			reset();
		}
	
		/// <summary>
		/// Create a new ConfigPolicyManager which will act on the rules specified in
		/// the configuration and download unknown certificates when necessary. This
		/// uses certificate format v2.
		/// </summary>
		///
		/// <param name="configFileName">separately call load().</param>
		/// <param name="certificateCache">A CertificateCacheV2 to hold known certificates.</param>
		/// <param name="searchDepth"></param>
		/// <param name="graceInterval">public key and the validation time. If omitted, use a default value.</param>
		/// <param name="keyTimestampTtl">value.</param>
		/// <param name="maxTrackedKeys"></param>
		public ConfigPolicyManager(String configFileName,
				CertificateCacheV2 certificateCache, int searchDepth,
				double graceInterval, double keyTimestampTtl, int maxTrackedKeys) {
			this.certificateCache_ = new CertificateCache();
					this.certificateCacheV2_ = new CertificateCacheV2();
					this.maxDepth_ = 5;
					this.keyGraceInterval_ = 3000;
					this.keyTimestampTtl_ = 3600000;
					this.maxTrackedKeys_ = 1000;
					this.fixedCertificateCache_ = new Hashtable();
					this.keyTimestamps_ = new Hashtable();
					this.config_ = new BoostInfoParser();
					this.requiresVerification_ = true;
			isSecurityV1_ = false;
			certificateCacheV2_ = certificateCache;
			maxDepth_ = searchDepth;
			keyGraceInterval_ = graceInterval;
			keyTimestampTtl_ = keyTimestampTtl;
			maxTrackedKeys_ = maxTrackedKeys;
	
			reset();
	
			if (configFileName != null && !configFileName.equals(""))
				load(configFileName);
		}
	
		public ConfigPolicyManager(String configFileName,
				CertificateCacheV2 certificateCache, int searchDepth,
				double graceInterval, double keyTimestampTtl) {
			this.certificateCache_ = new CertificateCache();
					this.certificateCacheV2_ = new CertificateCacheV2();
					this.maxDepth_ = 5;
					this.keyGraceInterval_ = 3000;
					this.keyTimestampTtl_ = 3600000;
					this.maxTrackedKeys_ = 1000;
					this.fixedCertificateCache_ = new Hashtable();
					this.keyTimestamps_ = new Hashtable();
					this.config_ = new BoostInfoParser();
					this.requiresVerification_ = true;
			isSecurityV1_ = false;
			certificateCacheV2_ = certificateCache;
			maxDepth_ = searchDepth;
			keyGraceInterval_ = graceInterval;
			keyTimestampTtl_ = keyTimestampTtl;
	
			reset();
	
			if (configFileName != null && !configFileName.equals(""))
				load(configFileName);
		}
	
		public ConfigPolicyManager(String configFileName,
				CertificateCacheV2 certificateCache, int searchDepth,
				double graceInterval) {
			this.certificateCache_ = new CertificateCache();
					this.certificateCacheV2_ = new CertificateCacheV2();
					this.maxDepth_ = 5;
					this.keyGraceInterval_ = 3000;
					this.keyTimestampTtl_ = 3600000;
					this.maxTrackedKeys_ = 1000;
					this.fixedCertificateCache_ = new Hashtable();
					this.keyTimestamps_ = new Hashtable();
					this.config_ = new BoostInfoParser();
					this.requiresVerification_ = true;
			isSecurityV1_ = false;
			certificateCacheV2_ = certificateCache;
			maxDepth_ = searchDepth;
			keyGraceInterval_ = graceInterval;
	
			reset();
	
			if (configFileName != null && !configFileName.equals(""))
				load(configFileName);
		}
	
		public ConfigPolicyManager(String configFileName,
				CertificateCacheV2 certificateCache, int searchDepth) {
			this.certificateCache_ = new CertificateCache();
					this.certificateCacheV2_ = new CertificateCacheV2();
					this.maxDepth_ = 5;
					this.keyGraceInterval_ = 3000;
					this.keyTimestampTtl_ = 3600000;
					this.maxTrackedKeys_ = 1000;
					this.fixedCertificateCache_ = new Hashtable();
					this.keyTimestamps_ = new Hashtable();
					this.config_ = new BoostInfoParser();
					this.requiresVerification_ = true;
			isSecurityV1_ = false;
			certificateCacheV2_ = certificateCache;
			maxDepth_ = searchDepth;
	
			reset();
	
			if (configFileName != null && !configFileName.equals(""))
				load(configFileName);
		}
	
		public ConfigPolicyManager(String configFileName,
				CertificateCacheV2 certificateCache) {
			this.certificateCache_ = new CertificateCache();
					this.certificateCacheV2_ = new CertificateCacheV2();
					this.maxDepth_ = 5;
					this.keyGraceInterval_ = 3000;
					this.keyTimestampTtl_ = 3600000;
					this.maxTrackedKeys_ = 1000;
					this.fixedCertificateCache_ = new Hashtable();
					this.keyTimestamps_ = new Hashtable();
					this.config_ = new BoostInfoParser();
					this.requiresVerification_ = true;
			isSecurityV1_ = false;
			certificateCacheV2_ = certificateCache;
	
			reset();
	
			if (configFileName != null && !configFileName.equals(""))
				load(configFileName);
		}
	
		/// <summary>
		/// Reset the certificate cache and other fields to the constructor state.
		/// </summary>
		///
		public void reset() {
			if (isSecurityV1_)
				certificateCache_.reset();
			else
				certificateCacheV2_.clear();
			fixedCertificateCache_.clear();
			keyTimestamps_.clear();
			requiresVerification_ = true;
			config_ = new BoostInfoParser();
			refreshManager_ = new ConfigPolicyManager.TrustAnchorRefreshManager (isSecurityV1_);
		}
	
		/// <summary>
		/// Call reset() and load the configuration rules from the file.
		/// </summary>
		///
		/// <param name="configFileName"></param>
		public void load(String configFileName) {
			reset();
			config_.read(configFileName);
			loadTrustAnchorCertificates();
		}
	
		/// <summary>
		/// Call reset() and load the configuration rules from the input.
		/// </summary>
		///
		/// <param name="input"></param>
		/// <param name="inputName">Used for log messages, etc.</param>
		public void load(String input, String inputName) {
			reset();
			config_.read(input, inputName);
			loadTrustAnchorCertificates();
		}
	
		/// <summary>
		/// Check if the received data packet can escape from verification and be
		/// trusted as valid. If the configuration file contains the trust anchor
		/// 'any', nothing is verified.
		/// </summary>
		///
		/// <param name="data">The received data packet.</param>
		/// <returns>true if the data does not need to be verified to be trusted as
		/// valid, otherwise false.</returns>
		public sealed override bool skipVerifyAndTrust(Data data) {
			return !requiresVerification_;
		}
	
		/// <summary>
		/// Check if the received signed interest can escape from verification and be
		/// trusted as valid. If the configuration file contains the trust anchor
		/// 'any', nothing is verified.
		/// </summary>
		///
		/// <param name="interest">The received interest.</param>
		/// <returns>true if the interest does not need to be verified to be trusted as
		/// valid, otherwise false.</returns>
		public sealed override bool skipVerifyAndTrust(Interest interest) {
			return !requiresVerification_;
		}
	
		/// <summary>
		/// Check if this PolicyManager has a verification rule for the received data.
		/// If the configuration file contains the trust anchor 'any', nothing is
		/// verified.
		/// </summary>
		///
		/// <param name="data">The received data packet.</param>
		/// <returns>true if the data must be verified, otherwise false.</returns>
		public sealed override bool requireVerify(Data data) {
			return requiresVerification_;
		}
	
		/// <summary>
		/// Check if this PolicyManager has a verification rule for the received signed
		/// interest.
		/// If the configuration file contains the trust anchor 'any', nothing is
		/// verified.
		/// </summary>
		///
		/// <param name="interest">The received interest.</param>
		/// <returns>true if the interest must be verified, otherwise false.</returns>
		public sealed override bool requireVerify(Interest interest) {
			return requiresVerification_;
		}
	
		/// <summary>
		/// Check whether the received data packet complies with the verification policy,
		/// and get the indication of the next verification step.
		/// </summary>
		///
		/// <param name="data">The Data object with the signature to check.</param>
		/// <param name="stepCount"></param>
		/// <param name="onVerified">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onValidationFailed">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <returns>the indication of next verification step, null if there is no
		/// further step.</returns>
		public sealed override ValidationRequest checkVerificationPolicy(Data data,
				int stepCount, OnVerified onVerified,
				OnDataValidationFailed onValidationFailed) {
			String[] failureReason = new String[] { "unknown" };
			Interest certificateInterest;
			try {
				certificateInterest = getCertificateInterest(stepCount, "data",
						data.getName(), data.getSignature(), failureReason);
			} catch (CertificateV2.Error ex) {
				throw new SecurityException(ex.Message);
			} catch (NdnRegexMatcherBase.Error ex_0) {
				throw new SecurityException(
						"ConfigPolicyManager: Error in getCertificateInterest:"
								+ ex_0);
			}
			if (certificateInterest == null) {
				try {
					onValidationFailed.onDataValidationFailed(data,
							failureReason[0]);
				} catch (Exception ex_1) {
					logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onDataValidationFailed", ex_1);
				}
				return null;
			}
	
			if (certificateInterest.getName().size() > 0)
				return new ValidationRequest(certificateInterest,
						new ConfigPolicyManager.OnCertificateDownloadComplete (this, data, stepCount,
								onVerified, onValidationFailed),
						onValidationFailed, 2, stepCount + 1);
			else {
				// Certificate is known. Verify the signature.
				// wireEncode returns the cached encoding if available.
				if (verify(data.getSignature(), data.wireEncode(), failureReason)) {
					try {
						onVerified.onVerified(data);
					} catch (Exception ex_2) {
						logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onVerified", ex_2);
					}
				} else {
					try {
						onValidationFailed.onDataValidationFailed(data,
								failureReason[0]);
					} catch (Exception ex_3) {
						logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
								"Error in onDataValidationFailed", ex_3);
					}
				}
	
				return null;
			}
		}
	
		/// <summary>
		/// Check whether the received signed interest complies with the verification
		/// policy, and get the indication of the next verification step.
		/// </summary>
		///
		/// <param name="interest">The interest with the signature to check.</param>
		/// <param name="stepCount"></param>
		/// <param name="onVerified">better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onValidationFailed">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <returns>the indication of next verification step, null if there is no
		/// further step.</returns>
		public sealed override ValidationRequest checkVerificationPolicy(Interest interest,
				int stepCount, OnVerifiedInterest onVerified,
				OnInterestValidationFailed onValidationFailed, WireFormat wireFormat) {
			String[] failureReason = new String[] { "unknown" };
			Signature signature = extractSignature(interest, wireFormat,
					failureReason);
			if (signature == null) {
				// Can't get the signature from the interest name.
				try {
					onValidationFailed.onInterestValidationFailed(interest,
							failureReason[0]);
				} catch (Exception ex) {
					logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
							"Error in onInterestValidationFailed", ex);
				}
				return null;
			}
	
			// For command interests, we need to ignore the last 4 components when
			//   matching the name.
			Interest certificateInterest;
			try {
				certificateInterest = getCertificateInterest(stepCount, "interest",
						interest.getName().getPrefix(-4), signature, failureReason);
			} catch (CertificateV2.Error ex_0) {
				throw new SecurityException(ex_0.Message);
			} catch (NdnRegexMatcherBase.Error ex_1) {
				throw new SecurityException(
						"ConfigPolicyManager: Error in getCertificateInterest:"
								+ ex_1);
			}
			if (certificateInterest == null) {
				try {
					onValidationFailed.onInterestValidationFailed(interest,
							failureReason[0]);
				} catch (Exception ex_2) {
					logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
							"Error in onInterestValidationFailed", ex_2);
				}
				return null;
			}
	
			if (certificateInterest.getName().size() > 0)
				return new ValidationRequest(certificateInterest,
						new ConfigPolicyManager.OnCertificateDownloadCompleteForInterest (this, interest,
								stepCount, onVerified, onValidationFailed,
								wireFormat), new ConfigPolicyManager.OnVerifyInterestFailedWrapper (
								onValidationFailed, interest), 2, stepCount + 1);
			else {
				// For interests, we must check that the timestamp is fresh enough.
				// This is done after (possibly) downloading the certificate to avoid filling
				// the cache with bad keys.
				Name signatureName = net.named_data.jndn.KeyLocator.getFromSignature(signature)
						.getKeyName();
				Name keyName;
				if (isSecurityV1_)
					keyName = net.named_data.jndn.security.certificate.IdentityCertificate
							.certificateNameToPublicKeyName(signatureName);
				else
					// For security V2, the KeyLocator name is already the key name.
					keyName = signatureName;
				double timestamp = interest.getName().get(-4).toNumber();
	
				if (!interestTimestampIsFresh(keyName, timestamp, failureReason)) {
					try {
						onValidationFailed.onInterestValidationFailed(interest,
								failureReason[0]);
					} catch (Exception ex_3) {
						logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
								"Error in onInterestValidationFailed", ex_3);
					}
					return null;
				}
	
				// Certificate is known. Verify the signature.
				// wireEncode returns the cached encoding if available.
				if (verify(signature, interest.wireEncode(), failureReason)) {
					try {
						onVerified.onVerifiedInterest(interest);
					} catch (Exception ex_4) {
						logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onVerifiedInterest", ex_4);
					}
					updateTimestampForKey(keyName, timestamp);
				} else {
					try {
						onValidationFailed.onInterestValidationFailed(interest,
								failureReason[0]);
					} catch (Exception ex_5) {
						logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
								"Error in onInterestValidationFailed", ex_5);
					}
				}
	
				return null;
			}
		}
	
		/// <summary>
		/// Override to always indicate that the signing certificate name and data name
		/// satisfy the signing policy.
		/// </summary>
		///
		/// <param name="dataName">The name of data to be signed.</param>
		/// <param name="certificateName">The name of signing certificate.</param>
		/// <returns>true to indicate that the signing certificate can be used to sign
		/// the data.</returns>
		public sealed override bool checkSigningPolicy(Name dataName, Name certificateName) {
			return true;
		}
	
		/// <summary>
		/// Infer the signing identity name according to the policy. If the signing
		/// identity cannot be inferred, return an empty name.
		/// </summary>
		///
		/// <param name="dataName">The name of data to be signed.</param>
		/// <returns>The signing identity or an empty name if cannot infer.</returns>
		public sealed override Name inferSigningIdentity(Name dataName) {
			throw new NotSupportedException(
					"ConfigPolicyManager.inferSigningIdentity is not implemented");
		}
	
		/// <summary>
		/// TrustAnchorRefreshManager manages the trust-anchor certificates, including
		/// refresh.
		/// </summary>
		///
		private class TrustAnchorRefreshManager {
			public TrustAnchorRefreshManager(bool isSecurityV1) {
				this.certificateCache_ = new CertificateCache();
				this.certificateCacheV2_ = new CertificateCacheV2();
				this.refreshDirectories_ = new Hashtable();
				isSecurityV1_ = isSecurityV1;
			}
	
			public static IdentityCertificate loadIdentityCertificateFromFile(
					String filename) {
				StringBuilder encodedData = new StringBuilder();
	
				try {
					TextReader certFile = new FileReader(
											filename);
					// Use "try/finally instead of "try-with-resources" or "using"
					// which are not supported before Java 7.
					try {
						String line;
						while ((line = certFile.readLine()) != null)
							encodedData.append(line);
					} finally {
						certFile.close();
					}
				} catch (FileNotFoundException ex) {
					throw new SecurityException(
							"Can't find IdentityCertificate file " + filename
									+ ": " + ex.Message);
				} catch (IOException ex_0) {
					throw new SecurityException(
							"Error reading IdentityCertificate file " + filename
									+ ": " + ex_0.Message);
				}
	
				byte[] decodedData = net.named_data.jndn.util.Common.base64Decode(encodedData.toString());
				IdentityCertificate cert = new IdentityCertificate();
				try {
					cert.wireDecode(new Blob(decodedData, false));
				} catch (EncodingException ex_1) {
					throw new SecurityException(
							"Can't decode the IdentityCertificate from file "
									+ filename + ": " + ex_1.Message);
				}
				return cert;
			}
	
			public static CertificateV2 loadCertificateV2FromFile(String filename) {
				StringBuilder encodedData = new StringBuilder();
	
				try {
					TextReader certFile = new FileReader(
											filename);
					// Use "try/finally instead of "try-with-resources" or "using"
					// which are not supported before Java 7.
					try {
						String line;
						while ((line = certFile.readLine()) != null)
							encodedData.append(line);
					} finally {
						certFile.close();
					}
				} catch (FileNotFoundException ex) {
					throw new SecurityException("Can't find the certificate file "
							+ filename + ": " + ex.Message);
				} catch (IOException ex_0) {
					throw new SecurityException(
							"Error reading the certificate file " + filename + ": "
									+ ex_0.Message);
				}
	
				byte[] decodedData = net.named_data.jndn.util.Common.base64Decode(encodedData.toString());
				CertificateV2 cert = new CertificateV2();
				try {
					cert.wireDecode(new Blob(decodedData, false));
				} catch (EncodingException ex_1) {
					throw new SecurityException(
							"Can't decode the certificate from file " + filename
									+ ": " + ex_1.Message);
				}
				return cert;
			}
	
			public IdentityCertificate getCertificate(Name certificateName) {
				if (!isSecurityV1_)
					throw new SecurityException(
							"getCertificate: For security v2, use getCertificateV2()");
	
				// Assume the timestamp is already removed.
				return certificateCache_.getCertificate(certificateName);
			}
	
			public CertificateV2 getCertificateV2(Name certificateName) {
				if (isSecurityV1_)
					throw new SecurityException(
							"getCertificateV2: For security v1, use getCertificate()");
	
				// Assume the timestamp is already removed.
				return certificateCacheV2_.find(certificateName);
			}
	
			public void addDirectory(String directoryName, double refreshPeriod) {
				FileInfo[] allFiles = new FileInfo(directoryName).listFiles();
				if (allFiles == null)
					throw new SecurityException("Cannot find files in directory "
							+ directoryName);
	
				// Use ArrayList without generics so it works with older Java compilers.
				ArrayList certificateNames = new ArrayList();
				for (int i = 0; i < allFiles.Length; ++i) {
					FileInfo file = allFiles[i];
	
					if (isSecurityV1_) {
						IdentityCertificate cert;
						try {
							cert = loadIdentityCertificateFromFile(file.FullName);
						} catch (Exception ex) {
							// Allow files that are not certificates.
							continue;
						}
	
						// Cut off the timestamp so it matches KeyLocator Name format.
						String certUri = cert.getName().getPrefix(-1).toUri();
						certificateCache_.insertCertificate(cert);
						ILOG.J2CsMapping.Collections.Collections.Add(certificateNames,certUri);
					} else {
						CertificateV2 cert_0;
						try {
							cert_0 = loadCertificateV2FromFile(file.FullName);
						} catch (Exception ex_1) {
							// Allow files that are not certificates.
							continue;
						}
	
						// Get the key name since this is in the KeyLocator.
						String certUri_2 = net.named_data.jndn.security.v2.CertificateV2.extractKeyNameFromCertName(
								cert_0.getName()).toUri();
						certificateCacheV2_.insert(cert_0);
						ILOG.J2CsMapping.Collections.Collections.Add(certificateNames,certUri_2);
					}
				}
	
				ILOG.J2CsMapping.Collections.Collections.Put(refreshDirectories_,directoryName,new net.named_data.jndn.security.policy.ConfigPolicyManager.TrustAnchorRefreshManager.DirectoryInfo (
									certificateNames, net.named_data.jndn.util.Common.getNowMilliseconds()
											+ refreshPeriod, refreshPeriod));
			}
	
			public void refreshAnchors() {
				double refreshTime = net.named_data.jndn.util.Common.getNowMilliseconds();
	
				// We will modify refreshDirectories_ in the loop, so copy its keys.
				Object[] directories = ILOG.J2CsMapping.Collections.Collections.ToArray(new ILOG.J2CsMapping.Collections.ListSet(refreshDirectories_.Keys));
				for (int iDirectory = 0; iDirectory < directories.Length; ++iDirectory) {
					String directory = (String) directories[iDirectory];
					net.named_data.jndn.security.policy.ConfigPolicyManager.TrustAnchorRefreshManager.DirectoryInfo  info = (net.named_data.jndn.security.policy.ConfigPolicyManager.TrustAnchorRefreshManager.DirectoryInfo ) ILOG.J2CsMapping.Collections.Collections.Get(refreshDirectories_,directory);
	
					double nextRefreshTime = info.nextRefresh_;
					if (nextRefreshTime <= refreshTime) {
						ArrayList certificateList = (ArrayList) info.certificateNames_
								.Clone();
	
						// Delete the certificates associated with this directory if possible
						//   then re-import.
						// IdentityStorage subclasses may not support deletion.
						for (int i = 0; i < certificateList.Count; ++i) {
							if (isSecurityV1_)
								certificateCache_.deleteCertificate(new Name(
										(String) certificateList[i]));
							else {
								// The name in the CertificateCacheV2 contains the but the name in
								// the certificateList does not, so find the certificate based on
								// the prefix first.
								CertificateV2 foundCertificate = certificateCacheV2_
										.find(new Name((String) certificateList[i]));
								if (foundCertificate != null)
									certificateCacheV2_
											.deleteCertificate(foundCertificate
													.getName());
							}
						}
	
						addDirectory(directory, info.refreshPeriod_);
					}
				}
			}
	
			private class DirectoryInfo {
				public DirectoryInfo(ArrayList certificateNames,
						double nextRefresh, double refreshPeriod) {
					certificateNames_ = certificateNames;
					nextRefresh_ = nextRefresh;
					refreshPeriod_ = refreshPeriod;
				}
	
				internal ArrayList certificateNames_; // of String.
				internal double nextRefresh_;
				internal double refreshPeriod_;
			} 
	
			private readonly bool isSecurityV1_;
			private readonly CertificateCache certificateCache_;
			private readonly CertificateCacheV2 certificateCacheV2_;
			// refreshDirectories_ maps the directory name to a DirectoryInfo of
			// the certificate names so they can be deleted when necessary, and the
			// next refresh time.
			// Use HashMap without generics so it works with older Java compilers.
			private readonly Hashtable refreshDirectories_;
		} 
	
		/// <summary>
		/// The configuration file allows 'trust anchor' certificates to be preloaded.
		/// The certificates may also be loaded from a directory, and if the 'refresh'
		/// option is set to an interval, the certificates are reloaded at the
		/// specified interval
		/// </summary>
		///
		private void loadTrustAnchorCertificates() {
			ArrayList<BoostInfoTree> anchors = config_.getRoot().get(
					"validator/trust-anchor");
	
			for (int i = 0; i < anchors.Count; ++i) {
				BoostInfoTree anchor = anchors[i];
	
				String typeName = anchor.getFirstValue("type");
				bool isPath = false;
				String certID = null;
				if (typeName.equals("file")) {
					certID = anchor.getFirstValue("file-name");
					isPath = true;
				} else if (typeName.equals("base64")) {
					certID = anchor.getFirstValue("base64-string");
					isPath = false;
				} else if (typeName.equals("dir")) {
					String dirName = anchor.getFirstValue("dir");
	
					double refreshPeriod = 0;
					ArrayList<BoostInfoTree> refreshTrees = anchor.get("refresh");
					if (refreshTrees.Count >= 1) {
						String refreshPeriodStr = refreshTrees[0].getValue();
	
						Pattern regex1 = ILOG.J2CsMapping.Text.Pattern.Compile("(\\d+)([hms])");
						Matcher refreshMatch = regex1.Matcher(refreshPeriodStr);
						if (!refreshMatch.Find())
							refreshPeriod = 0;
						else {
							refreshPeriod = Int32.Parse(refreshMatch.Group(1));
							if (!refreshMatch.Group(2).equals("s")) {
								refreshPeriod *= 60;
								if (!refreshMatch.Group(2).equals("m"))
									refreshPeriod *= 60;
							}
						}
					}
	
					// Convert refreshPeriod from seconds to milliseconds.
					refreshManager_.addDirectory(dirName, refreshPeriod * 1000);
					continue;
				} else if (typeName.equals("any")) {
					// This disables all security!
					requiresVerification_ = false;
					break;
				}
	
				if (isSecurityV1_)
					lookupCertificate(certID, isPath);
				else
					lookupCertificateV2(certID, isPath);
			}
		}
	
		/// <summary>
		/// Once a rule is found to match data or a signed interest, the name in the
		/// KeyLocator must satisfy the condition in the 'checker' section of the rule,
		/// else the data or interest is rejected.
		/// </summary>
		///
		/// <param name="signatureName">The certificate name from the KeyLocator.</param>
		/// <param name="objectName">components.</param>
		/// <param name="rule"></param>
		/// <param name="failureReason"></param>
		/// <returns>True if matches.</returns>
		private bool checkSignatureMatch(Name signatureName, Name objectName,
				BoostInfoTree rule, String[] failureReason) {
			BoostInfoTree checker = rule.get("checker")[0];
			String checkerType = checker.getFirstValue("type");
			if (checkerType.equals("fixed-signer")) {
				BoostInfoTree signerInfo = checker.get("signer")[0];
				String signerType = signerInfo.getFirstValue("type");
	
				Name certificateName;
				if (signerType.equals("file")) {
					if (isSecurityV1_) {
						Certificate cert = lookupCertificate(
								signerInfo.getFirstValue("file-name"), true);
						if (cert == null) {
							failureReason[0] = "Can't find fixed-signer certificate file: "
									+ signerInfo.getFirstValue("file-name");
							return false;
						}
						certificateName = cert.getName();
					} else {
						CertificateV2 cert_0 = lookupCertificateV2(
								signerInfo.getFirstValue("file-name"), true);
						if (cert_0 == null) {
							failureReason[0] = "Can't find fixed-signer certificate file: "
									+ signerInfo.getFirstValue("file-name");
							return false;
						}
						certificateName = cert_0.getName();
					}
				} else if (signerType.equals("base64")) {
					if (isSecurityV1_) {
						Certificate cert_1 = lookupCertificate(
								signerInfo.getFirstValue("base64-string"), false);
						if (cert_1 == null) {
							failureReason[0] = "Can't find fixed-signer certificate base64: "
									+ signerInfo.getFirstValue("base64-string");
							return false;
						}
						certificateName = cert_1.getName();
					} else {
						CertificateV2 cert_2 = lookupCertificateV2(
								signerInfo.getFirstValue("base64-string"), false);
						if (cert_2 == null) {
							failureReason[0] = "Can't find fixed-signer certificate base64: "
									+ signerInfo.getFirstValue("base64-string");
							return false;
						}
						certificateName = cert_2.getName();
					}
				} else {
					failureReason[0] = "Unrecognized fixed-signer signerType: "
							+ signerType;
					return false;
				}
	
				if (certificateName.equals(signatureName))
					return true;
				else {
					failureReason[0] = "fixed-signer cert name \""
							+ certificateName.toUri()
							+ "\" does not equal signatureName \""
							+ signatureName.toUri() + "\"";
					return false;
				}
			} else if (checkerType.equals("hierarchical")) {
				// This just means the data/interest name has the signing identity as a prefix.
				// That means everything before "ksk-?" in the key name.
				String identityRegex = "^([^<KEY>]*)<KEY>(<>*)<ksk-.+><ID-CERT>";
				NdnRegexTopMatcher identityMatch = new NdnRegexTopMatcher(
						identityRegex);
				if (identityMatch.match(signatureName)) {
					Name identityPrefix = identityMatch.expand("\\1").append(
							identityMatch.expand("\\2"));
					if (matchesRelation(objectName, identityPrefix, "is-prefix-of"))
						return true;
					else {
						failureReason[0] = "The hierarchical objectName \""
								+ objectName.toUri() + "\" is not a prefix of \""
								+ identityPrefix + "\"";
						return false;
					}
				}
	
				if (!isSecurityV1_) {
					// Check for a security v2 key name.
					String identityRegex2 = "^(<>*)<KEY><>$";
					NdnRegexTopMatcher identityMatch2 = new NdnRegexTopMatcher(
							identityRegex2);
					if (identityMatch2.match(signatureName)) {
						Name identityPrefix_3 = identityMatch2.expand("\\1");
						if (matchesRelation(objectName, identityPrefix_3,
								"is-prefix-of"))
							return true;
						else {
							failureReason[0] = "The hierarchical objectName \""
									+ objectName.toUri()
									+ "\" is not a prefix of \"" + identityPrefix_3
									+ "\"";
							return false;
						}
					}
				}
	
				failureReason[0] = "The hierarchical identityRegex \""
						+ identityRegex + "\" does not match signatureName \""
						+ signatureName.toUri() + "\"";
				return false;
			} else if (checkerType.equals("customized")) {
				BoostInfoTree keyLocatorInfo = checker.get("key-locator")[0];
				// Not checking type - only name is supported.
	
				// Is this a simple relation?
				String simpleRelationType = keyLocatorInfo
						.getFirstValue("relation");
				if (simpleRelationType != null) {
					Name matchName = new Name(keyLocatorInfo.getFirstValue("name"));
					if (matchesRelation(signatureName, matchName,
							simpleRelationType))
						return true;
					else {
						failureReason[0] = "The custom signatureName \""
								+ signatureName.toUri()
								+ "\" does not match matchName \""
								+ matchName.toUri() + "\" using relation "
								+ simpleRelationType;
						return false;
					}
				}
	
				// Is this a simple regex?
				String simpleKeyRegex = keyLocatorInfo.getFirstValue("regex");
				if (simpleKeyRegex != null) {
					if (new NdnRegexTopMatcher(simpleKeyRegex).match(signatureName))
						return true;
					else {
						failureReason[0] = "The custom signatureName \""
								+ signatureName.toUri()
								+ "\" does not regex match simpleKeyRegex \""
								+ simpleKeyRegex + "\"";
						return false;
					}
				}
	
				// Is this a hyper-relation?
				ArrayList<BoostInfoTree> hyperRelationList = keyLocatorInfo
						.get("hyper-relation");
				if (hyperRelationList.Count >= 1) {
					BoostInfoTree hyperRelation = hyperRelationList[0];
	
					String keyRegex = hyperRelation.getFirstValue("k-regex");
					String keyExpansion = hyperRelation.getFirstValue("k-expand");
					String nameRegex = hyperRelation.getFirstValue("p-regex");
					String nameExpansion = hyperRelation.getFirstValue("p-expand");
					String relationType = hyperRelation.getFirstValue("h-relation");
					if (keyRegex != null && keyExpansion != null
							&& nameRegex != null && nameExpansion != null
							&& relationType != null) {
						NdnRegexTopMatcher keyMatch = new NdnRegexTopMatcher(
								keyRegex);
						if (!keyMatch.match(signatureName)) {
							failureReason[0] = "The custom hyper-relation signatureName \""
									+ signatureName.toUri()
									+ "\" does not match the keyRegex \""
									+ keyRegex + "\"";
							return false;
						}
						Name keyMatchPrefix = keyMatch.expand(keyExpansion);
	
						NdnRegexTopMatcher nameMatch = new NdnRegexTopMatcher(
								nameRegex);
						if (!nameMatch.match(objectName)) {
							failureReason[0] = "The custom hyper-relation objectName \""
									+ objectName.toUri()
									+ "\" does not match the nameRegex \""
									+ nameRegex + "\"";
							return false;
						}
						Name nameMatchExpansion = nameMatch.expand(nameExpansion);
	
						if (matchesRelation(nameMatchExpansion, keyMatchPrefix,
								relationType))
							return true;
						else {
							failureReason[0] = "The custom hyper-relation nameMatch \""
									+ nameMatchExpansion.toUri()
									+ "\" does not match the keyMatchPrefix \""
									+ keyMatchPrefix
									+ "\" using relation "
									+ relationType;
							return false;
						}
					}
				}
			}
	
			failureReason[0] = "Unrecognized checkerType: " + checkerType;
			return false;
		}
	
		/// <summary>
		/// Similar to Python expand, return expansion where every \1, \2, etc. is
		/// replaced by match.group(1), match.group(2), etc.  Note: Even though this is
		/// a general utility function, we define it locally because it is only tested
		/// to work in the cases used by this class.
		/// </summary>
		///
		/// <param name="match">The match object from String.match.</param>
		/// <param name="expansion">The string with \1, \2, etc. to replace from match.</param>
		/// <returns>The expanded string.</returns>
		private static String expand(Matcher match, String expansion) {
			String result = "";
			int beginIndex = 0;
			Pattern regex = ILOG.J2CsMapping.Text.Pattern.Compile("\\\\(\\d)");
			Matcher expansionMatcher = regex.Matcher(expansion);
			while (expansionMatcher.Find()) {
				result += expansion.Substring(beginIndex,(expansionMatcher.start())-(beginIndex));
				result += match.Group(Int32.Parse(expansionMatcher.Group(1)));
				beginIndex = expansionMatcher.end();
			}
	
			// Add the substring after the last match.
			result += expansion.Substring(beginIndex,(expansion.Length)-(beginIndex));
			return result;
		}
	
		/// <summary>
		/// This looks up certificates specified as base64-encoded data or file names.
		/// These are cached by filename or encoding to avoid repeated reading of files
		/// or decoding.
		/// </summary>
		///
		/// <param name="certID"></param>
		/// <param name="isPath"></param>
		/// <returns>The IdentityCertificate or null if not found.</returns>
		private IdentityCertificate lookupCertificate(String certID, bool isPath) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"lookupCertificate: For security v2, use lookupCertificateV2()");
	
			IdentityCertificate cert;
	
			if (!fixedCertificateCache_.Contains(certID)) {
				if (isPath)
					// Load the certificate data (base64 encoded IdentityCertificate)
					cert = net.named_data.jndn.security.policy.ConfigPolicyManager.TrustAnchorRefreshManager
							.loadIdentityCertificateFromFile(certID);
				else {
					byte[] certData = net.named_data.jndn.util.Common.base64Decode(certID);
					cert = new IdentityCertificate();
					try {
						cert.wireDecode(new Blob(certData, false));
					} catch (EncodingException ex) {
						throw new SecurityException(
								"Cannot base64 decode the cert data: "
										+ ex.Message);
					}
				}
	
				String certUri = cert.getName().getPrefix(-1).toUri();
				ILOG.J2CsMapping.Collections.Collections.Put(fixedCertificateCache_,certID,certUri);
				certificateCache_.insertCertificate(cert);
			} else
				cert = certificateCache_.getCertificate(new Name(
						(String) ILOG.J2CsMapping.Collections.Collections.Get(fixedCertificateCache_,certID)));
	
			return cert;
		}
	
		/// <summary>
		/// This looks up certificates specified as base64-encoded data or file names.
		/// These are cached by filename or encoding to avoid repeated reading of files
		/// or decoding.
		/// </summary>
		///
		/// <param name="certID"></param>
		/// <param name="isPath"></param>
		/// <returns>The CertificateV2 or null if not found.</returns>
		private CertificateV2 lookupCertificateV2(String certID, bool isPath) {
			if (isSecurityV1_)
				throw new SecurityException(
						"lookupCertificateV2: For security v1, use lookupCertificate()");
	
			CertificateV2 cert;
	
			if (!fixedCertificateCache_.Contains(certID)) {
				if (isPath)
					// Load the certificate data (base64 encoded IdentityCertificate)
					cert = net.named_data.jndn.security.policy.ConfigPolicyManager.TrustAnchorRefreshManager
							.loadCertificateV2FromFile(certID);
				else {
					byte[] certData = net.named_data.jndn.util.Common.base64Decode(certID);
					cert = new CertificateV2();
					try {
						cert.wireDecode(new Blob(certData, false));
					} catch (EncodingException ex) {
						throw new SecurityException(
								"Cannot base64 decode the cert data: "
										+ ex.Message);
					}
				}
	
				String certUri = cert.getName().getPrefix(-1).toUri();
				ILOG.J2CsMapping.Collections.Collections.Put(fixedCertificateCache_,certID,certUri);
				certificateCacheV2_.insert(cert);
			} else
				cert = certificateCacheV2_.find(new Name(
						(String) ILOG.J2CsMapping.Collections.Collections.Get(fixedCertificateCache_,certID)));
	
			return cert;
		}
	
		/// <summary>
		/// Search the configuration file for the first rule that matches the data or
		/// signed interest name. In the case of interests, the name to match should
		/// exclude the timestamp, nonce, and signature components.
		/// </summary>
		///
		/// <param name="objName">The name to be matched.</param>
		/// <param name="matchType">The rule type to match, "data" or "interest".</param>
		/// <returns>The BoostInfoTree for the matching rule, or null if not found.</returns>
		private BoostInfoTree findMatchingRule(Name objName, String matchType) {
			ArrayList<BoostInfoTree> rules = config_.getRoot()
					.get("validator/rule");
			for (int iRule = 0; iRule < rules.Count; ++iRule) {
				BoostInfoTree r = rules[iRule];
	
				if (r.getFirstValue("for").equals(matchType)) {
					bool passed = true;
					ArrayList<BoostInfoTree> filters = r.get("filter");
					if ((filters.Count==0))
						// no filters means we pass!
						return r;
					else {
						for (int iFilter = 0; iFilter < filters.Count; ++iFilter) {
							BoostInfoTree f = filters[iFilter];
	
							// Don't check the type - it can only be name for now.
							// We need to see if this is a regex or a relation.
							String regexPattern = f.getFirstValue("regex");
							if (regexPattern == null) {
								String matchRelation = f.getFirstValue("relation");
								String matchUri = f.getFirstValue("name");
								Name matchName = new Name(matchUri);
								passed = matchesRelation(objName, matchName,
										matchRelation);
							} else
								passed = new NdnRegexTopMatcher(regexPattern)
										.match(objName);
	
							if (!passed)
								break;
						}
	
						if (passed)
							return r;
					}
				}
			}
	
			return null;
		}
	
		/// <summary>
		/// Determines if a name satisfies the relation to another name, based on
		/// matchRelation.
		/// </summary>
		///
		/// <param name="name"></param>
		/// <param name="matchName"></param>
		/// <param name="matchRelation">name as a prefix "is-strict-prefix-of" - passes if the name has the other name as a prefix, and is not equal "equal" - passes if the two names are equal</param>
		/// <returns>True if matches.</returns>
		private static bool matchesRelation(Name name, Name matchName,
				String matchRelation) {
			bool passed = false;
			if (matchRelation.equals("is-strict-prefix-of")) {
				if (matchName.size() == name.size())
					passed = false;
				else if (matchName.match(name))
					passed = true;
			} else if (matchRelation.equals("is-prefix-of")) {
				if (matchName.match(name))
					passed = true;
			} else if (matchRelation.equals("equal")) {
				if (matchName.equals(name))
					passed = true;
			}
	
			return passed;
		}
	
		/// <summary>
		/// Extract the signature information from the interest name.
		/// </summary>
		///
		/// <param name="interest">The interest whose signature is needed.</param>
		/// <param name="wireFormat"></param>
		/// <param name="failureReason"></param>
		/// <returns>A shared_ptr for the Signature object. This is null if can't decode.</returns>
		private static Signature extractSignature(Interest interest,
				WireFormat wireFormat, String[] failureReason) {
			if (interest.getName().size() < 2) {
				failureReason[0] = "The signed interest has less than 2 components: "
						+ interest.getName().toUri();
				return null;
			}
	
			try {
				return wireFormat.decodeSignatureInfoAndValue(interest.getName()
						.get(-2).getValue().buf(), interest.getName().get(-1)
						.getValue().buf(), false);
			} catch (EncodingException ex) {
				failureReason[0] = "Error decoding the signed interest signature: "
						+ ex;
				return null;
			}
		}
	
		/// <summary>
		/// Determine whether the timestamp from the interest is newer than the last
		/// use of this key, or within the grace interval on first use.
		/// </summary>
		///
		/// <param name="keyName">The name of the public key used to sign the interest.</param>
		/// <param name="timestamp">The timestamp extracted from the interest name.</param>
		/// <param name="failureReason"></param>
		/// <returns>True if timestamp is fresh as described above.</returns>
		private bool interestTimestampIsFresh(Name keyName, double timestamp,
				String[] failureReason) {
			String keyNameUri = keyName.toUri();
			if (!keyTimestamps_.Contains(keyNameUri)) {
				double now = net.named_data.jndn.util.Common.getNowMilliseconds();
				double notBefore = now - keyGraceInterval_;
				double notAfter = now + keyGraceInterval_;
	
				if (!(timestamp > notBefore && timestamp < notAfter)) {
					failureReason[0] = "The command interest timestamp is not within the first use grace period of "
							+ keyGraceInterval_ + " milliseconds.";
					return false;
				} else
					return true;
			} else {
				double lastTimestamp = (double) (Double) ILOG.J2CsMapping.Collections.Collections.Get(keyTimestamps_,keyNameUri);
				if (timestamp <= lastTimestamp) {
					failureReason[0] = "The command interest timestamp is not newer than the previous timestamp";
					return false;
				}
				return true;
			}
		}
	
		/// <summary>
		/// Trim the table size down if necessary, and insert/update the latest
		/// interest signing timestamp for the key. Any key which has not been used
		/// within the TTL period is purged. If the table is still too large, the
		/// oldest key is purged.
		/// </summary>
		///
		/// <param name="keyName">The name of the public key used to sign the interest.</param>
		/// <param name="timestamp">The timestamp extracted from the interest name.</param>
		private void updateTimestampForKey(Name keyName, double timestamp) {
			ILOG.J2CsMapping.Collections.Collections.Put(keyTimestamps_,keyName.toUri(),timestamp);
	
			if (keyTimestamps_.Count >= maxTrackedKeys_) {
				double now = net.named_data.jndn.util.Common.getNowMilliseconds();
				double oldestTimestamp = now;
				String oldestKey = "";
	
				// Get the keys to erase without disturbing the map.
				// Use ArrayList without generics so it works with older Java compilers.
				ArrayList keysToErase = new ArrayList();
	
				Object[] keys = ILOG.J2CsMapping.Collections.Collections.ToArray(new ILOG.J2CsMapping.Collections.ListSet(keyTimestamps_.Keys));
				for (int i = 0; i < keys.Length; ++i) {
					String keyUri = (String) keys[i];
					double ts = (double) (Double) ILOG.J2CsMapping.Collections.Collections.Get(keyTimestamps_,keyUri);
					if (now - ts > keyTimestampTtl_)
						ILOG.J2CsMapping.Collections.Collections.Add(keysToErase,keyUri);
					else if (ts < oldestTimestamp) {
						oldestTimestamp = ts;
						oldestKey = keyUri;
					}
				}
	
				// Now erase.
				for (int i_0 = 0; i_0 < keysToErase.Count; ++i_0)
					ILOG.J2CsMapping.Collections.Collections.Remove(keyTimestamps_,keysToErase[i_0]);
	
				if (keyTimestamps_.Count > maxTrackedKeys_
						&& oldestKey.Length != 0)
					// have not removed enough
					ILOG.J2CsMapping.Collections.Collections.Remove(keyTimestamps_,oldestKey);
			}
		}
	
		/// <summary>
		/// Check the type of signatureInfo to get the KeyLocator. Look in the
		/// IdentityStorage for the public key with the name in the KeyLocator and use
		/// it to verify the signedBlob. If the public key can't be found, return
		/// false. (This is a generalized method which can verify both a Data packet
		/// and an interest.)
		/// </summary>
		///
		/// <param name="signatureInfo"></param>
		/// <param name="signedBlob">the SignedBlob with the signed portion to verify.</param>
		/// <param name="failureReason"></param>
		/// <returns>True if the signature verifies, False if not.</returns>
		private bool verify(Signature signatureInfo, SignedBlob signedBlob,
				String[] failureReason) {
			// We have already checked once that there is a key locator.
			KeyLocator keyLocator = net.named_data.jndn.KeyLocator.getFromSignature(signatureInfo);
	
			if (keyLocator.getType() == net.named_data.jndn.KeyLocatorType.KEYNAME) {
				// Assume the key name is a certificate name.
				Name signatureName = keyLocator.getKeyName();
				Blob publicKeyDer;
				if (isSecurityV1_) {
					IdentityCertificate certificate = refreshManager_
							.getCertificate(signatureName);
					if (certificate == null)
						certificate = certificateCache_
								.getCertificate(signatureName);
					if (certificate == null) {
						failureReason[0] = "Cannot find a certificate with name "
								+ signatureName.toUri();
						return false;
					}
	
					publicKeyDer = certificate.getPublicKeyInfo().getKeyDer();
					if (publicKeyDer.isNull()) {
						// We don't expect this to happen.
						failureReason[0] = "There is no public key in the certificate with name "
								+ certificate.getName().toUri();
						return false;
					}
				} else {
					CertificateV2 certificate_0 = refreshManager_
							.getCertificateV2(signatureName);
					if (certificate_0 == null)
						certificate_0 = certificateCacheV2_.find(signatureName);
					if (certificate_0 == null) {
						failureReason[0] = "Cannot find a certificate with name "
								+ signatureName.toUri();
						return false;
					}
	
					try {
						publicKeyDer = certificate_0.getPublicKey();
					} catch (CertificateV2.Error ex) {
						// We don't expect this to happen.
						failureReason[0] = "There is no public key in the certificate with name "
								+ certificate_0.getName().toUri();
						return false;
					}
				}
	
				if (net.named_data.jndn.security.policy.PolicyManager.verifySignature(signatureInfo, signedBlob, publicKeyDer))
					return true;
				else {
					failureReason[0] = "The signature did not verify with the given public key";
					return false;
				}
			} else {
				failureReason[0] = "The KeyLocator does not have a key name";
				return false;
			}
		}
	
		/// <summary>
		/// This is a helper for checkVerificationPolicy to verify the rule and return
		/// a certificate interest to fetch the next certificate in the hierarchy if
		/// needed.
		/// </summary>
		///
		/// <param name="stepCount"></param>
		/// <param name="matchType">Either "data" or "interest".</param>
		/// <param name="objectName">The name of the data or interest packet.</param>
		/// <param name="signature">The Signature object for the data or interest packet.</param>
		/// <param name="failureReason"></param>
		/// <returns>null if can't determine the interest, otherwise the interest for the
		/// ValidationRequest to fetch the next certificate. However, if the interest
		/// has an empty name, the validation succeeded and no need to fetch a
		/// certificate.</returns>
		private Interest getCertificateInterest(int stepCount, String matchType,
				Name objectName, Signature signature, String[] failureReason) {
			if (stepCount > maxDepth_) {
				failureReason[0] = "The verification stepCount " + stepCount
						+ " exceeded the maxDepth " + maxDepth_;
				return null;
			}
	
			// first see if we can find a rule to match this packet
			BoostInfoTree matchedRule = findMatchingRule(objectName, matchType);
	
			// No matching rule -> fail.
			if (matchedRule == null) {
				failureReason[0] = "No matching rule found for "
						+ objectName.toUri();
				return null;
			}
	
			// TODO: Do a quick check if this is sig-type sha256.
	
			if (!net.named_data.jndn.KeyLocator.canGetFromSignature(signature)) {
				// We only support signature types with key locators.
				failureReason[0] = "The signature type does not support a KeyLocator";
				return null;
			}
	
			KeyLocator keyLocator = net.named_data.jndn.KeyLocator.getFromSignature(signature);
	
			Name signatureName = keyLocator.getKeyName();
			// No key name in KeyLocator -> fail.
			if (signatureName.size() == 0) {
				failureReason[0] = "The signature KeyLocator doesn't have a key name";
				return null;
			}
	
			bool signatureMatches = checkSignatureMatch(signatureName,
					objectName, matchedRule, failureReason);
			if (!signatureMatches)
				return null;
	
			// Before we look up keys, refresh any certificate directories.
			refreshManager_.refreshAnchors();
	
			// If we don't actually have the certificate yet, return a certificateInterest
			//   for it.
			if (isSecurityV1_) {
				IdentityCertificate foundCert = refreshManager_
						.getCertificate(signatureName);
				if (foundCert == null)
					foundCert = certificateCache_.getCertificate(signatureName);
				if (foundCert == null)
					return new Interest(signatureName);
			} else {
				CertificateV2 foundCert_0 = refreshManager_
						.getCertificateV2(signatureName);
				if (foundCert_0 == null)
					foundCert_0 = certificateCacheV2_.find(signatureName);
				if (foundCert_0 == null)
					return new Interest(signatureName);
			}
	
			return new Interest();
		}
	
		/// <summary>
		/// The onVerified method of this inner class is called by KeyChain.verifyData
		/// because checkVerificationPolicy returned a ValidationRequest to fetch a
		/// certificate and verify a certificate, through a separate call to
		/// KeyChain.verifyData. When it verifies the data, it calls onVerified which
		/// is this method.
		/// </summary>
		///
		/// <param name="data"></param>
		/// <param name="originalData">The original data from checkVerificationPolicy.</param>
		/// <param name="stepCount">The value from checkVerificationPolicy.</param>
		/// <param name="onVerified">The value from checkVerificationPolicy.</param>
		/// <param name="onValidationFailed">The value from checkVerificationPolicy.</param>
			internal class OnCertificateDownloadComplete : OnVerified {
				private ConfigPolicyManager outer_ConfigPolicyManager;
				public OnCertificateDownloadComplete(ConfigPolicyManager manager, Data originalData, int stepCount,
						OnVerified onVerified, OnDataValidationFailed onValidationFailed) {
					outer_ConfigPolicyManager = manager;
					originalData_ = originalData;
					stepCount_ = stepCount;
					onVerified_ = onVerified;
					onValidationFailed_ = onValidationFailed;
				}
		
				public void onVerified(Data data) {
					if (outer_ConfigPolicyManager.isSecurityV1_) {
						IdentityCertificate certificate;
						try {
							certificate = new IdentityCertificate(data);
						} catch (DerDecodingException ex) {
							try {
								onValidationFailed_.onDataValidationFailed(
										originalData_, "Cannot decode certificate "
												+ data.getName().toUri());
							} catch (Exception exception) {
								net.named_data.jndn.security.policy.ConfigPolicyManager.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
										"Error in onDataValidationFailed", exception);
							}
							return;
						}
						outer_ConfigPolicyManager.certificateCache_.insertCertificate(certificate);
					} else {
						CertificateV2 certificate_0;
						try {
							certificate_0 = new CertificateV2(data);
						} catch (CertificateV2.Error ex_1) {
							try {
								onValidationFailed_.onDataValidationFailed(
										originalData_, "Cannot decode certificate "
												+ data.getName().toUri());
							} catch (Exception exception_2) {
								net.named_data.jndn.security.policy.ConfigPolicyManager.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
										"Error in onDataValidationFailed", exception_2);
							}
							return;
						}
						try {
							outer_ConfigPolicyManager.certificateCacheV2_.insert(certificate_0);
						} catch (CertificateV2.Error ex_3) {
							try {
								onValidationFailed_.onDataValidationFailed(
										originalData_, "Cannot insert certificate "
												+ data.getName().toUri());
							} catch (Exception exception_4) {
								net.named_data.jndn.security.policy.ConfigPolicyManager.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
										"Error in onDataValidationFailed", exception_4);
							}
							return;
						}
					}
		
					try {
						// Now that we stored the needed certificate, increment stepCount and try again
						//   to verify the originalData.
						outer_ConfigPolicyManager.checkVerificationPolicy(originalData_, stepCount_ + 1,
								onVerified_, onValidationFailed_);
					} catch (Exception ex_5) {
						try {
							onValidationFailed_.onDataValidationFailed(originalData_,
									"Error in checkVerificationPolicy: " + ex_5);
						} catch (Exception exception_6) {
							net.named_data.jndn.security.policy.ConfigPolicyManager.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
									"Error in onDataValidationFailed", exception_6);
						}
					}
				}
		
				private readonly Data originalData_;
				private readonly int stepCount_;
				private readonly OnVerified onVerified_;
				private readonly OnDataValidationFailed onValidationFailed_;
			}
	
		/// <summary>
		/// The onVerified method of this inner class is called by KeyChain.verifyData
		/// because checkVerificationPolicy returned a ValidationRequest to fetch a
		/// certificate and verify a certificate, through a separate call to
		/// KeyChain.verifyData. When it verifies the data, it calls onVerified which
		/// is this method.
		/// </summary>
		///
		/// <param name="data"></param>
		/// <param name="originalInterest">The original interest from checkVerificationPolicy.</param>
		/// <param name="stepCount">The value from checkVerificationPolicy.</param>
		/// <param name="onVerified">The value from checkVerificationPolicy.</param>
		/// <param name="onValidationFailed">The value from checkVerificationPolicy.</param>
			internal class OnCertificateDownloadCompleteForInterest : 				OnVerified {
				private ConfigPolicyManager outer_ConfigPolicyManager;
				public OnCertificateDownloadCompleteForInterest(
						ConfigPolicyManager manager, Interest originalInterest, int stepCount,
						OnVerifiedInterest onVerified,
						OnInterestValidationFailed onValidationFailed,
						WireFormat wireFormat) {
					outer_ConfigPolicyManager = manager;
					originalInterest_ = originalInterest;
					stepCount_ = stepCount;
					onVerified_ = onVerified;
					onValidationFailed_ = onValidationFailed;
					wireFormat_ = wireFormat;
				}
		
				public void onVerified(Data data) {
					if (outer_ConfigPolicyManager.isSecurityV1_) {
						IdentityCertificate certificate;
						try {
							certificate = new IdentityCertificate(data);
						} catch (DerDecodingException ex) {
							try {
								onValidationFailed_.onInterestValidationFailed(
										originalInterest_, "Cannot decode certificate "
												+ data.getName().toUri());
							} catch (Exception exception) {
								net.named_data.jndn.security.policy.ConfigPolicyManager.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
										"Error in onInterestValidationFailed",
										exception);
							}
							return;
						}
						outer_ConfigPolicyManager.certificateCache_.insertCertificate(certificate);
					} else {
						CertificateV2 certificate_0;
						try {
							certificate_0 = new CertificateV2(data);
						} catch (CertificateV2.Error ex_1) {
							try {
								onValidationFailed_.onInterestValidationFailed(
										originalInterest_, "Cannot decode certificate "
												+ data.getName().toUri());
							} catch (Exception exception_2) {
								net.named_data.jndn.security.policy.ConfigPolicyManager.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
										"Error in onInterestValidationFailed",
										exception_2);
							}
							return;
						}
						try {
							outer_ConfigPolicyManager.certificateCacheV2_.insert(certificate_0);
						} catch (CertificateV2.Error ex_3) {
							try {
								onValidationFailed_.onInterestValidationFailed(
										originalInterest_, "Cannot insert certificate "
												+ data.getName().toUri());
							} catch (Exception exception_4) {
								net.named_data.jndn.security.policy.ConfigPolicyManager.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
										"Error in onDataValidationFailed", exception_4);
							}
							return;
						}
					}
		
					try {
						// Now that we stored the needed certificate, increment stepCount and try again
						//   to verify the originalInterest.
						outer_ConfigPolicyManager.checkVerificationPolicy(originalInterest_, stepCount_ + 1,
								onVerified_, onValidationFailed_, wireFormat_);
					} catch (Exception ex_5) {
						try {
							onValidationFailed_.onInterestValidationFailed(
									originalInterest_,
									"Error in checkVerificationPolicy: " + ex_5);
						} catch (Exception exception_6) {
							net.named_data.jndn.security.policy.ConfigPolicyManager.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
									"Error in onInterestValidationFailed", exception_6);
						}
					}
				}
		
				private readonly Interest originalInterest_;
				private readonly int stepCount_;
				private readonly OnVerifiedInterest onVerified_;
				private readonly OnInterestValidationFailed onValidationFailed_;
				private readonly WireFormat wireFormat_;
			}
	
		/// <summary>
		/// Ignore data and call onInterestValidationFailed(interest, reason). This is
		/// so that an OnInterestValidationFailed can be passed as an
		/// OnDataValidationFailed.
		/// </summary>
		///
		private class OnVerifyInterestFailedWrapper : 			OnDataValidationFailed {
			public OnVerifyInterestFailedWrapper(
					OnInterestValidationFailed onValidationFailed, Interest interest) {
				onValidationFailed_ = onValidationFailed;
				interest_ = interest;
			}
	
			public void onDataValidationFailed(Data data, String reason) {
				onValidationFailed_.onInterestValidationFailed(interest_, reason);
			}
	
			private readonly OnInterestValidationFailed onValidationFailed_;
			private readonly Interest interest_;
		}
	
		/// <summary>
		/// A class implements Friend if it has a method
		/// setConfigPolicyManagerFriendAccess which setFriendAccess calls to set
		/// the FriendAccess object.
		/// </summary>
		///
		public interface Friend {
			void setConfigPolicyManagerFriendAccess(ConfigPolicyManager.FriendAccess  friendAccess);
		}
	
		/// <summary>
		/// Call friend.setConfigPolicyManagerFriendAccess to pass an instance of
		/// a FriendAccess class to allow a friend class to call private methods.
		/// </summary>
		///
		/// <param name="friend">Therefore, only a friend class gets an implementation of FriendAccess.</param>
		public static void setFriendAccess(ConfigPolicyManager.Friend  friend) {
			if (friend
							.GetType().FullName
					.endsWith(
							"net.named_data.jndn.tests.integration_tests.TestPolicyManager")
					|| friend
											.GetType().FullName
							.endsWith(
									"net.named_data.jndn.tests.integration_tests.TestVerificationRules")) {
				friend.setConfigPolicyManagerFriendAccess(new ConfigPolicyManager.FriendAccessImpl ());
			}
		}
	
		/// <summary>
		/// A friend class can call the methods of FriendAccess to access private
		/// methods.  This abstract class is public, but setFriendAccess passes an
		/// instance of a private class which implements the methods.
		/// </summary>
		///
		public abstract class FriendAccess {
			public abstract BoostInfoTree findMatchingRule(
					ConfigPolicyManager policyManager, Name objName,
					String matchType);
	
			public abstract bool checkSignatureMatch(
					ConfigPolicyManager policyManager, Name signatureName,
					Name objectName, BoostInfoTree rule, String[] failureReason);
		}
	
		/// <summary>
		/// setFriendAccess passes an instance of this private class which implements
		/// the FriendAccess methods.
		/// </summary>
		///
		private class FriendAccessImpl : ConfigPolicyManager.FriendAccess  {
			public override BoostInfoTree findMatchingRule(
					ConfigPolicyManager policyManager, Name objName,
					String matchType) {
				return policyManager.findMatchingRule(objName, matchType);
			}
	
			public override bool checkSignatureMatch(ConfigPolicyManager policyManager,
					Name signatureName, Name objectName, BoostInfoTree rule,
					String[] failureReason) {
				return policyManager.checkSignatureMatch(signatureName, objectName,
						rule, failureReason);
			}
		}
	
		internal readonly bool isSecurityV1_;
		internal CertificateCache certificateCache_;
		internal CertificateCacheV2 certificateCacheV2_;
		private int maxDepth_;
		private double keyGraceInterval_;
		private double keyTimestampTtl_;
		private int maxTrackedKeys_;
		// fixedCertificateCache_ stores the fixed-signer certificate name associated with
		//    validation rules so we don't keep loading from files.
		// Use HashMap without generics so it works with older Java compilers.
		private readonly Hashtable fixedCertificateCache_;
		// keyTimestamps_ stores the timestamps for each public key used in command
		//   interests to avoid replay attacks.
		// key is the public key name, value is the last timestamp.
		private readonly Hashtable keyTimestamps_;
		private BoostInfoParser config_;
		private bool requiresVerification_;
		private ConfigPolicyManager.TrustAnchorRefreshManager  refreshManager_;
		static internal readonly Logger logger_ = ILOG.J2CsMapping.Util.Logging.Logger
				.getLogger(typeof(ConfigPolicyManager).FullName);
	}
}
