// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 12/23/15 3:55 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2015 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn {
	
	using ILOG.J2CsMapping.Util;
	using System;
	using System.Collections;
	using System.Collections.concurrent;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.transport;
	
	/// <summary>
	/// ThreadPoolFace extends Face to provide the main methods for NDN communication
	/// by submitting to a given ScheduledExecutorService thread pool. This also
	/// uses the thread pool to schedule the interest timeouts.
	/// </summary>
	///
	public class ThreadPoolFace : Face {
		public sealed class Anonymous_C3 : OnData {
				public sealed class Anonymous_C5 : IRunnable {
								private readonly ThreadPoolFace.Anonymous_C3  outer_Anonymous_C3;
								private readonly Interest localInterest;
								private readonly Data data;
					
								public Anonymous_C5(ThreadPoolFace.Anonymous_C3  paramouter_Anonymous_C3,
										Interest localInterest_0, Data data_1) {
									this.localInterest = localInterest_0;
									this.data = data_1;
									this.outer_Anonymous_C3 = paramouter_Anonymous_C3;
								}
					
								// Call the passed-in onData.
								public void run() {
									outer_Anonymous_C3.finalOnData.onData(localInterest, data);
								}
							}
		
				private readonly ThreadPoolFace outer_ThreadPoolFace;
				internal readonly OnData finalOnData;
		
				public Anonymous_C3(ThreadPoolFace paramouter_ThreadPoolFace,
						OnData finalOnData_0) {
					this.finalOnData = finalOnData_0;
					this.outer_ThreadPoolFace = paramouter_ThreadPoolFace;
				}
		
				public void onData(Interest localInterest_0, Data data_1) {
					outer_ThreadPoolFace.threadPool_.submit(new net.named_data.jndn.ThreadPoolFace.Anonymous_C3.Anonymous_C5 (this, localInterest_0, data_1));
				}
			}
	
		public sealed class Anonymous_C2 : OnTimeout {
				public sealed class Anonymous_C4 : IRunnable {
								private readonly ThreadPoolFace.Anonymous_C2  outer_Anonymous_C2;
								private readonly Interest localInterest;
					
								public Anonymous_C4(ThreadPoolFace.Anonymous_C2  paramouter_Anonymous_C2,
										Interest localInterest_0) {
									this.localInterest = localInterest_0;
									this.outer_Anonymous_C2 = paramouter_Anonymous_C2;
								}
					
								// Call the passed-in onTimeout.
								public void run() {
									outer_Anonymous_C2.finalOnTimeout.onTimeout(localInterest);
								}
							}
		
				private readonly ThreadPoolFace outer_ThreadPoolFace;
				internal readonly OnTimeout finalOnTimeout;
		
				public Anonymous_C2(ThreadPoolFace paramouter_ThreadPoolFace,
						OnTimeout finalOnTimeout_0) {
					this.finalOnTimeout = finalOnTimeout_0;
					this.outer_ThreadPoolFace = paramouter_ThreadPoolFace;
				}
		
				public void onTimeout(Interest localInterest_0) {
					outer_ThreadPoolFace.threadPool_.submit(new net.named_data.jndn.ThreadPoolFace.Anonymous_C2.Anonymous_C4 (this, localInterest_0));
				}
			}
	
		public sealed class Anonymous_C1 : IRunnable {
				private readonly ThreadPoolFace outer_ThreadPoolFace;
				private readonly Interest interest;
				private readonly long pendingInterestId;
				private readonly OnData onDataSubmit;
				private readonly OnTimeout onTimeoutSubmit;
				private readonly WireFormat wireFormat;
		
				public Anonymous_C1(ThreadPoolFace paramouter_ThreadPoolFace,
						Interest interest_0, long pendingInterestId_1, OnData onDataSubmit_2,
						OnTimeout onTimeoutSubmit_3, WireFormat wireFormat_4) {
					this.interest = interest_0;
					this.pendingInterestId = pendingInterestId_1;
					this.onDataSubmit = onDataSubmit_2;
					this.onTimeoutSubmit = onTimeoutSubmit_3;
					this.wireFormat = wireFormat_4;
					this.outer_ThreadPoolFace = paramouter_ThreadPoolFace;
				}
		
				public void run() {
					try {
						outer_ThreadPoolFace.node_.expressInterest(pendingInterestId, interest,
								onDataSubmit, onTimeoutSubmit, wireFormat,
								outer_ThreadPoolFace);
					} catch (IOException ex) {
						// TODO: How to notify the application of failure?
						Console.Error.WriteLine(ex.StackTrace);
					}
				}
			}
	
		public sealed class Anonymous_C0 : IRunnable {
			private readonly IRunnable callback;
	
			public Anonymous_C0(IRunnable callback_0) {
				this.callback = callback_0;
			}
	
			public void run() {
				callback.run();
			}
		}
	
		/// <summary>
		/// Create a new ThreadPoolFace for communication with an NDN hub with the given
		/// Transport object and connectionInfo.
		/// </summary>
		///
		/// <param name="threadPool">is also used to schedule the interest timeouts.</param>
		/// <param name="transport">like AsyncTcpTransport, in which case the transport should use the same ioService.</param>
		/// <param name="connectionInfo"></param>
		public ThreadPoolFace(ScheduledExecutorService threadPool,
				Transport transport, Transport.ConnectionInfo connectionInfo) : base(transport, connectionInfo) {
			threadPool_ = threadPool;
		}
	
		/// <summary>
		/// Submit a task to the thread pool to send the Interest through the
		/// transport, read the entire response and call onData(interest, data).
		/// </summary>
		///
		/// <param name="interest_0">The Interest to send.  This copies the Interest.</param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. This wraps the callback to submit it to the thread pool.</param>
		/// <param name="onTimeout">interest given to expressInterest. If onTimeout is null, this does not use it. This wraps the callback to submit it to the thread pool.</param>
		/// <param name="wireFormat_1">A WireFormat object used to encode the message.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		public override long expressInterest(Interest interest_0, OnData onData,
				OnTimeout onTimeout, WireFormat wireFormat_1) {
			long pendingInterestId_2 = node_.getNextEntryId();
	
			// Wrap onData and onTimeout to submit to the thread pool.
			OnData finalOnData_3 = onData;
			OnData onDataSubmit_4 = new ThreadPoolFace.Anonymous_C3 (this, finalOnData_3);
	
			OnTimeout finalOnTimeout_5 = onTimeout;
			OnTimeout onTimeoutSubmit_6 = (onTimeout == null) ? null
					: new ThreadPoolFace.Anonymous_C2 (this, finalOnTimeout_5);
	
			threadPool_.submit(new ThreadPoolFace.Anonymous_C1 (this, interest_0, pendingInterestId_2, onDataSubmit_4,
					onTimeoutSubmit_6, wireFormat_1));
	
			return pendingInterestId_2;
		}
	
		/// <summary>
		/// Override to schedule in the thread pool to call callback.run() after the
		/// given delay. Even though this is public, it is not part of the public API
		/// of Face.
		/// </summary>
		///
		/// <param name="delayMilliseconds">The delay in milliseconds.</param>
		/// <param name="callback_0">This calls callback.run() after the delay.</param>
		public override void callLater(double delayMilliseconds, IRunnable callback_0) {
			threadPool_.schedule(new ThreadPoolFace.Anonymous_C0 (callback_0), (long) delayMilliseconds, java.util.concurrent.TimeUnit.MILLISECONDS);
		}
	
		internal readonly ScheduledExecutorService threadPool_;
	}
}
