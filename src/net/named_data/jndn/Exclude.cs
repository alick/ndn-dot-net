// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2013-2016 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn {
	
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// An Exclude holds an Array of Exclude.Entry.
	/// </summary>
	///
	public class Exclude : ChangeCountable {
		public enum Type {
			COMPONENT, ANY
		}
	
		/// <summary>
		/// An Exclude.Entry holds an Exclude.Type, and if it is a COMPONENT, it holds
		/// the component value.
		/// </summary>
		///
		public class Entry {
			/// <summary>
			/// Create an Exclude.Entry of type ANY
			/// </summary>
			///
			public Entry() {
				type_ = net.named_data.jndn.Exclude.Type.ANY;
				component_ = null;
			}
	
			/// <summary>
			/// Create an Exclude.Entry of type COMPONENT.
			/// </summary>
			///
			/// <param name="component">The component value.</param>
			public Entry(Name.Component component) {
				type_ = net.named_data.jndn.Exclude.Type.COMPONENT;
				component_ = component;
			}
	
			/// <summary>
			/// Get the type of this entry.
			/// </summary>
			///
			/// <returns>The Exclude.Type.</returns>
			public Exclude.Type getType() {
				return type_;
			}
	
			/// <summary>
			/// Get the component value for this entry (if it is of type COMPONENT).
			/// </summary>
			///
			/// <returns>The component value, or null if this entry is not of type
			/// COMPONENT.</returns>
			public Name.Component getComponent() {
				return component_;
			}
	
			private readonly Exclude.Type type_;
			private readonly Name.Component component_;
			/**< only used if type_ is
			     Exclude.Type.COMPONENT */
		}
	
		/// <summary>
		/// Create a new Exclude with no entries.
		/// </summary>
		///
		public Exclude() {
			this.changeCount_ = 0;
			entries_ = new ArrayList<Entry>();
		}
	
		/// <summary>
		/// Create a new Exclude as a copy of the given exclude.
		/// </summary>
		///
		/// <param name="exclude">The Exclude to copy.</param>
		public Exclude(Exclude exclude) {
			this.changeCount_ = 0;
			// Each entry is read-only, so do a shallow copy.
			entries_ = new ArrayList<Entry>(exclude.entries_);
		}
	
		/// <summary>
		/// Get the number of entries.
		/// </summary>
		///
		/// <returns>The number of entries.</returns>
		public int size() {
			return entries_.Count;
		}
	
		/// <summary>
		/// Get the entry at the given index.
		/// </summary>
		///
		/// <param name="i">The index of the entry, starting from 0.</param>
		/// <returns>The entry at the index.</returns>
		public Exclude.Entry get(int i) {
			return entries_[i];
		}
	
		/// <summary>
		/// Append a new entry of type Exclude.Type.ANY.
		/// </summary>
		///
		/// <returns>This Exclude so that you can chain calls to append.</returns>
		public Exclude appendAny() {
			ILOG.J2CsMapping.Collections.Collections.Add(entries_,new Exclude.Entry ());
			++changeCount_;
			return this;
		}
	
		/// <summary>
		/// Append a new entry of type Exclude.Type.COMPONENT, taking another pointer
		/// to the Name.Component.
		/// </summary>
		///
		/// <param name="component">The component value for the entry.</param>
		/// <returns>This Exclude so that you can chain calls to append.</returns>
		public Exclude appendComponent(Name.Component component) {
			ILOG.J2CsMapping.Collections.Collections.Add(entries_,new Exclude.Entry (component));
			++changeCount_;
			return this;
		}
	
		/// <summary>
		/// Clear all the entries.
		/// </summary>
		///
		public void clear() {
			ILOG.J2CsMapping.Collections.Collections.Clear(entries_);
			++changeCount_;
		}
	
		/// <summary>
		/// Check if the component matches any of the exclude criteria.
		/// </summary>
		///
		/// <param name="component">The name component to check.</param>
		/// <returns>True if the component matches any of the exclude criteria,
		/// otherwise false.</returns>
		public bool matches(Name.Component component) {
			for (int i = 0; i < entries_.Count; ++i) {
				if (get(i).getType() == net.named_data.jndn.Exclude.Type.ANY) {
					Exclude.Entry  lowerBound = null;
					if (i > 0)
						lowerBound = get(i - 1);
	
					// Find the upper bound, possibly skipping over multiple ANY in a row.
					int iUpperBound;
					Exclude.Entry  upperBound = null;
					for (iUpperBound = i + 1; iUpperBound < entries_.Count; ++iUpperBound) {
						if (get(iUpperBound).getType() == net.named_data.jndn.Exclude.Type.COMPONENT) {
							upperBound = get(iUpperBound);
							break;
						}
					}
	
					// If lowerBound != null, we already checked component equals lowerBound on the last pass.
					// If upperBound != null, we will check component equals upperBound on the next pass.
					if (upperBound != null) {
						if (lowerBound != null) {
							if (component.compare(lowerBound.getComponent()) > 0
									&& component.compare(upperBound.getComponent()) < 0)
								return true;
						} else {
							if (component.compare(upperBound.getComponent()) < 0)
								return true;
						}
	
						// Make i equal iUpperBound on the next pass.
						i = iUpperBound - 1;
					} else {
						if (lowerBound != null) {
							if (component.compare(lowerBound.getComponent()) > 0)
								return true;
						} else
							// entries_ has only ANY.
							return true;
					}
				} else {
					if (component.equals(get(i).getComponent()))
						return true;
				}
			}
	
			return false;
		}
	
		/// <summary>
		/// Encode this Exclude with elements separated by "," and Exclude.Type.ANY
		/// shown as "///".
		/// </summary>
		///
		/// <returns>the URI string</returns>
		public String toUri() {
			if ((entries_.Count==0))
				return "";
	
			StringBuilder result = new StringBuilder();
			for (int i = 0; i < entries_.Count; ++i) {
				if (i > 0)
					result.append(",");
	
				if (get(i).getType() == net.named_data.jndn.Exclude.Type.ANY)
					result.append("*");
				else
					net.named_data.jndn.Name.toEscapedString(get(i).getComponent().getValue().buf(),
							result);
			}
	
			return result.toString();
		}
	
		/// <summary>
		/// Get the change count, which is incremented each time this object is
		/// changed.
		/// </summary>
		///
		/// <returns>The change count.</returns>
		public long getChangeCount() {
			return changeCount_;
		}
	
		private readonly ArrayList<Entry> entries_;
		private long changeCount_;
	}
}
