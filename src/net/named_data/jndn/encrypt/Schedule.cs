// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2015-2017 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.encrypt {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.NIO;
	using ILOG.J2CsMapping.Util;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.encoding.tlv;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// Schedule is used to manage the times when a member can access data using two
	/// sets of RepetitiveInterval as follows. whiteIntervalList is an ordered
	/// set for the times a member is allowed to access to data, and
	/// blackIntervalList is for the times a member is not allowed.
	/// </summary>
	///
	/// @note This class is an experimental feature. The API may change.
	public class Schedule {
		public class Result {
			public Result(bool isPositive, Interval interval) {
				this.isPositive = isPositive;
				this.interval = interval;
			}
	
			public bool isPositive;
			public Interval interval;
		}
	
		/// <summary>
		/// Create a Schedule with empty whiteIntervalList and blackIntervalList.
		/// </summary>
		///
		public Schedule() {
			this.whiteIntervalList_ = new SortedSet();
			this.blackIntervalList_ = new SortedSet();
		}
	
		/// <summary>
		/// Create a Schedule, copying values from the given schedule.
		/// </summary>
		///
		/// <param name="schedule">The Schedule to copy values from.</param>
		public Schedule(Schedule schedule) {
			this.whiteIntervalList_ = new SortedSet();
			this.blackIntervalList_ = new SortedSet();
			// RepetitiveInterval is immutable, so we don't need to make a deep copy.
			ILOG.J2CsMapping.Collections.Collections.AddAll(schedule.whiteIntervalList_,whiteIntervalList_);
			ILOG.J2CsMapping.Collections.Collections.AddAll(schedule.blackIntervalList_,blackIntervalList_);
		}
	
		/// <summary>
		/// Add the repetitiveInterval to the whiteIntervalList.
		/// </summary>
		///
		/// <param name="repetitiveInterval"></param>
		/// <returns>This Schedule so you can chain calls to add.</returns>
		public Schedule addWhiteInterval(RepetitiveInterval repetitiveInterval) {
			// RepetitiveInterval is immutable, so we don't need to make a copy.
			ILOG.J2CsMapping.Collections.Collections.Add(whiteIntervalList_,repetitiveInterval);
			return this;
		}
	
		/// <summary>
		/// Add the repetitiveInterval to the blackIntervalList.
		/// </summary>
		///
		/// <param name="repetitiveInterval"></param>
		/// <returns>This Schedule so you can chain calls to add.</returns>
		public Schedule addBlackInterval(RepetitiveInterval repetitiveInterval) {
			// RepetitiveInterval is immutable, so we don't need to make a copy.
			ILOG.J2CsMapping.Collections.Collections.Add(blackIntervalList_,repetitiveInterval);
			return this;
		}
	
		/// <summary>
		/// Get the interval that covers the time stamp. This iterates over the two
		/// repetitive interval sets and find the shortest interval that allows a group
		/// member to access the data. If there is no interval covering the time stamp,
		/// this returns false for isPositive and returns a negative interval.
		/// </summary>
		///
		/// <param name="timeStamp">The time stamp as milliseconds since Jan 1, 1970 UTC.</param>
		/// <returns>An object with fields (isPositive, interval) where isPositive is
		/// true if the returned interval is positive or false if negative, and
		/// interval is the Interval covering the time stamp, or a negative interval if
		/// not found.</returns>
		public Schedule.Result  getCoveringInterval(double timeStamp) {
			Interval blackPositiveResult = new Interval(true);
			Interval whitePositiveResult = new Interval(true);
	
			Interval blackNegativeResult = new Interval();
			Interval whiteNegativeResult = new Interval();
	
			// Get the black result.
			calculateIntervalResult(blackIntervalList_, timeStamp,
					blackPositiveResult, blackNegativeResult);
	
			// If the black positive result is not empty, then isPositive must be false.
			if (!blackPositiveResult.isEmpty())
				return new Schedule.Result (false, blackPositiveResult);
	
			// Get the whiteResult.
			calculateIntervalResult(whiteIntervalList_, timeStamp,
					whitePositiveResult, whiteNegativeResult);
	
			if (whitePositiveResult.isEmpty() && !whiteNegativeResult.isValid()) {
				// There is no white interval covering the time stamp.
				// Return false and a 24-hour interval.
				double timeStampDateOnly = net.named_data.jndn.encrypt.RepetitiveInterval
						.toDateOnlyMilliseconds(timeStamp);
				return new Schedule.Result (false, new Interval(timeStampDateOnly,
						timeStampDateOnly + MILLISECONDS_IN_DAY));
			}
	
			if (!whitePositiveResult.isEmpty()) {
				// There is white interval covering the time stamp.
				// Return true and calculate the intersection.
				if (blackNegativeResult.isValid())
					return new Schedule.Result (true,
							whitePositiveResult.intersectWith(blackNegativeResult));
				else
					return new Schedule.Result (true, whitePositiveResult);
			} else
				// There is no white interval covering the time stamp.
				// Return false.
				return new Schedule.Result (false, whiteNegativeResult);
		}
	
		/// <summary>
		/// Encode this Schedule.
		/// </summary>
		///
		/// <returns>The encoded buffer.</returns>
		public Blob wireEncode() {
			// For now, don't use WireFormat and hardcode to use TLV since the encoding
			// doesn't go out over the wire, only into the local SQL database.
			TlvEncoder encoder = new TlvEncoder(256);
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			// Encode the blackIntervalList.
			int saveLengthForList = encoder.getLength();
			for (IIterator i = blackIntervalList_.descendingIterator(); i.HasNext();) {
				RepetitiveInterval element = (RepetitiveInterval) i.Next();
				encodeRepetitiveInterval(element, encoder);
			}
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_BlackIntervalList,
					encoder.getLength() - saveLengthForList);
	
			// Encode the whiteIntervalList.
			saveLengthForList = encoder.getLength();
			for (IIterator i_0 = whiteIntervalList_.descendingIterator(); i_0.HasNext();) {
				RepetitiveInterval element_1 = (RepetitiveInterval) i_0.Next();
				encodeRepetitiveInterval(element_1, encoder);
			}
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_WhiteIntervalList,
					encoder.getLength() - saveLengthForList);
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_Schedule, encoder.getLength()
					- saveLength);
	
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Decode the input and update this Schedule object.
		/// </summary>
		///
		/// <param name="input"></param>
		/// <exception cref="EncodingException">For invalid encoding.</exception>
		public void wireDecode(ByteBuffer input) {
			// For now, don't use WireFormat and hardcode to use TLV since the encoding
			// doesn't go out over the wire, only into the local SQL database.
			TlvDecoder decoder = new TlvDecoder(input);
	
			int endOffset = decoder.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_Schedule);
	
			// Decode the whiteIntervalList.
			ILOG.J2CsMapping.Collections.Collections.Clear(whiteIntervalList_);
			int listEndOffset = decoder
					.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_WhiteIntervalList);
			while (decoder.getOffset() < listEndOffset)
				ILOG.J2CsMapping.Collections.Collections.Add(whiteIntervalList_,decodeRepetitiveInterval(decoder));
			decoder.finishNestedTlvs(listEndOffset);
	
			// Decode the blackIntervalList.
			ILOG.J2CsMapping.Collections.Collections.Clear(blackIntervalList_);
			listEndOffset = decoder
					.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_BlackIntervalList);
			while (decoder.getOffset() < listEndOffset)
				ILOG.J2CsMapping.Collections.Collections.Add(blackIntervalList_,decodeRepetitiveInterval(decoder));
			decoder.finishNestedTlvs(listEndOffset);
	
			decoder.finishNestedTlvs(endOffset);
		}
	
		/// <summary>
		/// Decode the input and update this Schedule object.
		/// </summary>
		///
		/// <param name="input"></param>
		/// <exception cref="EncodingException">For invalid encoding.</exception>
		public void wireDecode(Blob input) {
			wireDecode(input.buf());
		}
	
		/// <summary>
		/// Encode the RepetitiveInterval as NDN-TLV to the encoder.
		/// </summary>
		///
		/// <param name="repetitiveInterval">The RepetitiveInterval to encode.</param>
		/// <param name="encoder">The TlvEncoder to receive the encoding.</param>
		private static void encodeRepetitiveInterval(
				RepetitiveInterval repetitiveInterval, TlvEncoder encoder) {
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_RepeatUnit,
					net.named_data.jndn.encrypt.RepetitiveInterval.getRepeatUnitNumericType(repetitiveInterval
							.getRepeatUnit()));
			encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_NRepeats,
					repetitiveInterval.getNRepeats());
			encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_IntervalEndHour,
					repetitiveInterval.getIntervalEndHour());
			encoder.writeNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_IntervalStartHour,
					repetitiveInterval.getIntervalStartHour());
			// Use Blob to convert the string to UTF8 encoding.
			encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_EndDate, new Blob(
					toIsoString(repetitiveInterval.getEndDate())).buf());
			encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_StartDate, new Blob(
					toIsoString(repetitiveInterval.getStartDate())).buf());
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_RepetitiveInterval,
					encoder.getLength() - saveLength);
		}
	
		/// <summary>
		/// Decode the input as an NDN-TLV RepetitiveInterval.
		/// </summary>
		///
		/// <param name="decoder">The decoder with the input to decode.</param>
		/// <returns>A new RepetitiveInterval with the decoded result.</returns>
		private static RepetitiveInterval decodeRepetitiveInterval(
				TlvDecoder decoder) {
			int endOffset = decoder
					.readNestedTlvsStart(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_RepetitiveInterval);
	
			// Use Blob to convert UTF8 to a string.
			double startDate = fromIsoString(new Blob(
					decoder.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_StartDate), true).toString());
			double endDate = fromIsoString(new Blob(
					decoder.readBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_EndDate), true).toString());
			int startHour = (int) decoder
					.readNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_IntervalStartHour);
			int endHour = (int) decoder
					.readNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_IntervalEndHour);
			int nRepeats = (int) decoder
					.readNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_NRepeats);
	
			int repeatUnitCode = (int) decoder
					.readNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.Encrypt_RepeatUnit);
			RepetitiveInterval.RepeatUnit repeatUnit;
			if (repeatUnitCode == net.named_data.jndn.encoding.tlv.Tlv.Encrypt_RepeatUnit_NONE)
				repeatUnit = net.named_data.jndn.encrypt.RepetitiveInterval.RepeatUnit.NONE;
			else if (repeatUnitCode == net.named_data.jndn.encoding.tlv.Tlv.Encrypt_RepeatUnit_DAY)
				repeatUnit = net.named_data.jndn.encrypt.RepetitiveInterval.RepeatUnit.DAY;
			else if (repeatUnitCode == net.named_data.jndn.encoding.tlv.Tlv.Encrypt_RepeatUnit_MONTH)
				repeatUnit = net.named_data.jndn.encrypt.RepetitiveInterval.RepeatUnit.MONTH;
			else if (repeatUnitCode == net.named_data.jndn.encoding.tlv.Tlv.Encrypt_RepeatUnit_YEAR)
				repeatUnit = net.named_data.jndn.encrypt.RepetitiveInterval.RepeatUnit.YEAR;
			else
				throw new EncodingException(
						"Unrecognized RepetitiveInterval RepeatUnit code: "
								+ repeatUnitCode);
	
			decoder.finishNestedTlvs(endOffset);
			return new RepetitiveInterval(startDate, endDate, startHour, endHour,
					nRepeats, repeatUnit);
		}
	
		/// <summary>
		/// A helper function to calculate black interval results or white interval
		/// results.
		/// </summary>
		///
		/// <param name="list"></param>
		/// <param name="timeStamp">The time stamp as milliseconds since Jan 1, 1970 UTC.</param>
		/// <param name="positiveResult">The positive result which is updated.</param>
		/// <param name="negativeResult">The negative result which is updated.</param>
		private static void calculateIntervalResult(SortedSet list, double timeStamp,
				Interval positiveResult, Interval negativeResult) {
			/* foreach */
			foreach (Object elementObj  in  list) {
				RepetitiveInterval element = (RepetitiveInterval) elementObj;
	
				RepetitiveInterval.Result result = element.getInterval(timeStamp);
				Interval tempInterval = result.interval;
				if (result.isPositive == true) {
					try {
						positiveResult.unionWith(tempInterval);
					} catch (Interval.Error ex) {
						// We don't expect to get this error.
						throw new Exception("Error in Interval.unionWith: "
								+ ex.Message);
					}
				} else {
					if (!negativeResult.isValid())
						negativeResult.set(tempInterval);
					else
						negativeResult.intersectWith(tempInterval);
				}
			}
		}
	
		public static double fromIsoString(String dateString) {
			try {
				return (double) net.named_data.jndn.util.Common.dateToMillisecondsSince1970(dateFormat
						.parse(dateString));
			} catch (ParseException ex) {
				throw new EncodingException("Cannot parse date string "
						+ dateString);
			}
		}
	
		public static String toIsoString(double msSince1970) {
			return dateFormat.format(net.named_data.jndn.util.Common.millisecondsSince1970ToDate((long) Math.Round(msSince1970,MidpointRounding.AwayFromZero)));
		}
	
		private static SimpleDateFormat getDateFormat() {
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyyMMdd'T'HHmmss");
			dateFormat.setTimeZone(System.Collections.TimeZone.getTimeZone("UTC"));
			return dateFormat;
		}
	
		// Use TreeSet without generics so it works with older Java compilers.
		private readonly SortedSet whiteIntervalList_; // of RepetitiveInterval
		private readonly SortedSet blackIntervalList_; // of RepetitiveInterval
		private static readonly SimpleDateFormat dateFormat = getDateFormat();
		private const long MILLISECONDS_IN_DAY = 24 * 3600 * 1000;
	}
}
