// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2015-2016 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.encrypt.algo {
	
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.spec;
	using javax.crypto;
	using net.named_data.jndn.encoding.der;
	using net.named_data.jndn.encrypt;
	using net.named_data.jndn.security;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// The RsaAlgorithm class provides static methods to manipulate keys, encrypt
	/// and decrypt using RSA.
	/// </summary>
	///
	/// @note This class is an experimental feature. The API may change.
	public class RsaAlgorithm {
		/// <summary>
		/// Generate a new random decrypt key for RSA based on the given params.
		/// </summary>
		///
		/// <param name="params">The key params with the key size (in bits).</param>
		/// <returns>The new decrypt key (PKCS8-encoded private key).</returns>
		public static DecryptKey generateKey(RsaKeyParams paras) {
			KeyPairGenerator generator = System.KeyPairGenerator.getInstance("RSA");
			generator.initialize(paras.getKeySize());
			KeyPair pair = generator.generateKeyPair();
	
			return new DecryptKey(new Blob(pair.getPrivate().getEncoded()));
		}
	
		/// <summary>
		/// Derive a new encrypt key from the given decrypt key value.
		/// </summary>
		///
		/// <param name="keyBits"></param>
		/// <returns>The new encrypt key (DER-encoded public key).</returns>
		public static EncryptKey deriveEncryptKey(Blob keyBits) {
			// Decode the PKCS #8 private key. (We don't use RSAPrivateCrtKey because
			// the Android library doesn't have an easy way to decode into it.)
			DerNode parsedNode = net.named_data.jndn.encoding.der.DerNode.parse(keyBits.buf(), 0);
			IList pkcs8Children = parsedNode.getChildren();
			IList algorithmIdChildren = net.named_data.jndn.encoding.der.DerNode.getSequence(pkcs8Children, 1)
					.getChildren();
			String oidString = ((DerNode.DerOid) algorithmIdChildren[0])
					.toVal().toString();
			Blob rsaPrivateKeyDer = ((DerNode) pkcs8Children[2]).getPayload();
	
			String RSA_ENCRYPTION_OID = "1.2.840.113549.1.1.1";
			if (!oidString.equals(RSA_ENCRYPTION_OID))
				throw new DerDecodingException(
						"The PKCS #8 private key is not RSA_ENCRYPTION");
	
			// Decode the PKCS #1 RSAPrivateKey.
			parsedNode = net.named_data.jndn.encoding.der.DerNode.parse(rsaPrivateKeyDer.buf(), 0);
			IList rsaPrivateKeyChildren = parsedNode.getChildren();
			Blob modulus = ((DerNode) rsaPrivateKeyChildren[1]).getPayload();
			Blob publicExponent = ((DerNode) rsaPrivateKeyChildren[2])
					.getPayload();
	
			System.SecurityPublicKey publicKey = keyFactory_
					.generatePublic(new RSAPublicKeySpec(new Int64(modulus
							.getImmutableArray()), new Int64(publicExponent
							.getImmutableArray())));
	
			return new EncryptKey(new Blob(publicKey.getEncoded()));
		}
	
		/// <summary>
		/// Decrypt the encryptedData using the keyBits according the encrypt params.
		/// </summary>
		///
		/// <param name="keyBits">The key value (PKCS8-encoded private key).</param>
		/// <param name="encryptedData">The data to decrypt.</param>
		/// <param name="params">This decrypts according to params.getAlgorithmType().</param>
		/// <returns>The decrypted data.</returns>
		public static Blob decrypt(Blob keyBits, Blob encryptedData,
				EncryptParams paras) {
			PrivateKey privateKey = keyFactory_
					.generatePrivate(new PKCS8EncodedKeySpec(keyBits
							.getImmutableArray()));
	
			String transformation;
			if (paras.getAlgorithmType() == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaPkcs)
				transformation = "RSA/ECB/PKCS1Padding";
			else if (paras.getAlgorithmType() == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaOaep)
				transformation = "RSA/ECB/OAEPWithSHA-1AndMGF1Padding";
			else
				throw new Exception("unsupported padding scheme");
	
			Cipher cipher = javax.crypto.Cipher.getInstance(transformation);
			cipher.init(javax.crypto.Cipher.DECRYPT_MODE, privateKey);
			return new Blob(cipher.doFinal(encryptedData.getImmutableArray()));
		}
	
		/// <summary>
		/// Encrypt the plainData using the keyBits according the encrypt params.
		/// </summary>
		///
		/// <param name="keyBits">The key value (DER-encoded public key).</param>
		/// <param name="plainData">The data to encrypt.</param>
		/// <param name="params">This encrypts according to params.getAlgorithmType().</param>
		/// <returns>The encrypted data.</returns>
		public static Blob encrypt(Blob keyBits, Blob plainData,
				EncryptParams paras) {
			System.SecurityPublicKey publicKey = keyFactory_
					.generatePublic(new X509EncodedKeySpec(keyBits
							.getImmutableArray()));
	
			String transformation;
			if (paras.getAlgorithmType() == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaPkcs)
				transformation = "RSA/ECB/PKCS1Padding";
			else if (paras.getAlgorithmType() == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaOaep)
				transformation = "RSA/ECB/OAEPWithSHA-1AndMGF1Padding";
			else
				throw new Exception("unsupported padding scheme");
	
			Cipher cipher = javax.crypto.Cipher.getInstance(transformation);
			cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, publicKey);
			return new Blob(cipher.doFinal(plainData.getImmutableArray()));
		}
	
		// TODO: Move this to a common utility?
		private static readonly SecureRandom random_ = new SecureRandom();
		private static KeyFactory keyFactory_;
		static RsaAlgorithm() {
				try {
					keyFactory_ = System.KeyFactory.getInstance("RSA");
				} catch (Exception ex) {
					ILOG.J2CsMapping.Util.Logging.Logger.getLogger(typeof(RsaAlgorithm).FullName)
							.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, null, ex);
				}
			}
	}
}
