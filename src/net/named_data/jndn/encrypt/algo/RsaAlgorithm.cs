// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2015-2018 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.encrypt.algo {
	
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.spec;
	using javax.crypto;
	using net.named_data.jndn.encrypt;
	using net.named_data.jndn.security;
	using net.named_data.jndn.security.tpm;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// The RsaAlgorithm class provides static methods to manipulate keys, encrypt
	/// and decrypt using RSA.
	/// </summary>
	///
	/// @note This class is an experimental feature. The API may change.
	public class RsaAlgorithm {
		/// <summary>
		/// Generate a new random decrypt key for RSA based on the given params.
		/// </summary>
		///
		/// <param name="params">The key params with the key size (in bits).</param>
		/// <returns>The new decrypt key (PKCS8-encoded private key).</returns>
		public static DecryptKey generateKey(RsaKeyParams paras) {
			TpmPrivateKey privateKey;
			try {
				privateKey = net.named_data.jndn.security.tpm.TpmPrivateKey.generatePrivateKey(paras);
			} catch (ArgumentException ex) {
				throw new SecurityException(
						"generateKey: Error in generatePrivateKey: " + ex);
			} catch (TpmPrivateKey.Error ex_0) {
				throw new SecurityException(
						"generateKey: Error in generatePrivateKey: " + ex_0);
			}
	
			try {
				return new DecryptKey(privateKey.toPkcs8());
			} catch (TpmPrivateKey.Error ex_1) {
				throw new SecurityException("generateKey: Error in toPkcs8: " + ex_1);
			}
		}
	
		/// <summary>
		/// Derive a new encrypt key from the given decrypt key value.
		/// </summary>
		///
		/// <param name="keyBits"></param>
		/// <returns>The new encrypt key (DER-encoded public key).</returns>
		public static EncryptKey deriveEncryptKey(Blob keyBits) {
			TpmPrivateKey privateKey = new TpmPrivateKey();
			try {
				privateKey.loadPkcs8(keyBits.buf());
			} catch (TpmPrivateKey.Error ex) {
				throw new SecurityException(
						"deriveEncryptKey: Error in loadPkcs8: " + ex);
			}
	
			try {
				return new EncryptKey(privateKey.derivePublicKey());
			} catch (TpmPrivateKey.Error ex_0) {
				throw new SecurityException(
						"deriveEncryptKey: Error in derivePublicKey: " + ex_0);
			}
		}
	
		/// <summary>
		/// Decrypt the encryptedData using the keyBits according the encrypt params.
		/// </summary>
		///
		/// <param name="keyBits">The key value (PKCS8-encoded private key).</param>
		/// <param name="encryptedData">The data to decrypt.</param>
		/// <param name="params">This decrypts according to params.getAlgorithmType().</param>
		/// <returns>The decrypted data.</returns>
		public static Blob decrypt(Blob keyBits, Blob encryptedData,
				EncryptParams paras) {
			TpmPrivateKey privateKey = new TpmPrivateKey();
			try {
				privateKey.loadPkcs8(keyBits.buf());
			} catch (TpmPrivateKey.Error ex) {
				throw new SecurityException("decrypt: Error in loadPkcs8: " + ex);
			}
	
			try {
				return privateKey.decrypt(encryptedData.buf(),
						paras.getAlgorithmType());
			} catch (TpmPrivateKey.Error ex_0) {
				throw new SecurityException("decrypt: Error in decrypt: " + ex_0);
			}
		}
	
		/// <summary>
		/// Encrypt the plainData using the keyBits according the encrypt params.
		/// </summary>
		///
		/// <param name="keyBits">The key value (DER-encoded public key).</param>
		/// <param name="plainData">The data to encrypt.</param>
		/// <param name="params">This encrypts according to params.getAlgorithmType().</param>
		/// <returns>The encrypted data.</returns>
		public static Blob encrypt(Blob keyBits, Blob plainData,
				EncryptParams paras) {
			System.SecurityPublicKey publicKey = keyFactory_
					.generatePublic(new X509EncodedKeySpec(keyBits
							.getImmutableArray()));
	
			String transformation;
			if (paras.getAlgorithmType() == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaPkcs)
				transformation = "RSA/ECB/PKCS1Padding";
			else if (paras.getAlgorithmType() == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaOaep)
				transformation = "RSA/ECB/OAEPWithSHA-1AndMGF1Padding";
			else
				throw new Exception("unsupported padding scheme");
	
			Cipher cipher = javax.crypto.Cipher.getInstance(transformation);
			cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, publicKey);
			return new Blob(cipher.doFinal(plainData.getImmutableArray()), false);
		}
	
		private static KeyFactory keyFactory_;
	
		static RsaAlgorithm() {
				try {
					keyFactory_ = System.KeyFactory.getInstance("RSA");
				} catch (Exception ex) {
					ILOG.J2CsMapping.Util.Logging.Logger.getLogger(typeof(RsaAlgorithm).FullName)
							.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, null, ex);
				}
			}
	}
}
