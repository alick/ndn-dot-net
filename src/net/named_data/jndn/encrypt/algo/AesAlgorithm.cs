// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2015-2019 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.encrypt.algo {
	
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using javax.crypto;
	using javax.crypto.spec;
	using net.named_data.jndn.encrypt;
	using net.named_data.jndn.security;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// The AesAlgorithm class provides static methods to manipulate keys, encrypt
	/// and decrypt using the AES symmetric key cipher.
	/// </summary>
	///
	/// @note This class is an experimental feature. The API may change.
	public class AesAlgorithm {
		/// <summary>
		/// Generate a new random decrypt key for AES based on the given params.
		/// </summary>
		///
		/// <param name="params">The key params with the key size (in bits).</param>
		/// <returns>The new decrypt key.</returns>
		public static DecryptKey generateKey(AesKeyParams paras) {
			// Convert the key bit size to bytes.
			ByteBuffer key = ILOG.J2CsMapping.NIO.ByteBuffer.allocate(paras.getKeySize() / 8);
			net.named_data.jndn.util.Common.getRandom().nextBytes(key.array());
	
			DecryptKey decryptKey = new DecryptKey(new Blob(key, false));
			return decryptKey;
		}
	
		/// <summary>
		/// Derive a new encrypt key from the given decrypt key value.
		/// </summary>
		///
		/// <param name="keyBits">The key value of the decrypt key.</param>
		/// <returns>The new encrypt key.</returns>
		public static EncryptKey deriveEncryptKey(Blob keyBits) {
			return new EncryptKey(keyBits);
		}
	
		/// <summary>
		/// Decrypt the encryptedData using the keyBits according the encrypt params.
		/// </summary>
		///
		/// <param name="keyBits">The key value.</param>
		/// <param name="encryptedData">The data to decrypt.</param>
		/// <param name="params"></param>
		/// <returns>The decrypted data.</returns>
		public static Blob decrypt(Blob keyBits, Blob encryptedData,
				EncryptParams paras) {
			if (paras.getAlgorithmType() == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesEcb) {
				Cipher cipher = javax.crypto.Cipher.getInstance("AES/ECB/PKCS5PADDING");
				cipher.init(javax.crypto.Cipher.DECRYPT_MODE,
						new SecretKeySpec(keyBits.getImmutableArray(), "AES"));
				return new Blob(cipher.doFinal(encryptedData.getImmutableArray()),
						false);
			} else if (paras.getAlgorithmType() == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesCbc) {
				if (paras.getInitialVector().size() != BLOCK_SIZE)
					throw new Exception("incorrect initial vector size");
	
				Cipher cipher_0 = javax.crypto.Cipher.getInstance("AES/CBC/PKCS5PADDING");
				cipher_0.init(javax.crypto.Cipher.DECRYPT_MODE,
						new SecretKeySpec(keyBits.getImmutableArray(), "AES"),
						new IvParameterSpec(paras.getInitialVector()
								.getImmutableArray()));
				return new Blob(cipher_0.doFinal(encryptedData.getImmutableArray()),
						false);
			} else
				throw new Exception("unsupported encryption mode");
		}
	
		/// <summary>
		/// Encrypt the plainData using the keyBits according the encrypt params.
		/// </summary>
		///
		/// <param name="keyBits">The key value.</param>
		/// <param name="plainData">The data to encrypt.</param>
		/// <param name="params"></param>
		/// <returns>The encrypted data.</returns>
		public static Blob encrypt(Blob keyBits, Blob plainData,
				EncryptParams paras) {
			if (paras.getAlgorithmType() == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesEcb) {
				Cipher cipher = javax.crypto.Cipher.getInstance("AES/ECB/PKCS5PADDING");
				cipher.init(javax.crypto.Cipher.ENCRYPT_MODE,
						new SecretKeySpec(keyBits.getImmutableArray(), "AES"));
				return new Blob(cipher.doFinal(plainData.getImmutableArray()),
						false);
			} else if (paras.getAlgorithmType() == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesCbc) {
				if (paras.getInitialVector().size() != BLOCK_SIZE)
					throw new Exception("incorrect initial vector size");
	
				Cipher cipher_0 = javax.crypto.Cipher.getInstance("AES/CBC/PKCS5PADDING");
				cipher_0.init(javax.crypto.Cipher.ENCRYPT_MODE,
						new SecretKeySpec(keyBits.getImmutableArray(), "AES"),
						new IvParameterSpec(paras.getInitialVector()
								.getImmutableArray()));
				return new Blob(cipher_0.doFinal(plainData.getImmutableArray()),
						false);
			} else
				throw new Exception("unsupported encryption mode");
		}
	
		public const int BLOCK_SIZE = 16;
	}
}
