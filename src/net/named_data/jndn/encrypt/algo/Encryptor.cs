// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2015-2017 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.encrypt.algo {
	
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.spec;
	using javax.crypto;
	using net.named_data.jndn;
	using net.named_data.jndn.encrypt;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// Encryptor has static constants and utility methods for encryption, such as
	/// encryptData.
	/// </summary>
	///
	public class Encryptor {
		public static readonly Name.Component NAME_COMPONENT_FOR = new Name.Component(
				"FOR");
		public static readonly Name.Component NAME_COMPONENT_READ = new Name.Component(
				"READ");
		public static readonly Name.Component NAME_COMPONENT_SAMPLE = new Name.Component(
				"SAMPLE");
		public static readonly Name.Component NAME_COMPONENT_ACCESS = new Name.Component(
				"ACCESS");
		public static readonly Name.Component NAME_COMPONENT_E_KEY = new Name.Component(
				"E-KEY");
		public static readonly Name.Component NAME_COMPONENT_D_KEY = new Name.Component(
				"D-KEY");
		public static readonly Name.Component NAME_COMPONENT_C_KEY = new Name.Component(
				"C-KEY");
	
		/// <summary>
		/// Prepare an encrypted data packet by encrypting the payload using the key
		/// according to the params. In addition, this prepares the encoded
		/// EncryptedContent with the encryption result using keyName and params. The
		/// encoding is set as the content of the data packet. If params defines an
		/// asymmetric encryption algorithm and the payload is larger than the maximum
		/// plaintext size, this encrypts the payload with a symmetric key that is
		/// asymmetrically encrypted and provided as a nonce in the content of the data
		/// packet. The packet's /{dataName}/ is updated to be
		/// /{dataName}/FOR/{keyName}
		/// </summary>
		///
		/// <param name="data">The data packet which is updated.</param>
		/// <param name="payload">The payload to encrypt.</param>
		/// <param name="keyName">The key name for the EncryptedContent.</param>
		/// <param name="key">The encryption key value.</param>
		/// <param name="params">The parameters for encryption.</param>
		public static void encryptData(Data data, Blob payload, Name keyName,
				Blob key, EncryptParams paras) {
			data.getName().append(NAME_COMPONENT_FOR).append(keyName);
	
			EncryptAlgorithmType algorithmType = paras.getAlgorithmType();
	
			if (algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesCbc
					|| algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesEcb) {
				EncryptedContent content = encryptSymmetric(payload, key, keyName,
						paras);
				data.setContent(content.wireEncode(net.named_data.jndn.encoding.TlvWireFormat.get()));
			} else if (algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaPkcs
					|| algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaOaep) {
				// Java doesn't have a direct way to get the maximum plain text size, so
				// try to encrypt the payload first and catch the error if it is too big.
				try {
					EncryptedContent content_0 = encryptAsymmetric(payload, key,
							keyName, paras);
					data.setContent(content_0.wireEncode(net.named_data.jndn.encoding.TlvWireFormat.get()));
					return;
				} catch (IllegalBlockSizeException ex) {
					// The payload is larger than the maximum plaintext size. Continue.
				}
	
				// 128-bit nonce.
				ByteBuffer nonceKeyBuffer = ILOG.J2CsMapping.NIO.ByteBuffer.allocate(16);
				net.named_data.jndn.util.Common.getRandom().nextBytes(nonceKeyBuffer.array());
				Blob nonceKey = new Blob(nonceKeyBuffer, false);
	
				Name nonceKeyName = new Name(keyName);
				nonceKeyName.append("nonce");
	
				EncryptParams symmetricParams = new EncryptParams(
						net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesCbc, net.named_data.jndn.encrypt.algo.AesAlgorithm.BLOCK_SIZE);
	
				EncryptedContent nonceContent = encryptSymmetric(payload, nonceKey,
						nonceKeyName, symmetricParams);
	
				EncryptedContent payloadContent = encryptAsymmetric(nonceKey, key,
						keyName, paras);
	
				Blob nonceContentEncoding = nonceContent.wireEncode();
				Blob payloadContentEncoding = payloadContent.wireEncode();
				ByteBuffer content_1 = ILOG.J2CsMapping.NIO.ByteBuffer.allocate(nonceContentEncoding
						.size() + payloadContentEncoding.size());
				content_1.put(payloadContentEncoding.buf());
				content_1.put(nonceContentEncoding.buf());
				content_1.flip();
	
				data.setContent(new Blob(content_1, false));
			} else
				throw new Exception("Unsupported encryption method");
		}
	
		/// <summary>
		/// Encrypt the payload using the symmetric key according to params, and return
		/// an EncryptedContent.
		/// </summary>
		///
		/// <param name="payload">The data to encrypt.</param>
		/// <param name="key">The key value.</param>
		/// <param name="keyName">The key name for the EncryptedContent key locator.</param>
		/// <param name="params">The parameters for encryption.</param>
		/// <returns>A new EncryptedContent.</returns>
		private static EncryptedContent encryptSymmetric(Blob payload, Blob key,
				Name keyName, EncryptParams paras) {
			EncryptAlgorithmType algorithmType = paras.getAlgorithmType();
			Blob initialVector = paras.getInitialVector();
			KeyLocator keyLocator = new KeyLocator();
			keyLocator.setType(net.named_data.jndn.KeyLocatorType.KEYNAME);
			keyLocator.setKeyName(keyName);
	
			if (algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesCbc
					|| algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesEcb) {
				if (algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.AesCbc) {
					if (initialVector.size() != net.named_data.jndn.encrypt.algo.AesAlgorithm.BLOCK_SIZE)
						throw new Exception("incorrect initial vector size");
				}
	
				Blob encryptedPayload = net.named_data.jndn.encrypt.algo.AesAlgorithm.encrypt(key, payload, paras);
	
				EncryptedContent result = new EncryptedContent();
				result.setAlgorithmType(algorithmType);
				result.setKeyLocator(keyLocator);
				result.setPayload(encryptedPayload);
				result.setInitialVector(initialVector);
				return result;
			} else
				throw new Exception("Unsupported encryption method");
		}
	
		/// <summary>
		/// Encrypt the payload using the asymmetric key according to params, and
		/// return an EncryptedContent.
		/// </summary>
		///
		/// <param name="payload"></param>
		/// <param name="key">The key value.</param>
		/// <param name="keyName">The key name for the EncryptedContent key locator.</param>
		/// <param name="params">The parameters for encryption.</param>
		/// <returns>A new EncryptedContent.</returns>
		private static EncryptedContent encryptAsymmetric(Blob payload, Blob key,
				Name keyName, EncryptParams paras) {
			EncryptAlgorithmType algorithmType = paras.getAlgorithmType();
			KeyLocator keyLocator = new KeyLocator();
			keyLocator.setType(net.named_data.jndn.KeyLocatorType.KEYNAME);
			keyLocator.setKeyName(keyName);
	
			if (algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaPkcs
					|| algorithmType == net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaOaep) {
				Blob encryptedPayload = net.named_data.jndn.encrypt.algo.RsaAlgorithm.encrypt(key, payload, paras);
	
				EncryptedContent result = new EncryptedContent();
				result.setAlgorithmType(algorithmType);
				result.setKeyLocator(keyLocator);
				result.setPayload(encryptedPayload);
				return result;
			} else
				throw new Exception("Unsupported encryption method");
		}
	}
}
