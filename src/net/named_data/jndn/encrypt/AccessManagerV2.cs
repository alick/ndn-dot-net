// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2018 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.encrypt {
	
	using ILOG.J2CsMapping.NIO;
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.spec;
	using javax.crypto;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.in_memory_storage;
	using net.named_data.jndn.security;
	using net.named_data.jndn.security.certificate;
	using net.named_data.jndn.security.pib;
	using net.named_data.jndn.security.tpm;
	using net.named_data.jndn.security.v2;
	
	/// <summary>
	/// AccessManagerV2 controls the decryption policy by publishing granular
	/// per-namespace access policies in the form of key encryption
	/// (KEK, plaintext public) and key decryption (KDK, encrypted private key)
	/// key pairs. This works with EncryptorV2 and DecryptorV2 using security v2.
	/// For the meaning of "KDK", etc. see:
	/// https://github.com/named-data/name-based-access-control/blob/new/docs/spec.rst
	/// </summary>
	///
	public class AccessManagerV2 {
		public sealed class Anonymous_C1 : OnInterestCallback {
				private readonly AccessManagerV2 outer_AccessManagerV2;
		
				public Anonymous_C1(AccessManagerV2 paramouter_AccessManagerV2) {
					this.outer_AccessManagerV2 = paramouter_AccessManagerV2;
				}
		
				public void onInterest(Name prefix, Interest interest, Face face,
						long interestFilterId, InterestFilter filter) {
					Data data = outer_AccessManagerV2.storage_.find(interest);
					if (data != null) {
						net.named_data.jndn.encrypt.AccessManagerV2.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.INFO,
								"Serving {0} from in-memory-storage",
								data.getName());
						try {
							face.putData(data);
						} catch (Exception ex) {
							net.named_data.jndn.encrypt.AccessManagerV2.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
									"AccessManagerV2: Error in Face.putData", ex);
						}
					} else {
						net.named_data.jndn.encrypt.AccessManagerV2.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.INFO, "Didn't find data for {0}",
								interest.getName());
						// TODO: Send NACK?
					}
				}
			}
		public sealed class Anonymous_C0 : OnRegisterFailed {
			public void onRegisterFailed(Name prefix) {
				net.named_data.jndn.encrypt.AccessManagerV2.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
						"AccessManagerV2: Failed to register prefix {0}",
						prefix.toUri());
			}
		}
		/// <summary>
		/// Create an AccessManagerV2 to serve the NAC public key for other data
		/// producers to fetch, and to serve encrypted versions of the private keys
		/// (as safe bags) for authorized consumers to fetch.
		/// KEK and KDK naming:
		/// [identity]/NAC/[dataset]/KEK            /[key-id]                           (== KEK, public key)
		/// [identity]/NAC/[dataset]/KDK/[key-id]   /ENCRYPTED-BY/[user]/KEY/[key-id]   (== KDK, encrypted private key)
		/// \_____________  ______________/
		/// \/
		/// registered with NFD
		/// </summary>
		///
		/// <param name="identity"></param>
		/// <param name="dataset">The name of dataset that this manager is controlling.</param>
		/// <param name="keyChain">The KeyChain used to sign Data packets.</param>
		/// <param name="face"></param>
		public AccessManagerV2(PibIdentity identity, Name dataset,
				KeyChain keyChain, Face face) {
			this.storage_ = new InMemoryStorageRetaining();
			identity_ = identity;
			keyChain_ = keyChain;
			face_ = face;
	
			// The NAC identity is: <identity>/NAC/<dataset>
			// Generate the NAC key.
			PibIdentity nacIdentity = keyChain_.createIdentityV2(
					new Name(identity.getName()).append(
							net.named_data.jndn.encrypt.EncryptorV2.NAME_COMPONENT_NAC).append(dataset),
					new RsaKeyParams());
			nacKey_ = nacIdentity.getDefaultKey();
			if (nacKey_.getKeyType() != net.named_data.jndn.security.KeyType.RSA) {
				logger_.log(ILOG.J2CsMapping.Util.Logging.Level.INFO,
						"Cannot re-use existing KEK/KDK pair, as it is not an RSA key, regenerating");
				nacKey_ = keyChain_.createKey(nacIdentity, new RsaKeyParams());
			}
			Name.Component nacKeyId = nacKey_.getName().get(-1);
	
			Name kekPrefix = new Name(nacKey_.getIdentityName())
					.append(net.named_data.jndn.encrypt.EncryptorV2.NAME_COMPONENT_KEK);
	
			Data kekData = new Data(nacKey_.getDefaultCertificate());
			kekData.setName(new Name(kekPrefix).append(nacKeyId));
			kekData.getMetaInfo().setFreshnessPeriod(
					DEFAULT_KEK_FRESHNESS_PERIOD_MS);
			keyChain_.sign(kekData, new SigningInfo(identity_));
			// kek looks like a cert, but doesn't have ValidityPeriod
			storage_.insert(kekData);
	
			OnInterestCallback serveFromStorage = new AccessManagerV2.Anonymous_C1 (this);
	
			OnRegisterFailed registerFailed = new AccessManagerV2.Anonymous_C0 ();
	
			kekRegisteredPrefixId_ = face_.registerPrefix(kekPrefix,
					serveFromStorage, registerFailed);
	
			Name kdkPrefix = new Name(nacKey_.getIdentityName()).append(
					net.named_data.jndn.encrypt.EncryptorV2.NAME_COMPONENT_KDK).append(nacKeyId);
			kdkRegisteredPrefixId_ = face_.registerPrefix(kdkPrefix,
					serveFromStorage, registerFailed);
		}
	
		public void shutdown() {
			face_.unsetInterestFilter(kekRegisteredPrefixId_);
			face_.unsetInterestFilter(kdkRegisteredPrefixId_);
		}
	
		/// <summary>
		/// Authorize a member identified by memberCertificate to decrypt data under
		/// the policy.
		/// </summary>
		///
		/// <param name="memberCertificate"></param>
		/// <returns>The published KDK Data packet.</returns>
		public Data addMember(CertificateV2 memberCertificate) {
			Name kdkName = new Name(nacKey_.getIdentityName());
			kdkName.append(net.named_data.jndn.encrypt.EncryptorV2.NAME_COMPONENT_KDK)
					.append(nacKey_.getName().get(-1))
					// key-id
					.append(net.named_data.jndn.encrypt.EncryptorV2.NAME_COMPONENT_ENCRYPTED_BY)
					.append(memberCertificate.getKeyName());
	
			int secretLength = 32;
			byte[] secret = new byte[secretLength];
			net.named_data.jndn.util.Common.getRandom().nextBytes(secret);
			// To be compatible with OpenSSL which uses a null-terminated string,
			// replace each 0 with 1. And to be compatible with the Java security
			// library interprets the secret as a char array converted to UTF8, limit
			// each byte to the ASCII range 1 to 127.
			for (int i = 0; i < secretLength; ++i) {
				if (secret[i] == 0)
					secret[i] = 1;
	
				secret[i] &= 0x7f;
			}
	
			SafeBag kdkSafeBag = keyChain_.exportSafeBag(
					nacKey_.getDefaultCertificate(), ILOG.J2CsMapping.NIO.ByteBuffer.wrap(secret));
	
			PublicKey memberKey = new PublicKey(memberCertificate.getPublicKey());
	
			EncryptedContent encryptedContent = new EncryptedContent();
			encryptedContent.setPayload(kdkSafeBag.wireEncode());
			encryptedContent.setPayloadKey(memberKey.encrypt(secret,
					net.named_data.jndn.encrypt.algo.EncryptAlgorithmType.RsaOaep));
	
			Data kdkData = new Data(kdkName);
			kdkData.setContent(encryptedContent.wireEncodeV2());
			// FreshnessPeriod can serve as a soft access control for revoking access
			kdkData.getMetaInfo().setFreshnessPeriod(
					DEFAULT_KDK_FRESHNESS_PERIOD_MS);
			keyChain_.sign(kdkData, new SigningInfo(identity_));
	
			storage_.insert(kdkData);
	
			return kdkData;
		}
	
		/// <summary>
		/// The number of packets stored in in-memory storage.
		/// </summary>
		///
		/// <returns>The number of packets.</returns>
		public int size() {
			return storage_.size();
		}
	
		/// <summary>
		/// Get the the storage cache, which should only be used for testing.
		/// </summary>
		///
		/// <returns>The storage cache.</returns>
		public Hashtable getCache_() {
			return storage_.getCache_();
		}
	
		private readonly PibIdentity identity_;
		private PibKey nacKey_;
		private readonly KeyChain keyChain_;
		private readonly Face face_;
	
		// storage_ is for the KEK and KDKs.
		internal readonly InMemoryStorageRetaining storage_;
		private readonly long kekRegisteredPrefixId_;
		private readonly long kdkRegisteredPrefixId_;
		static internal readonly Logger logger_ = ILOG.J2CsMapping.Util.Logging.Logger
				.getLogger(typeof(AccessManagerV2).FullName);
	
		private const double DEFAULT_KEK_FRESHNESS_PERIOD_MS = 3600 * 1000.0d;
		private const double DEFAULT_KDK_FRESHNESS_PERIOD_MS = 3600 * 1000.0d;
	}
}
