// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 12/23/15 3:55 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2015 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn {
	
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// A DelegationSet holds a list of DelegationSet.Delegation entries which is
	/// used as the content of a Link instance. If you add elements with add(), then
	/// the list is a set sorted by preference number then by name. But wireDecode
	/// will add the elements from the wire encoding, preserving the given order and
	/// possible duplicates (in which case a DelegationSet really holds a "list" and
	/// not necessarily a "set").
	/// </summary>
	///
	public class DelegationSet {
		/// <summary>
		/// Create a DelegationSet with an empty list of delegations.
		/// </summary>
		///
		public DelegationSet() {
			this.delegations_ = new ArrayList();
		}
	
		/// <summary>
		/// Create a DelegationSet, copying values from the other DelegationSet.
		/// </summary>
		///
		/// <param name="delegationSet">The DelegationSet to copy values from.</param>
		public DelegationSet(DelegationSet delegationSet) {
			this.delegations_ = new ArrayList();
			delegations_.AddRange(delegationSet.delegations_);
		}
	
		/// <summary>
		/// A DelegationSet.Delegation holds a preference number and delegation name.
		/// </summary>
		///
		public class Delegation {
			/// <summary>
			/// Create a new DelegationSet.Delegation with the given values.
			/// </summary>
			///
			/// <param name="preference">The preference number.</param>
			/// <param name="name">The delegation name. This makes a copy of the name.</param>
			public Delegation(int preference, Name name) {
				preference_ = preference;
				name_ = new Name(name);
			}
	
			/// <summary>
			/// Get the preference number.
			/// </summary>
			///
			/// <returns>The preference number.</returns>
			public int getPreference() {
				return preference_;
			}
	
			/// <summary>
			/// Get the delegation name.
			/// </summary>
			///
			/// <returns>The delegation name. NOTE: You must not change the name object -
			/// if you need to change it then make a copy.</returns>
			public Name getName() {
				return name_;
			}
	
			/// <summary>
			/// Compare this Delegation with other according to the ordering, based first
			/// on the preference number, then on the delegation name.
			/// </summary>
			///
			/// <param name="other">The other Delegation to compare with.</param>
			/// <returns>0 If they compare equal, -1 if this Delegation comes before other
			/// in the ordering, or 1 if this Delegation comes after.</returns>
			public int compare(DelegationSet.Delegation  other) {
				if (preference_ < other.preference_)
					return -1;
				if (preference_ > other.preference_)
					return 1;
	
				return name_.compare(other.name_);
			}
	
			private readonly int preference_;
			private readonly Name name_;
		}
	
		/// <summary>
		/// Add a new DelegationSet.Delegation to the list of delegations, sorted by
		/// preference number then by name. If there is already a delegation with the
		/// same name, update its preference, and remove any extra delegations with the
		/// same name.
		/// </summary>
		///
		/// <param name="preference">The preference number.</param>
		/// <param name="name">The delegation name. This makes a copy of the name.</param>
		public void add(int preference, Name name) {
			remove(name);
	
			DelegationSet.Delegation  newDelegation = new DelegationSet.Delegation (preference, name);
			// Find the index of the first entry where it is not less than newDelegation.
			int i = 0;
			while (i < delegations_.Count) {
				if (((DelegationSet.Delegation ) delegations_[i]).compare(newDelegation) >= 0)
					break;
	
				++i;
			}
	
			delegations_.Insert(i, newDelegation);
		}
	
		/// <summary>
		/// Add a new DelegationSet.Delegation to the end of the list of delegations,
		/// without sorting or updating any existing entries. This is useful for adding
		/// preferences from a wire encoding, preserving the supplied ordering and
		/// possible duplicates.
		/// </summary>
		///
		/// <param name="preference">The preference number.</param>
		/// <param name="name">The delegation name. This makes a copy of the name.</param>
		public void addUnsorted(int preference, Name name) {
			ILOG.J2CsMapping.Collections.Collections.Add(delegations_,new DelegationSet.Delegation (preference, name));
		}
	
		/// <summary>
		/// Remove every DelegationSet.Delegation with the given name.
		/// </summary>
		///
		/// <param name="name">Then name to match the name of the delegation(s) to be removed.</param>
		/// <returns>True if a DelegationSet.Delegation was removed, otherwise false.</returns>
		public bool remove(Name name) {
			bool wasRemoved = false;
			// Go backwards through the list so we can remove entries.
			for (int i = delegations_.Count - 1; i >= 0; --i) {
				if (((DelegationSet.Delegation ) delegations_[i]).getName().equals(name)) {
					wasRemoved = true;
					ILOG.J2CsMapping.Collections.Collections.RemoveAt(delegations_,i);
				}
			}
	
			return wasRemoved;
		}
	
		/// <summary>
		/// Clear the list of delegations.
		/// </summary>
		///
		public void clear() {
			ILOG.J2CsMapping.Collections.Collections.Clear(delegations_);
		}
	
		/// <summary>
		/// Get the number of delegation entries.
		/// </summary>
		///
		/// <returns>The number of delegation entries.</returns>
		public int size() {
			return delegations_.Count;
		}
	
		/// <summary>
		/// Get the delegation at the given index, according to the ordering described
		/// in add().
		/// </summary>
		///
		/// <param name="i">The index of the component, starting from 0.</param>
		/// <returns>The delegation at the index.</returns>
		public DelegationSet.Delegation  get(int i) {
			return (DelegationSet.Delegation ) delegations_[i];
		}
	
		/// <summary>
		/// Find the first delegation with the given name and return its index.
		/// </summary>
		///
		/// <param name="name">Then name of the delegation to find.</param>
		/// <returns>The index of the delegation, or -1 if not found.</returns>
		public int find(Name name) {
			for (int i = 0; i < delegations_.Count; ++i) {
				if (((DelegationSet.Delegation ) delegations_[i]).getName().equals(name))
					return i;
			}
	
			return -1;
		}
	
		/// <summary>
		/// Encode this DelegationSet for a particular wire format.
		/// </summary>
		///
		/// <param name="wireFormat">A WireFormat object used to encode this DelegationSet.</param>
		/// <returns>The encoded buffer.</returns>
		public Blob wireEncode(WireFormat wireFormat) {
			return wireFormat.encodeDelegationSet(this);
		}
	
		/// <summary>
		/// Encode this DelegationSet for the default wire format
		/// WireFormat.getDefaultWireFormat().
		/// </summary>
		///
		/// <returns>The encoded buffer.</returns>
		public Blob wireEncode() {
			return wireEncode(net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Decode the input using a particular wire format and update this
		/// DelegationSet, using addUnsorted() to preserve the given order and
		/// possible duplicates.
		/// </summary>
		///
		/// <param name="input"></param>
		/// <param name="wireFormat">A WireFormat object used to decode the input.</param>
		/// <exception cref="EncodingException">For invalid encoding.</exception>
		public void wireDecode(ByteBuffer input, WireFormat wireFormat) {
			wireFormat.decodeDelegationSet(this, input);
		}
	
		/// <summary>
		/// Decode the input using the default wire format
		/// WireFormat.getDefaultWireFormat() and update this DelegationSet, using
		/// addUnsorted() to preserve the given order and possible duplicates.
		/// </summary>
		///
		/// <param name="input"></param>
		/// <exception cref="EncodingException">For invalid encoding.</exception>
		public void wireDecode(ByteBuffer input) {
			wireDecode(input, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Decode the input using a particular wire format and update this DelegationSet.
		/// </summary>
		///
		/// <param name="input">The input blob to decode.</param>
		/// <param name="wireFormat">A WireFormat object used to decode the input.</param>
		/// <exception cref="EncodingException">For invalid encoding.</exception>
		public void wireDecode(Blob input, WireFormat wireFormat) {
			wireDecode(input.buf(), wireFormat);
		}
	
		/// <summary>
		/// Decode the input using the default wire format
		/// WireFormat.getDefaultWireFormat() and update this DelegationSet.
		/// </summary>
		///
		/// <param name="input">The input blob to decode.</param>
		/// <exception cref="EncodingException">For invalid encoding.</exception>
		public void wireDecode(Blob input) {
			wireDecode(input.buf());
		}
	
		// Use ArrayList without generics so it works with older Java compilers.
		private readonly ArrayList delegations_;
	}
}
